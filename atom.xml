<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zgshen&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zguishen.com/"/>
  <updated>2021-07-19T05:30:14.072Z</updated>
  <id>https://zguishen.com/</id>
  
  <author>
    <name>zguishen</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>IDEA 部署 Docker 到 WSL2</title>
    <link href="https://zguishen.com/posts/4f490049.html"/>
    <id>https://zguishen.com/posts/4f490049.html</id>
    <published>2021-07-18T16:00:00.000Z</published>
    <updated>2021-07-19T05:30:14.072Z</updated>
    
    <content type="html"><![CDATA[<p>本地环境 Windows10+WSL2(Ubuntu)</p><p>在服务器安装 Docker 之后，开启远程访问</p><p> <code>sudo vi /etc/default/docker</code> 修改配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开启远程访问 -H tcp://0.0.0.0:2375</span></span><br><span class="line"><span class="comment"># 开启本地套接字访问 -H unix:///var/run/docker.sock</span></span><br><span class="line">DOCKER_OPTS=<span class="string">"-H tcp://0.0.0.0:2375 -H unix:///var/run/docker.sock"</span></span><br></pre></td></tr></table></figure><p><code>sudo service docker restart</code> 重启</p><p>Idea 安装 Docker 插件后，设置填写地址 tcp://192.168.50.28:2375 ，成功连接的话有 Connection Successful 提示</p><p><img src="../images/20210719/1626669684831.png" alt></p><p>Tools 选项配置，需要先安装 Windows 版本 Docker，装完把程序关掉，开机自启关掉，因为我不想多开一个程序，Ubuntu 里已经有 Docker 了，这里只是要用到 docker-compose.exe 在 Windows 环境做下容器编排而已。Docker Machine 用不着也不用管。</p><p><img src="../images/20210719/1626669715195.png" alt></p><p>一般的 Dockerfile 文件和 docker-compose.yml 文件参考</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:latest</span><br><span class="line"></span><br><span class="line">COPY target/*.jar /app.jar</span><br><span class="line"></span><br><span class="line">ENV JAVA_HOME=<span class="string">"/usr/lib/jdk1.8"</span></span><br><span class="line"></span><br><span class="line">ENV PATH=<span class="string">"<span class="variable">$&#123;PATH&#125;</span>:<span class="variable">$&#123;JAVA_HOME&#125;</span>/bin:<span class="variable">$&#123;JAVA_HOME&#125;</span>/sbin"</span></span><br><span class="line"></span><br><span class="line">ENTRYPOINT [ <span class="string">"java"</span>, <span class="string">"-jar"</span>, <span class="string">"/app.jar"</span> ]</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">version: <span class="string">'3'</span></span><br><span class="line">services:</span><br><span class="line">  last:</span><br><span class="line">    build:</span><br><span class="line">      context: .</span><br><span class="line">      dockerfile: Dockerfile</span><br><span class="line">    ports:</span><br><span class="line">      - <span class="string">"18080:8080"</span></span><br><span class="line">    volumes:</span><br><span class="line">      - /usr/lib/jvm/java-8-openjdk-amd64:/usr/lib/jdk1.8 <span class="comment">#宿主机 jdk 映射给容器使用</span></span><br><span class="line">    tty: <span class="literal">true</span></span><br><span class="line">    network_mode: bridge</span><br><span class="line">    restart: always</span><br></pre></td></tr></table></figure><p>使用 Docker-compose 创建 Docker 容器</p><p><img src="../images/20210719/1626669727452.png" alt></p><p>Compose files 选择刚创建的 docker-compose.yml 文件</p><p>运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Deploying <span class="string">'Compose: lin-test'</span>...</span><br><span class="line"><span class="string">"C:\Program Files\Docker\Docker\resources\bin\docker-compose.exe"</span> -f D:\Project\gitFile\lin\lin-test\docker-compose.yml up -d</span><br><span class="line">Building last</span><br><span class="line">Sending build context to Docker daemon  61.72MB</span><br><span class="line">Step 1/5 : FROM ubuntu:latest</span><br><span class="line"> ---&gt; c29284518f49</span><br><span class="line">Step 2/5 : COPY target/*.jar /app.jar</span><br><span class="line"> ---&gt; f13f1a3f4a0d</span><br><span class="line">Step 3/5 : ENV JAVA_HOME=<span class="string">"/usr/lib/jdk1.8"</span></span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> ea05d01bf802</span><br><span class="line">Removing intermediate container ea05d01bf802</span><br><span class="line"> ---&gt; 9bb4f1a6be38</span><br><span class="line">Step 4/5 : ENV PATH=<span class="string">"<span class="variable">$&#123;PATH&#125;</span>:<span class="variable">$&#123;JAVA_HOME&#125;</span>/bin:<span class="variable">$&#123;JAVA_HOME&#125;</span>/sbin"</span></span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> 73ab542794a5</span><br><span class="line">Removing intermediate container 73ab542794a5</span><br><span class="line"> ---&gt; a6d791e7bd7c</span><br><span class="line">Step 5/5 : ENTRYPOINT [ <span class="string">"java"</span>, <span class="string">"-jar"</span>, <span class="string">"/app.jar"</span> ]</span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> e1704a59d50b</span><br><span class="line">Removing intermediate container e1704a59d50b</span><br><span class="line"> ---&gt; 8ee7a6f5b53a</span><br><span class="line">Successfully built 8ee7a6f5b53a</span><br><span class="line">Successfully tagged lin-test_last:latest</span><br><span class="line">SECURITY WARNING: You are building a Docker image from Windows against a non-Windows Docker host. All files and directories added to build context will have <span class="string">'-rwxr-xr-x'</span> permissions. It is recommended to double check and reset permissions <span class="keyword">for</span> sensitive files and directories.</span><br><span class="line"></span><br><span class="line">Use <span class="string">'docker scan'</span> to run Snyk tests against images to find vulnerabilities and learn how to fix them</span><br><span class="line">Image <span class="keyword">for</span> service last was built because it did not already exist. To rebuild this image you must use `docker-compose build` or `docker-compose up --build`.</span><br><span class="line">Creating lin-test_last_1 ... </span><br><span class="line">Creating lin-test_last_1 ... <span class="keyword">done</span></span><br><span class="line"><span class="string">'Compose: lin-test'</span> has been deployed successfully.</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本地环境 Windows10+WSL2(Ubuntu)&lt;/p&gt;
&lt;p&gt;在服务器安装 Docker 之后，开启远程访问&lt;/p&gt;
&lt;p&gt; &lt;code&gt;sudo vi /etc/default/docker&lt;/code&gt; 修改配置&lt;/p&gt;
&lt;figure class=&quot;highl
      
    
    </summary>
    
      <category term="技术" scheme="https://zguishen.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="其他" scheme="https://zguishen.com/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title>三年前海珠湖</title>
    <link href="https://zguishen.com/posts/168d311b.html"/>
    <id>https://zguishen.com/posts/168d311b.html</id>
    <published>2021-04-02T16:00:00.000Z</published>
    <updated>2021-07-19T05:30:14.072Z</updated>
    
    <content type="html"><![CDATA[<p>三年前的今天，当时跟大学的室友去海珠湖玩，过得真快。</p><p><img src="../images/20210403/IMG_20170403_141512.jpg" alt="海珠湖IMG_20170403_141512"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;三年前的今天，当时跟大学的室友去海珠湖玩，过得真快。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/20210403/IMG_20170403_141512.jpg&quot; alt=&quot;海珠湖IMG_20170403_141512&quot;&gt;&lt;/p&gt;

      
    
    </summary>
    
      <category term="生活" scheme="https://zguishen.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="其他" scheme="https://zguishen.com/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title>【轉載】打造「極度專注力」，其實很簡單</title>
    <link href="https://zguishen.com/posts/e43fadb9.html"/>
    <id>https://zguishen.com/posts/e43fadb9.html</id>
    <published>2021-03-15T16:00:00.000Z</published>
    <updated>2021-07-19T05:30:14.072Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>被打亂思緒要再重組的確很難，到現在我也仍未掌握「不被打斷」或是「即使被打斷還能輕鬆地整理好思緒、繼續做事」的能力。 注意力被分散的原因可能來自外部或內部，《極度專注力》這本書中則討論到如何開啟「極度專注力模式」。 作者克里斯・貝利（Chris Bailey）提到，想進入這個模式，有 4 個步驟。<br>不知道是為什麼，有時候在書寫時能夠專心致志完全不受外界干擾，一口氣將文章寫完，而有時候卻會不斷地被雜音或是內心所擾亂。</p></blockquote><p>你一定也有過這樣的經驗，就是當你終於順利進入了專注狀態，正要好好地完成手邊的工作時，剛好旁邊的人發出聲響或突然跟你說話，打斷了你好不容易開始連貫的思緒，讓組裝好的想法又亂成一團，必須費很大一番功夫才能重新整理好，更多時候還無法將思緒歸回原位。</p><p>被打亂思緒要再重組的確很難，到現在我也仍未掌握「不被打斷」或是「即使被打斷還能輕鬆地整理好思緒、繼續做事」的能力。</p><p>注意力被分散的原因可能來自外部或內部，《極度專注力》這本書中則討論到如何開啟「極度專注力模式」。</p><p>作者克里斯・貝利（Chris Bailey）提到，想進入這個模式，有 4 個步驟。</p><p>一、選定一項你打算專注其中的任務</p><p>有了目標我們才能知道如何安排注意力，有效地完成目標；沒有目標卻要保持專注的話不僅困難，還是浪費精力的行為；過多的目標也會使自己茫然無緒，不曉得該先把焦點放在哪一個目標上。</p><p>在你尚未開始工作前，請為自己設立幾個目標，並且規畫好要先做哪一件事，將順序排定，如此一來便能一次只專注在一個任務上。如果你沒有事先安排好處理各項任務的前後順序，在上工時你會發現自己困在不知道應該先做什麼的煩惱之中，導致注意力嚴重分散。</p><p>以我自己來說，都會先選好當日要進行的任務，若是沒有事先預定那天要完成哪些事項，等到要開始做了才在決定，就會像無頭蒼蠅一樣不知道要做什麼好，陷在五花八門的選項中。後來還發現就連每個項目的處理順序也都要先安排好，否則到時候也會膠著於設定要做的幾個目標上。我幾乎都會將當天一定要做完的事列為第一要務，一定是首先處理的工作，其餘的就依據重要性和時間排程來決定先後順序。</p><p>給自己設下限制，按照已排定的順序做事，就不會跟自己討價還價，也能讓注意力集中於正在進行的工作上，如此才能快速有效率地完成任務。</p><p>二、消除外部和內部干擾</p><p>訂定目標後的首要之務就是事先排除干擾，無論是外部或是內部干擾，事前排除都比事後排除還來得有效；因為只要放任大腦漫無目的地行動，大腦便會被更有趣的事物吸引，因而分心，造成生產力低落。所以事先消除干擾，例如把手機關掉，或是將不必要的網頁關閉，如此大腦就別無選擇，只能專注在任務上。</p><p>內在的干擾也是需要控制的，譬如大腦隨機的神遊以及突然冒出的念頭，將這些想法寫下來，能幫助大腦重新專注。研究顯示人的大腦有 47％ 的時間都在神遊，平均需要 22 分鐘才能再度返回工作狀態，所以排除干擾有助於阻止大腦神遊，否則可能需要花費不少時間才能讓大腦恢復專注。</p><p>對於這個部分我深有同感，大腦總是會不斷地冒出各種念頭，如同關不住的水龍頭，讓人無法好好地專心做事；所以為了預防這樣的情形出現，我會盡量排除可能的干擾。以前我會一邊寫文章一邊想著其他尚未做的事，或者想著自己訂閱的創作者所發布的新內容，因此寫著寫著就會被這些思維影響而分心；不過現在，我會在寫文章之前就將內容看完，或是先大致瀏覽，至於還沒做的工作就不去想，刻意使自己專心寫完文章才去做其他事，後來發現分心的次數減少了，寫文的速度也變快了。</p><p><img src="../images/20210316/1615880404580.png" alt="圖／Estée Janssens on Unsplash"><br>圖／Estée Janssens on Unsplash</p><p>三、把注意力集中在任務上</p><p>預先想好自己要專注多久，更有助於進入極度專注的模式。如果前面兩個步驟基礎打得夠深，後續的專注力就更強。能否集中注意力的關鍵就在於你有沒有確實執行前面兩個流程。</p><p>四、持續把注意力拉回選定的任務</p><p>儘管已經事先移除干擾，偶爾還是會有意外出現打擾我們，這個時候極度專注力就是在我們思緒被打亂或分心時，把注意力拉回到任務上的最佳幫手。只要前面幾道手續都有做好，有將根基打好，極度專注力便能幫助我們搶回被吸引走的注意力。</p><p>無論再怎麼完善的計畫，還是會有突如其來的干擾出現、打亂我們的專注力；即便我事先安排好要先專注進行的任務，依照順序並排除可能的干擾，在工作的當下還是會被外頭的聲響或別人的談話拉走注意力，或是被打斷思緒；所以就必須持續地拉回自己的注意力。儘管很難，但我發現，透過一次次拉回專注力的練習，自己就越來越能專注，不會再輕易被搶走注意力。</p><p>在需要專注力幫忙之時，先為自己設定一個目標，並且事先消除可能出現的干擾，這兩點是最重要的。如果能就此建立良好的基礎，開啟極度專注模式，讓極度專注力替你拉回神遊的大腦，就不需要懼怕其他人事物來打擾了。</p><p>執行編輯：張詠晴<br>核稿編輯：何承祐</p><p>Photo Credit：Ashley Knedler on Unsplash<br>原文链接[<a href="https://crossing.cw.com.tw/article/12893]" target="_blank" rel="noopener">https://crossing.cw.com.tw/article/12893]</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;被打亂思緒要再重組的確很難，到現在我也仍未掌握「不被打斷」或是「即使被打斷還能輕鬆地整理好思緒、繼續做事」的能力。 注意力被分散的原因可能來自外部或內部，《極度專注力》這本書中則討論到如何開啟「極度專注力模式」。 作者克里斯・貝利（Chris Ba
      
    
    </summary>
    
      <category term="生活" scheme="https://zguishen.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="转载" scheme="https://zguishen.com/tags/%E8%BD%AC%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>Counting Stars</title>
    <link href="https://zguishen.com/posts/feeb20a0.html"/>
    <id>https://zguishen.com/posts/feeb20a0.html</id>
    <published>2021-03-06T16:00:00.000Z</published>
    <updated>2021-07-19T05:30:14.072Z</updated>
    
    <content type="html"><![CDATA[<p>Simply Three 这版听起来又有另一种感觉。</p><iframe width="560" height="315" src="https://www.youtube.com/embed/bdkVzkIGjp0" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Simply Three 这版听起来又有另一种感觉。&lt;/p&gt;
&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/bdkVzkIGjp0&quot; frameborder=&quot;0&quot; allow=&quot;ac
      
    
    </summary>
    
      <category term="生活" scheme="https://zguishen.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="其他" scheme="https://zguishen.com/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title>过去半年生活买的一些电子电器产品评价</title>
    <link href="https://zguishen.com/posts/fe306d0f.html"/>
    <id>https://zguishen.com/posts/fe306d0f.html</id>
    <published>2021-02-25T16:00:00.000Z</published>
    <updated>2021-07-19T05:30:14.072Z</updated>
    
    <content type="html"><![CDATA[<p>去年七月离职之后，不再需要按上班节奏生活，有了许多时间做自己喜欢做的事情。在这期间也体验了许多有趣的事情，买了一些东西充实生活，有的好用，有的用了几次就吃灰了。<br><a id="more"></a></p><h3 id="1、华为WATCH-GT2（42mm）"><a href="#1、华为WATCH-GT2（42mm）" class="headerlink" title="1、华为WATCH GT2（42mm）"></a><strong>1、华为WATCH GT2（42mm）</strong></h3><p>买42mm版时因为觉得46mm看起来比较丑，42mm的好看，而且自己手腕比较细小的比较适合。续航官方说法一周，实际轻度使用，不开常亮差不多吧，5天充一次可以接受。买这个手表主要是觉得好看，可以检测心率，提醒久坐和跑步计步。其实手环这些功能也一样全都有，就是觉得好看才买。缺点就是跑步的时候想要跟踪运动轨迹，GPS功能实在不行，搜星半天还不怎么准。</p><h3 id="2、高漫1060pro-数位板"><a href="#2、高漫1060pro-数位板" class="headerlink" title="2、高漫1060pro 数位板"></a><strong>2、高漫1060pro 数位板</strong></h3><p>看了网络上那么多大佬画的那么漂亮的图，也想尝试自己画画，最重要的是，想要se图还可以自己，那岂不是好爽……<br>突然有热情就买了，但是绘画真不是简单的事情，不认真学个几年估计画不出像样的东西。不过着东西还能拿来做笔记，看文档的事情做标记做笔记还挺好用的。但是我没这个习惯，用得少，所以这数位板成了吃灰产品。</p><h3 id="3、双飞燕-A4TECH-FK11小键盘"><a href="#3、双飞燕-A4TECH-FK11小键盘" class="headerlink" title="3、双飞燕 A4TECH FK11小键盘"></a><strong>3、双飞燕 A4TECH FK11小键盘</strong></h3><p>去年11月入职新公司，公司给发了笔记本电脑，但这笔记本这是辣鸡，还特么必须只能用这个笔记本，不能自己带电脑。键盘敲得太难受了就买了这个双飞燕键盘，实际外接键盘个人感觉也没多爽，其实是上班不爽，之后12月离职，宿舍里还有日常用的n年前50块钱买的键盘，个人对键盘没什么需求，还一直用着。现在写这篇文章又把闲置的小键盘拿出来敲敲，其实还不错的，要是出差的时候也能带上不占地方。</p><h3 id="4、ZJXED家用电表"><a href="#4、ZJXED家用电表" class="headerlink" title="4、ZJXED家用电表"></a><strong>4、ZJXED家用电表</strong></h3><p>纯粹玩具了，用来看看电流电压功率的小玩意。</p><h3 id="5、实木取暖器烤火器"><a href="#5、实木取暖器烤火器" class="headerlink" title="5、实木取暖器烤火器"></a><strong>5、实木取暖器烤火器</strong></h3><p>最讨厌的季节是冬天，一冷整个人都不好。这个烤火器用来热脚的，很爽啊，脚暖了人精神好多了。</p><h3 id="7、澳柯玛（AUCMA）取暖器-暖风机"><a href="#7、澳柯玛（AUCMA）取暖器-暖风机" class="headerlink" title="7、澳柯玛（AUCMA）取暖器 暖风机"></a><strong>7、澳柯玛（AUCMA）取暖器 暖风机</strong></h3><p>天气更冷了，身体和手也觉得冷，受不了了再买了这个暖风机。结果广东的冬天很冷的时候也就几天，但是真不能忍。在公司上班的时候就没这么多想法了，公司还是比较暖和的，一闲下来有点冷觉得不行，看来还是要早点重新找工作上班了，没事干平常屁事反而多了。</p><h3 id="8、志高H20A6家用电磁炉和煎炒锅"><a href="#8、志高H20A6家用电磁炉和煎炒锅" class="headerlink" title="8、志高H20A6家用电磁炉和煎炒锅"></a><strong>8、志高H20A6家用电磁炉和煎炒锅</strong></h3><p>一个人生活自己煮饭，电磁炉绝对是神器，怎么就没早点买呢，干啥都行，而且快。一个电饭煲和一个电磁炉加上炒锅就可以做大多数想做的饭菜了。<br>但是这款电磁炉最低的火力都有1100w，想开小火持续煮东西就不怎么好了，调到最低档是开几秒停几秒的模式，勉强能用用。看了小米那款电磁炉调节范围就比较大，可能比较好用，但是这款胜在便宜点，个人也不是非要那么多功能的电磁炉。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;去年七月离职之后，不再需要按上班节奏生活，有了许多时间做自己喜欢做的事情。在这期间也体验了许多有趣的事情，买了一些东西充实生活，有的好用，有的用了几次就吃灰了。&lt;br&gt;
    
    </summary>
    
      <category term="生活" scheme="https://zguishen.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="其他" scheme="https://zguishen.com/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title>Java开发常用的Linux命令</title>
    <link href="https://zguishen.com/posts/8ecd9316.html"/>
    <id>https://zguishen.com/posts/8ecd9316.html</id>
    <published>2021-02-04T16:00:00.000Z</published>
    <updated>2021-07-19T05:30:14.072Z</updated>
    
    <content type="html"><![CDATA[<h2 id="系统信息"><a href="#系统信息" class="headerlink" title="系统信息"></a>系统信息</h2><h3 id="1-uname"><a href="#1-uname" class="headerlink" title="1. uname"></a>1. uname</h3><p>用于查看系统信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uname -a    显示全部信息</span><br></pre></td></tr></table></figure></p><h3 id="2-lscpu"><a href="#2-lscpu" class="headerlink" title="2. lscpu"></a>2. lscpu</h3><p>cpu 架构信息</p><h2 id="文件和目录操作"><a href="#文件和目录操作" class="headerlink" title="文件和目录操作"></a>文件和目录操作</h2><h3 id="1-ls"><a href="#1-ls" class="headerlink" title="1. ls"></a>1. ls</h3><p>列出文件或者目录的信息，目录的信息就是其中包含的文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">## ls [-aAdfFhilnrRSt] file|dir</span><br><span class="line">-a ：列出全部的文件</span><br><span class="line">-d ：仅列出目录本身</span><br><span class="line">-l ：以长数据串行列出，包含文件的属性与权限等等数据</span><br><span class="line">-h : 和 -l 一起使用，列出文件同时以合理易读的单位显示文件大小</span><br></pre></td></tr></table></figure><h3 id="2-cd"><a href="#2-cd" class="headerlink" title="2. cd"></a>2. cd</h3><p>更换当前目录。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd [相对路径或绝对路径]</span><br></pre></td></tr></table></figure></p><h3 id="3-mkdir"><a href="#3-mkdir" class="headerlink" title="3. mkdir"></a>3. mkdir</h3><p>创建目录。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">## mkdir [-mp] 目录名称</span><br><span class="line">-m ：配置目录权限</span><br><span class="line">-p ：递归创建目录</span><br></pre></td></tr></table></figure></p><h3 id="4-rmdir"><a href="#4-rmdir" class="headerlink" title="4. rmdir"></a>4. rmdir</h3><p>删除目录，目录必须为空。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rmdir [-p] 目录名称</span><br><span class="line">-p ：递归删除目录</span><br></pre></td></tr></table></figure></p><h3 id="5-touch"><a href="#5-touch" class="headerlink" title="5. touch"></a>5. touch</h3><p>更新文件时间或者建立新文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">## touch [-acdmt] filename</span><br><span class="line">-a ： 更新 atime</span><br><span class="line">-c ： 更新 ctime，若该文件不存在则不建立新文件</span><br><span class="line">-m ： 更新 mtime</span><br><span class="line">-d ： 后面可以接更新日期而不使用当前日期，也可以使用 --date=&quot;日期或时间&quot;</span><br><span class="line">-t ： 后面可以接更新时间而不使用当前时间，格式为[YYYYMMDDhhmm]</span><br></pre></td></tr></table></figure></p><h3 id="6-cp"><a href="#6-cp" class="headerlink" title="6. cp"></a>6. cp</h3><p>复制文件。如果源文件有两个以上，则目的文件一定要是目录才行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cp [-adfilprsu] source destination</span><br><span class="line">-a ：相当于 -dr --preserve=all</span><br><span class="line">-d ：若来源文件为链接文件，则复制链接文件属性而非文件本身</span><br><span class="line">-i ：若目标文件已经存在时，在覆盖前会先询问</span><br><span class="line">-p ：连同文件的属性一起复制过去</span><br><span class="line">-r ：递归复制</span><br><span class="line">-u ：destination 比 source 旧才更新 destination，或 destination 不存在的情况下才复制</span><br><span class="line">--preserve=all ：除了 -p 的权限相关参数外，还加入 SELinux 的属性, links, xattr 等也复制了</span><br></pre></td></tr></table></figure></p><h3 id="7-rm"><a href="#7-rm" class="headerlink" title="7. rm"></a>7. rm</h3><p>删除文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">## rm [-fir] 文件或目录</span><br><span class="line">-r ：递归删除</span><br></pre></td></tr></table></figure></p><h3 id="8-mv"><a href="#8-mv" class="headerlink" title="8. mv"></a>8. mv</h3><p>移动文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">## mv [-fiu] source destination</span><br><span class="line">## mv [options] source1 source2 source3 .... directory</span><br><span class="line">-f ： force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖</span><br></pre></td></tr></table></figure></p><h2 id="查看文件内容"><a href="#查看文件内容" class="headerlink" title="查看文件内容"></a>查看文件内容</h2><h3 id="1-cat"><a href="#1-cat" class="headerlink" title="1. cat"></a>1. cat</h3><p>取得文件内容。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">## cat [-AbEnTv] filename</span><br><span class="line">-n ：打印出行号，连同空白行也会有行号，-b 不会</span><br></pre></td></tr></table></figure></p><h3 id="2-tac"><a href="#2-tac" class="headerlink" title="2. tac"></a>2. tac</h3><p>是 cat 的反向操作，从最后一行开始打印。</p><h3 id="3-more"><a href="#3-more" class="headerlink" title="3. more"></a>3. more</h3><p>和 cat 不同的是它可以一页一页查看文件内容，比较适合大文件的查看。</p><h3 id="4-less"><a href="#4-less" class="headerlink" title="4. less"></a>4. less</h3><p>和 more 类似，但是多了一个向前翻页的功能。</p><h3 id="5-head"><a href="#5-head" class="headerlink" title="5. head"></a>5. head</h3><p>取得文件前几行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">## head [-n number] filename</span><br><span class="line">-n ：后面接数字，代表显示几行的意思</span><br></pre></td></tr></table></figure></p><h3 id="6-tail"><a href="#6-tail" class="headerlink" title="6. tail"></a>6. tail</h3><p>是 head 的反向操作，只是取得是后几行。<br>常用：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tail -f xx  <span class="comment">#实时查看</span></span><br><span class="line">tail -100f xx  <span class="comment">#实时查看最后的一百行</span></span><br></pre></td></tr></table></figure></p><h3 id="7-od"><a href="#7-od" class="headerlink" title="7. od"></a>7. od</h3><p>以字符或者十六进制的形式显示二进制文件。</p><h2 id="用户和用户组"><a href="#用户和用户组" class="headerlink" title="用户和用户组"></a>用户和用户组</h2><h3 id="用户"><a href="#用户" class="headerlink" title="用户"></a>用户</h3><p>添加新的用户账号使用 useradd 命令，删除使用 userdel 命令，修改使用 usermod 命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">useradd 选项 用户名</span><br><span class="line">useradd mysql -g mysql <span class="comment">#添加 mysql 用户归属 mysql 用户组</span></span><br></pre></td></tr></table></figure></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">userdel 选项 </span><br><span class="line">userdel -r sam  <span class="comment">#-r的作用是把用户的主目录一起删除</span></span><br></pre></td></tr></table></figure><p>此命令删除用户sam在系统文件中（主要是/etc/passwd, /etc/shadow, /etc/group等）的记录，同时删除用户的主目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">usermod 选项 用户名</span><br><span class="line">usermod -s /bin/ksh -d /home/z –g developer sam</span><br></pre></td></tr></table></figure><p>此命令将用户sam的登录Shell修改为ksh，主目录改为/home/z，用户组改为developer</p><h3 id="用户组"><a href="#用户组" class="headerlink" title="用户组"></a>用户组</h3><p>增加用户组<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groupadd 选项 用户组</span><br></pre></td></tr></table></figure></p><p>删除用户组<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groupdel 用户组</span><br></pre></td></tr></table></figure></p><p>修改用户组<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groupmod 选项 用户组</span><br></pre></td></tr></table></figure></p><h2 id="权限操作"><a href="#权限操作" class="headerlink" title="权限操作"></a>权限操作</h2><p>chmod ［who］ ［+ | - | =］ ［mode］ 文件名<br>命令中各选项的含义为：<br>操作对象who可是下述字母中的任一个或者它们的组合：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">u 表示“用户（user）”，即文件或目录的所有者。</span><br><span class="line">g 表示“同组（group）用户”，即与文件属主有相同组ID的所有用户。</span><br><span class="line">o 表示“其他（others）用户”。</span><br><span class="line">a 表示“所有（all）用户”。它是系统默认值。</span><br></pre></td></tr></table></figure></p><p>操作符号可以是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ 添加某个权限。</span><br><span class="line">- 取消某个权限。</span><br><span class="line">= 赋予给定权限并取消其他所有权限（如果有的话）。</span><br></pre></td></tr></table></figure></p><p>设置mode所表示的权限可用下述字母的任意组合：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">r 可读。</span><br><span class="line">w 可写。</span><br><span class="line">x 可执行。</span><br><span class="line">X 只有目标文件对某些用户是可执行的或该目标文件是目录时才追加x 属性。</span><br><span class="line">s 在文件执行时把进程的属主或组ID置为该文件的文件属主。方式“u＋s”设置文件的用户ID位，“g＋s”设置组ID位。</span><br><span class="line">t 保存程序的文本到交换设备上。</span><br><span class="line">u 与文件属主拥有一样的权限。</span><br><span class="line">g 与和文件属主同组的用户拥有一样的权限。</span><br><span class="line">o 与其他用户拥有一样的权限。</span><br></pre></td></tr></table></figure></p><p>可以将一组权限用数字来表示，此时一组权限的 3 个位当做二进制数字的位，从左到右每个位的权值为 4、2、1，即每个权限对应的数字权值为 r : 4、w : 2、x : 1。</p><p>示例：<br>ls -l 命令 查看文件显示<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">drw-rw-rw- 4 root root 4096 Dec  3 06:05 SSR-Bash-Python</span><br><span class="line">-rw-r--r-- 1 root root   22 Jan 11 22:38 test.txt</span><br></pre></td></tr></table></figure></p><p>前面的  drw-rw-rw- 之类  ，第一位含义：<br>普通文件的文件权限第一个字符为“-”<br>目录文件的文件权限第一个字符为“d”<br>字符设备文件的文件权限第一个字符为“c”<br>块设备文件的文件权限第一个字符为“b”<br>符号链接文件的文件权限第一个字符为“s”</p><p>后面九位为三个用户组的权限，每个用户组三位，读、写、执行权限为 rwx ，没哪个则哪个为 - ，如 r– 为只读，没有写和执行权限。<br>添加权限方式<br>1、 chmod a+w filename   为所有用户给filename文件增加写(w)权限<br>2、chmod 777 filename  所用用户拥有filename的所有权限</p><h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h2><h3 id="1-which"><a href="#1-which" class="headerlink" title="1. which"></a>1. which</h3><p>指令搜索。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">## which [-a] command</span><br><span class="line">-a ：将所有指令列出，而不是只列第一个</span><br></pre></td></tr></table></figure></p><h3 id="2-whereis"><a href="#2-whereis" class="headerlink" title="2. whereis"></a>2. whereis</h3><p>文件搜索。速度比较快，因为它只搜索几个特定的目录。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## whereis [-bmsu] dirname/filename</span><br></pre></td></tr></table></figure></p><h3 id="3-locate"><a href="#3-locate" class="headerlink" title="3. locate"></a>3. locate</h3><p>文件搜索。可以用关键字或者正则表达式进行搜索。</p><h2 id="压缩和打包"><a href="#压缩和打包" class="headerlink" title="压缩和打包"></a>压缩和打包</h2><h3 id="压缩文件名"><a href="#压缩文件名" class="headerlink" title="压缩文件名"></a>压缩文件名</h3><p>Linux 底下有很多压缩文件名，常见的如下：</p><table><thead><tr><th>扩展名</th><th>压缩程序</th></tr></thead><tbody><tr><td>*.Z</td><td>compress</td></tr><tr><td>*.zip</td><td>zip</td></tr><tr><td>*.gz</td><td>gzip</td></tr><tr><td>*.bz2</td><td>bzip2</td></tr><tr><td>*.xz</td><td>xz</td></tr><tr><td>*.tar</td><td>tar 程序打包的数据，没有经过压缩</td></tr><tr><td>*.tar.gz</td><td>tar 程序打包的文件，经过 gzip 的压缩</td></tr><tr><td>*.tar.bz2</td><td>tar 程序打包的文件，经过 bzip2 的压缩</td></tr><tr><td>*.tar.xz</td><td>tar 程序打包的文件，经过 xz 的压缩</td></tr></tbody></table><h3 id="压缩指令"><a href="#压缩指令" class="headerlink" title="压缩指令"></a>压缩指令</h3><h3 id="1-gzip"><a href="#1-gzip" class="headerlink" title="1. gzip"></a>1. gzip</h3><p>gzip 是 Linux 使用最广的压缩指令，可以解开 compress、zip 与 gzip 所压缩的文件。<br>经过 gzip 压缩过，源文件就不存在了。<br>有 9 个不同的压缩等级可以使用。<br>可以使用 zcat、zmore、zless 来读取压缩文件的内容。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ gzip [-cdtv#] filename</span><br><span class="line">-c ：将压缩的数据输出到屏幕上</span><br><span class="line">-d ：解压缩</span><br><span class="line">-t ：检验压缩文件是否出错</span><br><span class="line">-v ：显示压缩比等信息</span><br><span class="line">-# ： # 为数字的意思，代表压缩等级，数字越大压缩比越高，默认为 6</span><br></pre></td></tr></table></figure></p><h3 id="2-bzip2"><a href="#2-bzip2" class="headerlink" title="2. bzip2"></a>2. bzip2</h3><p>提供比 gzip 更高的压缩比。<br>查看命令：bzcat、bzmore、bzless、bzgrep。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ bzip2 [-cdkzv#] filename</span><br><span class="line">-k ：保留源文件</span><br></pre></td></tr></table></figure></p><h3 id="3-xz"><a href="#3-xz" class="headerlink" title="3. xz"></a>3. xz</h3><p>提供比 bzip2 更佳的压缩比。<br>可以看到，gzip、bzip2、xz 的压缩比不断优化。不过要注意的是，压缩比越高，压缩的时间也越长。<br>查看命令：xzcat、xzmore、xzless、xzgrep。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ xz [-dtlkc#] filename</span><br></pre></td></tr></table></figure></p><h3 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h3><p>压缩指令只能对一个文件进行压缩，而打包能够将多个文件打包成一个大文件。tar 不仅可以用于打包，也可以使用 gzip、bzip2、xz 将打包文件进行压缩。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ tar [-z|-j|-J] [cv] [-f 新建的 tar 文件] filename...  ==打包压缩</span><br><span class="line">$ tar [-z|-j|-J] [tv] [-f 已有的 tar 文件]              ==查看</span><br><span class="line">$ tar [-z|-j|-J] [xv] [-f 已有的 tar 文件] [-C 目录]    ==解压缩</span><br><span class="line">-z ：使用 zip；</span><br><span class="line">-j ：使用 bzip2；</span><br><span class="line">-J ：使用 xz；</span><br><span class="line">-c ：新建打包文件；</span><br><span class="line">-t ：查看打包文件里面有哪些文件；</span><br><span class="line">-x ：解打包或解压缩的功能；</span><br><span class="line">-v ：在压缩/解压缩的过程中，显示正在处理的文件名；</span><br><span class="line">-f : filename：要处理的文件；</span><br><span class="line">-C 目录 ： 在特定目录解压缩。</span><br></pre></td></tr></table></figure></p><table><thead><tr><th>使用方式</th><th>命令</th></tr></thead><tbody><tr><td>打包压缩</td><td>tar -jcv -f filename.tar.bz2 要被压缩的文件或目录名称</td></tr><tr><td>查看</td><td>tar -jtv -f filename.tar.bz2</td></tr><tr><td>解压缩</td><td>tar -jxv -f filename.tar.bz2 -C 要解压缩的目录</td></tr></tbody></table><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><h3 id="iptables"><a href="#iptables" class="headerlink" title="iptables"></a>iptables</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">开启： chkconfig iptables on  </span><br><span class="line">关闭： chkconfig iptables off</span><br></pre></td></tr></table></figure><p>即时生效，重启后失效<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">开启： service iptables start   </span><br><span class="line">关闭： service iptables stop   </span><br><span class="line">状态 service iptables status</span><br></pre></td></tr></table></figure></p><h3 id="firewalld"><a href="#firewalld" class="headerlink" title="firewalld"></a>firewalld</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">service firewalld status; #查看防火墙状态</span><br><span class="line">service firewalld start;  或者 #systemctl start firewalld.service;#开启防火墙</span><br><span class="line">service firewalld stop;  或者 #systemctl stop firewalld.service;#关闭防火墙</span><br><span class="line">service firewalld restart;  或者 #systemctl restart firewalld.service;  #重启防火墙</span><br><span class="line">systemctl disable firewalld.service#禁止防火墙开启自启</span><br><span class="line"></span><br><span class="line">firewall-cmd --list-all #查看防火墙规则</span><br><span class="line">firewall-cmd --zone=public --list-ports #查看所有打开的端口</span><br><span class="line">firewall-cmd --zone=public --permanent --add-port=15672/tcp #添加端口，--permanent永久生效，没有此参数重启后失效</span><br><span class="line">firewall-cmd --reload #重新载入，添加端口后重新载入生效</span><br><span class="line">firewall-cmd --zone=public --remove-port=80/tcp --permanent #删除，同样需要重载生效</span><br></pre></td></tr></table></figure><h3 id="ss"><a href="#ss" class="headerlink" title="ss"></a>ss</h3><p>ss是Socket Statistics的缩写。ss命令用来显示处于活动状态的套接字信息。它可以显示和netstat类似的内容。但ss的优势在于它能够显示更多更详细的有关TCP和连接状态的信息，而且比netstat更快速更高效。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ss [参数]</span><br><span class="line">-n不解析服务名称，已数字方式显示</span><br><span class="line">-a显示所有套接字</span><br><span class="line">-l显示处于监听状态的套接字</span><br><span class="line">-o显示计时器信息</span><br><span class="line">-e显示详细的套接字信息</span><br><span class="line">-m显示套接字的内存使用情况</span><br><span class="line">-p显示使用套接字的进程</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ss -t -a #显示TCP套接字</span><br><span class="line">ss -u -a #显示UDP套接字</span><br><span class="line">ss -s #显示套接字使用概况</span><br><span class="line">ss -lnp|grep 80 #80端口占用</span><br></pre></td></tr></table></figure><h2 id="vi-vim-基本操作"><a href="#vi-vim-基本操作" class="headerlink" title="vi/vim 基本操作"></a>vi/vim 基本操作</h2><h3 id="vi与vim两者区别"><a href="#vi与vim两者区别" class="headerlink" title="vi与vim两者区别"></a>vi与vim两者区别</h3><p>它们都是多模式编辑器，不同的是vim 是vi的升级版本，它不仅兼容vi的所有指令，而且还有一些新的特性在里面。<br>vim的这些优势主要体现在以下几个方面：<br>1.多级撤消<br>我们知道在vi里，按 u只能撤消上次命令，而在vim里可以无限制的撤消。<br>2.易用性<br>vi只能运行于unix中，而vim不仅可以运行于unix,windows ,mac等多操作平台。<br>3.语法加亮<br>vim可以用不同的颜色来加亮你的代码。<br>4.可视化操作<br>就是说vim不仅可以在终端运行，也可以运行于x window、 mac os、 windows。<br>5.对vi的完全兼容<br>某些情况下，你可以把vim当成vi来使用</p><h3 id="使用-vi-文件名-或者-vim-文件名-打开文件"><a href="#使用-vi-文件名-或者-vim-文件名-打开文件" class="headerlink" title="使用 vi  文件名  或者  vim 文件名   打开文件"></a>使用 vi  文件名  或者  vim 文件名   打开文件</h3><p>按i进入编辑<br>按esc退出编辑<br>打开状态操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">u   撤销上一步操作</span><br><span class="line">ctrl+r   恢复上一步被撤销的操作</span><br><span class="line">/字符串    搜索字符串</span><br><span class="line">:%s/aa/bb    把aa替换成bb</span><br><span class="line">编辑状态操作：</span><br><span class="line">:w   保存</span><br><span class="line">:q   退出，有提示</span><br><span class="line">:q!   强制退出</span><br><span class="line">:wq   保存退出（强制写入文件并退出）</span><br><span class="line">:x   保存退出（有修改时才写入文件并退出）</span><br></pre></td></tr></table></figure></p><p>按esc回到打开状态</p><p>其他操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">gg  回到顶端</span><br><span class="line">G  到底端</span><br><span class="line">u  撤销  </span><br><span class="line">ctrl+r  恢复上一步被撤销的操作</span><br><span class="line">ctrl+b 向上翻页</span><br><span class="line">ctrl+f  向下翻页</span><br></pre></td></tr></table></figure></p><h3 id="vi操作异常中断"><a href="#vi操作异常中断" class="headerlink" title="vi操作异常中断"></a>vi操作异常中断</h3><p>提示Found a swap file by the name<br>删除目录下的隐藏文件，恢复操作;<br>ls -a 查看swap隐藏文件，rm 命令删除即可。</p><h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><h3 id="1-ps"><a href="#1-ps" class="headerlink" title="1.ps"></a>1.ps</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ps -l # 查看自己的进程</span><br><span class="line">ps aux # 查看系统所有进程</span><br><span class="line">ps aux | grep nginx # 查看特定进程nginx</span><br><span class="line">ps -ef | grep nginx # 同上</span><br><span class="line">pstree -A # 查看进程树</span><br></pre></td></tr></table></figure><p><img src="../images/20210219/1613749448742.png" alt></p><p>2.top<br><img src="../images/20210220/1613793448107.png" alt><br><strong>第一行，任务队列信息，同 uptime 命令的执行结果</strong></p><p>系统时间：23:46:16<br>运行时间：up 179 days, 11:16,<br>当前登录用户： 1 users<br>负载均衡(uptime) load average: 0.00, 0.02, 0.05</p><p>average后面的三个数分别是1分钟、5分钟、15分钟的负载情况。<br>load average数据是每隔5秒钟检查一次活跃的进程数，然后按特定算法计算出的数值。如果这个数除以逻辑CPU的数量，结果高于5的时候就表明系统在超负荷运转了</p><p><strong>第二行，Tasks — 任务（进程）</strong><br>总进程:96 total, 运行:1 running, 休眠:95 sleeping, 停止: 0 stopped, 僵尸进程: 0 zombie</p><p><strong>第三行，cpu状态信息</strong><br>0.3%us【user space】— 用户空间占用CPU的百分比<br>0.5%sy【sysctl】— 内核空间占用CPU的百分比<br>0.0%ni【】— 改变过优先级的进程占用CPU的百分比<br>99.2%id【idolt】— 空闲CPU百分比<br>0.0%wa【wait】— IO等待占用CPU的百分比<br>0.0%hi【Hardware IRQ】— 硬中断占用CPU的百分比<br>0.0%si【Software Interrupts】— 软中断占用CPU的百分比  </p><p><strong>第四行,内存状态</strong><br>8009128 total,   832280 free,  1235088 used,  5941760 buff/cache【buffers缓存的内存量】</p><p><strong>第五行，swap交换分区信息</strong><br>0 total,  0 free,  0 used.  6469384 avail Mem【cached缓冲的交换区总量】</p><p>备注：<br>可用内存=free + buffer + cached对于内存监控，在top里我们要时刻监控第五行swap交换分区的used，如果这个数值在不断的变化，说明内核在不断进行内存和swap的数据交换，这是真正的内存不够用了。第四行中使用中的内存总量（used）指的是现在系统内核控制的内存数，第四行中空闲内存总量（free）是内核还未纳入其管控范围的数量。纳入内核管理的内存不见得都在使用中，还包括过去使用过的现在可以被重复利用的内存，内核并不把这些可被重新使用的内存交还到free中去，因此在linux上free内存会越来越少，但不用为此担心。</p><h2 id="JDK-常用命令"><a href="#JDK-常用命令" class="headerlink" title="JDK 常用命令"></a>JDK 常用命令</h2><p>Sun JDK监控和故障处理命令有jps jstat jmap jhat jstack jinfo</p><ul><li>jps，JVM Process Status Tool，显示指定系统内所有的HotSpot虚拟机进程；</li><li>jstat，JVM statistics Monitoring，用于监视虚拟机运行时状态信息的命令，它可以显示出虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据；</li><li>jmap，JVM Memory Map 命令用于生成heap dump文件；</li><li>jhat，JVM Heap Analysis Tool 命令是与 jmap 搭配使用，用来分析 jmap 生成的 dump 文件，jhat 内置了一个微型的 HTTP/HTML 服务器，生成 dump 的分析结果后，可以在浏览器中查看；</li><li>jstack，用于生成java虚拟机当前时刻的线程快照；</li><li>jinfo，JVM Configuration info 这个命令作用是实时查看和调整虚拟机运行参数。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>[1] <a href="https://reid.run/archives/linux1#toc-head-45" target="_blank" rel="noopener">Linux基本概念及常用命令实现汇总</a></li><li>[2] <a href="https://www.runoob.com/linux/linux-command-manual.html" target="_blank" rel="noopener">Linux 命令大全</a></li><li>[3] <a href="http://linux.vbird.org/" target="_blank" rel="noopener">鸟哥的 Linux 私房菜</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;系统信息&quot;&gt;&lt;a href=&quot;#系统信息&quot; class=&quot;headerlink&quot; title=&quot;系统信息&quot;&gt;&lt;/a&gt;系统信息&lt;/h2&gt;&lt;h3 id=&quot;1-uname&quot;&gt;&lt;a href=&quot;#1-uname&quot; class=&quot;headerlink&quot; title=&quot;1. 
      
    
    </summary>
    
      <category term="技术" scheme="https://zguishen.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Linux" scheme="https://zguishen.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>IP地址表示方法</title>
    <link href="https://zguishen.com/posts/45bd0325.html"/>
    <id>https://zguishen.com/posts/45bd0325.html</id>
    <published>2021-01-15T16:00:00.000Z</published>
    <updated>2021-07-19T05:30:14.072Z</updated>
    
    <content type="html"><![CDATA[<p>有时会看到一些有关 ip 段的写法是这样的：“192.168.1.1/24”，这种写法叫 CIDR 无类域间路由。“/”后面的数字控制前面 ip 地址的掩码，以表示后面有几位可以变。<br><a id="more"></a></p><p>具体解析如下：<br>网段区间 192.168.1.1/24<br>IP 地址 192.168.1.1，由4段32 bit 组成，即<br>11000000 10101000 00000001 00000001</p><p>/24 表示子网掩码前24位为1，后面为0，子网掩码和 IP 地址按位与运算<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">11111111 11111111 11111111 00000000  </span><br><span class="line">11000000 10101000 00000001 00000001  &amp;</span><br><span class="line">-------------------------------------------------</span><br><span class="line">11000000 10101000 00000001 00000000</span><br></pre></td></tr></table></figure></p><p>十进制为 192.168.1.0，得到网络地址  </p><p>子网掩码中等于0的部分是后面8位，将网络地址的后8位设置为1，即<br>11000000 10101000 00000001 11111111<br>十进制为 192.168.1.255，得到广播地址</p><p>总结<br>IP段 192.168.1.0/24<br>IP段 192.168.1.0 - 192.168.1.255<br>起始IP 192.168.1.1 - 192.168.1.254<br>网络 192.168.1.0<br>掩码 255.255.255.0<br>广播 192.168.1.255<br>可用数 254</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有时会看到一些有关 ip 段的写法是这样的：“192.168.1.1/24”，这种写法叫 CIDR 无类域间路由。“/”后面的数字控制前面 ip 地址的掩码，以表示后面有几位可以变。&lt;br&gt;
    
    </summary>
    
      <category term="技术" scheme="https://zguishen.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="基础" scheme="https://zguishen.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>冬日</title>
    <link href="https://zguishen.com/posts/fb832fb5.html"/>
    <id>https://zguishen.com/posts/fb832fb5.html</id>
    <published>2021-01-02T16:00:00.000Z</published>
    <updated>2021-07-19T05:30:14.072Z</updated>
    
    <content type="html"><![CDATA[<p>以前对2020年的记忆是课本上的”2020全面建设小康社会“，一晃，2020年已经是历史了。<br><a id="more"></a></p><p>在2020年的最后一个月，上班一个多月，试用期期间，我还是选择了离职。说到底就不该入职这个公司，行业并不是自己多喜欢的音视频领域，想尝试坚持试试，但对出差实在反感，还要到长三角那边，这冬天这么冷……</p><p>上周寒流来临，广东也正式进入冬天了。天气一冷，皮肤干燥，行动迟缓，精神萎靡，最蛋疼的是鼻子又要遭罪了，一吹风拼命打喷嚏流鼻水。对冬天真实喜欢不起来。</p><p>冬日感觉最舒服的事情就是晒太阳了，一边晒太阳一边喝可乐，真的惬意。</p><p>上周去电影院看了《心灵奇旅》，明明买单写的是国语版，去到现场结果播的是英语，本来还想听听国语配音怎么样，看网络上评价还挺不错的。<br><a href="https://movie.douban.com/subject/24733428/" target="_blank" rel="noopener">心灵奇旅 Soul (2020)</a><br><img src="../images/20210103/1609684717801.png" alt> </p><p>《心灵奇旅》可以说是给了打工人一碗鸡汤。当你进入憧憬的企业上班，日子久了，突然发现每天重复性的上班劳动，这是我们想要的生活么。”What I want is the ocean.“，鱼要找到大海，殊不知已置身于大海之中。生活虽有波澜起伏，更多时候是风平浪静，没必要一直赶着前进，活在当下更重要。</p><p>平静的日子回忆起小时候的时光，还是小时候好玩，不过现在看这番感觉有些幼齿了。<br><a href="https://movie.douban.com/subject/27063403/" target="_blank" rel="noopener">悠哉日常大王剧场版：假期活动 劇場版 のんのんびより ばけーしょん (2018)</a><br><img src="../images/20210103/1609685802686.png" alt><br>这个星空场景真的美，现在家里乡下也难以见到漫天星星的夜空了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以前对2020年的记忆是课本上的”2020全面建设小康社会“，一晃，2020年已经是历史了。&lt;br&gt;
    
    </summary>
    
      <category term="生活" scheme="https://zguishen.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="其他" scheme="https://zguishen.com/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title>【转载】分布式事务，这一篇就够了</title>
    <link href="https://zguishen.com/posts/d8fe79bf.html"/>
    <id>https://zguishen.com/posts/d8fe79bf.html</id>
    <published>2020-12-29T16:00:00.000Z</published>
    <updated>2021-07-19T05:30:14.072Z</updated>
    
    <content type="html"><![CDATA[<p><strong>[作者简介]</strong> 李文华，小米信息技术部海外商城组</p><p>随着互联网技术的不断发展，系统越来越复杂，几乎所有 IT 公司的系统都已经完成从单体架构到分布式架构的转变，分布式系统几乎无处不在。谈到分布式系统，特别是微服务架构，我们不得不谈分布式事务。今天就跟大家一起聊聊分布式事务以及常用解决方案。</p><h2 id="基础理论"><a href="#基础理论" class="headerlink" title="基础理论"></a>基础理论</h2><p>在讲解具体方案之前，我们有必要了解一些分布式事务所涉及到的基础理论知识。</p><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>事务是应用程序中一系列严密的操作，所有操作必须成功完成，否则在每个操作中所作的所有更改都会被撤消。也就是事务具有原子性，一个事务中的一系列的操作要么全部成功，要么一个都不做。事务应该具有 4 个属性：原子性、一致性、隔离性、持久性。这四个属性通常称为 ACID 特性。</p><h3 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h3><p>分布式事务是指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于不同的分布式系统的不同节点之上。例如在大型电商系统中，下单接口通常会扣减库存、减去优惠、生成订单 id, 而订单服务与库存、优惠、订单 id 都是不同的服务，下单接口的成功与否，不仅取决于本地的 db 操作，而且依赖第三方系统的结果，这时候分布式事务就保证这些操作要么全部成功，要么全部失败。本质上来说，分布式事务就是为了保证不同数据库的数据一致性。</p><h3 id="强一致性、弱一致性、最终一致性"><a href="#强一致性、弱一致性、最终一致性" class="headerlink" title="强一致性、弱一致性、最终一致性"></a>强一致性、弱一致性、最终一致性</h3><h3 id="强一致性"><a href="#强一致性" class="headerlink" title="强一致性"></a>强一致性</h3><p>任何一次读都能读到某个数据的最近一次写的数据。系统中的所有进程，看到的操作顺序，都和全局时钟下的顺序一致。简言之，在任意时刻，所有节点中的数据是一样的。</p><h3 id="弱一致性"><a href="#弱一致性" class="headerlink" title="弱一致性"></a>弱一致性</h3><p>数据更新后，如果能容忍后续的访问只能访问到部分或者全部访问不到，则是弱一致性。</p><h3 id="最终一致性"><a href="#最终一致性" class="headerlink" title="最终一致性"></a>最终一致性</h3><p>不保证在任意时刻任意节点上的同一份数据都是相同的，但是随着时间的迁移，不同节点上的同一份数据总是在向趋同的方向变化。简单说，就是在一段时间后，节点间的数据会最终达到一致状态。</p><h3 id="CAP-原则"><a href="#CAP-原则" class="headerlink" title="CAP 原则"></a>CAP 原则</h3><blockquote><p>CAP 原则又称 CAP 定理，指的是在一个分布式系统中， Consistency（一致性）、 Availability（可用性）、Partition tolerance（分区容错性），三者不可得兼。</p></blockquote><p>一致性（C）：</p><blockquote><p>在分布式系统中的所有数据备份，在同一时刻是否同样的值。（等同于所有节点访问同一份最新的数据副本）</p></blockquote><p>可用性（A）：</p><blockquote><p>在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。（对数据更新具备高可用性）</p></blockquote><p>分区容错性（P）：</p><blockquote><p>以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在 C 和 A 之间做出选择。</p></blockquote><p>CAP 原则的精髓就是要么 AP，要么 CP，要么 AC，但是不存在 CAP。如果在某个分布式系统中数据无副本， 那么系统必然满足强一致性条件， 因为只有独一数据，不会出现数据不一致的情况，此时 C 和 P 两要素具备，但是如果系统发生了网络分区状况或者宕机，必然导致某些数据不可以访问，此时可用性条件就不能被满足，即在此情况下获得了 CP 系统，但是 CAP 不可同时满足。</p><h3 id="BASE-理论"><a href="#BASE-理论" class="headerlink" title="BASE 理论"></a>BASE 理论</h3><p>BASE 理论指的是基本可用 Basically Available，软状态 Soft State，最终一致性 Eventual Consistency，核心思想是即便无法做到强一致性，但应该采用适合的方式保证最终一致性。</p><p>BASE，Basically Available Soft State Eventual Consistency 的简写：BA：Basically Available 基本可用，分布式系统在出现故障的时候，允许损失部分可用性，即保证核心可用。S：Soft State 软状态，允许系统存在中间状态，而该中间状态不会影响系统整体可用性。E：Consistency 最终一致性，系统中的所有数据副本经过一定时间后，最终能够达到一致的状态。BASE 理论本质上是对 CAP 理论的延伸，是对 CAP 中 AP 方案的一个补充。</p><h3 id="柔性事务"><a href="#柔性事务" class="headerlink" title="柔性事务"></a>柔性事务</h3><p>不同于 ACID 的刚性事务，在分布式场景下基于 BASE 理论，就出现了柔性事务的概念。要想通过柔性事务来达到最终的一致性，就需要依赖于一些特性，这些特性在具体的方案中不一定都要满足，因为不同的方案要求不一样；但是都不满足的话，是不可能做柔性事务的。</p><h3 id="幂等操作"><a href="#幂等操作" class="headerlink" title="幂等操作"></a>幂等操作</h3><p>在编程中一个幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。幂等函数，或幂等方法，是指可以使用相同参数重复执行，并能获得相同结果的函数。这些函数不会影响系统状态，也不用担心重复执行会对系统造成改变。例如，支付流程中第三方支付系统告知系统中某个订单支付成功，接收该支付回调接口在网络正常的情况下无论操作多少次都应该返回成功。</p><h2 id="分布式事务使用场景"><a href="#分布式事务使用场景" class="headerlink" title="分布式事务使用场景"></a>分布式事务使用场景</h2><h3 id="转账"><a href="#转账" class="headerlink" title="转账"></a>转账</h3><p>转账是最经典那的分布式事务场景，假设用户 A 使用银行 app 发起一笔跨行转账给用户 B，银行系统首先扣掉用户 A 的钱，然后增加用户 B 账户中的余额。此时就会出现 2 种异常情况：1. 用户 A 的账户扣款成功，用户 B 账户余额增加失败 2. 用户 A 账户扣款失败，用户 B 账户余额增加成功。对于银行系统来说，以上 2 种情况都是不允许发生，此时就需要分布式事务来保证转账操作的成功。</p><h3 id="下单扣库存"><a href="#下单扣库存" class="headerlink" title="下单扣库存"></a>下单扣库存</h3><p>在电商系统中，下单是用户最常见操作。在下单接口中必定会涉及生成订单 id, 扣减库存等操作，对于微服务架构系统，订单 id 与库存服务一般都是独立的服务，此时就需要分布式事务来保证整个下单接口的成功。</p><h3 id="同步超时"><a href="#同步超时" class="headerlink" title="同步超时"></a>同步超时</h3><p>继续以电商系统为例，在微服务体系架构下，我们的支付与订单都是作为单独的系统存在。订单的支付状态依赖支付系统的通知，假设一个场景：我们的支付系统收到来自第三方支付的通知，告知某个订单支付成功，接收通知接口需要同步调用订单服务变更订单状态接口，更新订单状态为成功。流程图如下，从图中可以看出有两次调用，第三方支付调用支付服务，以及支付服务调用订单服务，这两步调用都可能出现调用超时的情况，此处如果没有分布式事务的保证，就会出现用户订单实际支付情况与最终用户看到的订单支付情况不一致的情况。</p><p><img src="../images/20201230/1609261719618.png" alt></p><h2 id="分布式事务的解决方案"><a href="#分布式事务的解决方案" class="headerlink" title="分布式事务的解决方案"></a>分布式事务的解决方案</h2><h3 id="两阶段提交-XA"><a href="#两阶段提交-XA" class="headerlink" title="两阶段提交/XA"></a>两阶段提交/XA</h3><p>两阶段提交，顾名思义就是要分两步提交。存在一个负责协调各个本地资源管理器的事务管理器，本地资源管理器一般是由数据库实现，事务管理器在第一阶段的时候询问各个资源管理器是否都就绪？如果收到每个资源的回复都是 yes，则在第二阶段提交事务，如果其中任意一个资源的回复是 no, 则回滚事务。</p><p><img src="../images/20201230/1609261761095.png" alt></p><p><img src="../images/20201230/1609261766711.png" alt></p><p>大致的流程：</p><p>第一阶段（prepare）：事务管理器向所有本地资源管理器发起请求，询问是否是 ready 状态，所有参与者都将本事务能否成功的信息反馈发给协调者；第二阶段 (commit/rollback)：事务管理器根据所有本地资源管理器的反馈，通知所有本地资源管理器，步调一致地在所有分支上提交或者回滚。</p><p>存在的问题：</p><blockquote><p>同步阻塞：当参与事务者存在占用公共资源的情况，其中一个占用了资源，其他事务参与者就只能阻塞等待资源释放，处于阻塞状态。</p></blockquote><blockquote><p>单点故障：一旦事务管理器出现故障，整个系统不可用</p></blockquote><blockquote><p>数据不一致：在阶段二，如果事务管理器只发送了部分 commit 消息，此时网络发生异常，那么只有部分参与者接收到 commit 消息，也就是说只有部分参与者提交了事务，使得系统数据不一致。</p></blockquote><blockquote><p>不确定性：当协事务管理器发送 commit 之后，并且此时只有一个参与者收到了 commit，那么当该参与者与事务管理器同时宕机之后，重新选举的事务管理器无法确定该条消息是否提交成功。</p></blockquote><h3 id="TCC"><a href="#TCC" class="headerlink" title="TCC"></a>TCC</h3><p>关于 TCC（Try-Confirm-Cancel）的概念，最早是由 Pat Helland 于 2007 年发表的一篇名为《Life beyond Distributed Transactions:an Apostate’s Opinion》的论文提出。 TCC 事务机制相比于上面介绍的 XA，解决了其几个缺点：</p><ol><li>解决了协调者单点，由主业务方发起并完成这个业务活动。业务活动管理器也变成多点，引入集群。</li><li>同步阻塞：引入超时，超时后进行补偿，并且不会锁定整个资源，将资源转换为业务逻辑形式，粒度变小。</li><li>数据一致性，有了补偿机制之后，由业务活动管理器控制一致性</li></ol><p>TCC(Try Confirm Cancel)Try 阶段：尝试执行，完成所有业务检查（一致性）, 预留必须业务资源（准隔离性）Confirm 阶段：确认执行真正执行业务，不作任何业务检查，只使用 Try 阶段预留的业务资源，Confirm 操作满足幂等性。要求具备幂等设计，Confirm 失败后需要进行重试。Cancel 阶段：取消执行，释放 Try 阶段预留的业务资源 Cancel 操作满足幂等性 Cancel 阶段的异常和 Confirm 阶段异常处理方案基本上一致。</p><p>在 Try 阶段，是对业务系统进行检查及资源预览，比如订单和存储操作，需要检查库存剩余数量是否够用，并进行预留，预留操作的话就是新建一个可用库存数量字段，Try 阶段操作是对这个可用库存数量进行操作。基于 TCC 实现分布式事务，会将原来只需要一个接口就可以实现的逻辑拆分为 Try、Confirm、Cancel 三个接口，所以代码实现复杂度相对较高。</p><h3 id="本地消息表"><a href="#本地消息表" class="headerlink" title="本地消息表"></a>本地消息表</h3><p>本地消息表这个方案最初是 ebay 架构师 Dan Pritchett 在 2008 年发表给 ACM 的文章。该方案中会有消息生产者与消费者两个角色，假设系统 A 是消息生产者，系统 B 是消息消费者，其大致流程如下：</p><p><img src="../images/20201230/1609261784439.png" alt></p><ol><li>当系统 A 被其他系统调用发生数据库表更操作，首先会更新数据库的业务表，其次会往相同数据库的消息表中插入一条数据，两个操作发生在同一个事务中</li><li>系统 A 的脚本定期轮询本地消息往 mq 中写入一条消息，如果消息发送失败会进行重试</li><li>系统 B 消费 mq 中的消息，并处理业务逻辑。如果本地事务处理失败，会在继续消费 mq 中的消息进行重试，如果业务上的失败，可以通知系统 A 进行回滚操作</li></ol><p>本地消息表实现的条件：</p><ol><li>消费者与生成者的接口都要支持幂等</li><li>生产者需要额外的创建消息表</li><li>需要提供补偿逻辑，如果消费者业务失败，需要生产者支持回滚操作</li></ol><p>容错机制：</p><ol><li>步骤 1 失败时，事务直接回滚</li><li>步骤 2、3 写 mq 与消费 mq 失败会进行重试</li><li>步骤 3 业务失败系统 B 向系统 A 发起事务回滚操作</li></ol><p>此方案的核心是将需要分布式处理的任务通过消息日志的方式来异步执行。消息日志可以存储到本地文本、数据库或消息队列，再通过业务规则自动或人工发起重试。人工重试更多的是应用于支付场景，通过对账系统对事后问题的处理。</p><h3 id="可靠消息最终一致性"><a href="#可靠消息最终一致性" class="headerlink" title="可靠消息最终一致性"></a>可靠消息最终一致性</h3><p>大致流程如下：</p><p><img src="../images/20201230/1609261798151.png" alt></p><ol><li>A 系统先向 mq 发送一条 prepare 消息，如果 prepare 消息发送失败，则直接取消操作</li><li>如果消息发送成功，则执行本地事务</li><li>如果本地事务执行成功，则想 mq 发送一条 confirm 消息，如果发送失败，则发送回滚消息</li><li>B 系统定期消费 mq 中的 confirm 消息，执行本地事务，并发送 ack 消息。如果 B 系统中的本地事务失败，会一直不断重试，如果是业务失败，会向 A 系统发起回滚请求</li></ol><p>5.mq 会定期轮询所有 prepared 消息调用系统 A 提供的接口查询消息的处理情况，如果该 prepare 消息本地事务处理成功，则重新发送 confirm 消息，否则直接回滚该消息</p><p>该方案与本地消息最大的不同是去掉了本地消息表，其次本地消息表依赖消息表重试写入 mq 这一步由本方案中的轮询 prepare 消息状态来重试或者回滚该消息替代。其实现条件与余容错方案基本一致。目前市面上实现该方案的只有阿里的 RocketMq。</p><h3 id="尽最大努力通知"><a href="#尽最大努力通知" class="headerlink" title="尽最大努力通知"></a>尽最大努力通知</h3><p>最大努力通知是最简单的一种柔性事务，适用于一些最终一致性时间敏感度低的业务，且被动方处理结果 不影响主动方的处理结果。</p><p>这个方案的大致意思就是：</p><ol><li>系统 A 本地事务执行完之后，发送个消息到 MQ；</li><li>这里会有个专门消费 MQ 的服务，这个服务会消费 MQ 并调用系统 B 的接口；</li><li>要是系统 B 执行成功就 ok 了；要是系统 B 执行失败了，那么最大努力通知服务就定时尝试重新调用系统 B, 反复 N 次，最后还是不行就放弃。</li></ol><h2 id="分布式事务实战"><a href="#分布式事务实战" class="headerlink" title="分布式事务实战"></a>分布式事务实战</h2><h3 id="两阶段提交-XA-1"><a href="#两阶段提交-XA-1" class="headerlink" title="两阶段提交/XA"></a>两阶段提交/XA</h3><p>目前支付宝使用两阶段提交思想实现了分布式事务服务 (Distributed Transaction Service, DTS) ，它是一个分布式事务框架，用来保障在大规模分布式环境下事务的最终一致性。具体可参考支付宝官方文档：<a href="https://tech.antfin.com/docs/2/46887" target="_blank" rel="noopener">https://tech.antfin.com/docs/2/46887</a></p><h3 id="TCC-1"><a href="#TCC-1" class="headerlink" title="TCC"></a>TCC</h3><p>TCC 需要事务接口提供 try, confirm, cancel 三个接口，提高了编程的复杂性。依赖于业务方来配合提供这样的接口，推行难度大，所以一般不推荐使用这种方式。</p><h3 id="可靠消息最终一致性-1"><a href="#可靠消息最终一致性-1" class="headerlink" title="可靠消息最终一致性"></a>可靠消息最终一致性</h3><p>目前市面上支持该方案的 mq 只有阿里的 rocketmq, 该方案应用场景也比较多，比如用户注册成功后发送邮件、电商系统给用户发送优惠券等需要保证最终一致性的场景</p><h3 id="本地消息表-1"><a href="#本地消息表-1" class="headerlink" title="本地消息表"></a>本地消息表</h3><p>跨行转账可通过该方案实现。用户 A 向用户 B 发起转账，首先系统会扣掉用户 A 账户中的金额，将该转账消息写入消息表中，如果事务执行失败则转账失败，如果转账成功，系统中会有定时轮询消息表，往 mq 中写入转账消息，失败重试。mq 消息会被实时消费并往用户 B 中账户增加转账金额，执行失败会不断重试。</p><p><img src="../images/20201230/1609261835880.png" alt></p><p>小米海外商城用户订单数据状态变更，会将变更状态记录消息表中，脚本将订单状态消息写入 mq，最终消费 mq 给用户发送邮件、短信、push 等。</p><h3 id="最大努力通知"><a href="#最大努力通知" class="headerlink" title="最大努力通知"></a>最大努力通知</h3><p>最大努力通知最常见的场景就是支付回调，支付服务收到第三方服务支付成功通知后，先更新自己库中订单支付状态，然后同步通知订单服务支付成功。如果此次同步通知失败，会通过异步脚步不断重试地调用订单服务的接口。</p><p><img src="../images/20201230/1609261851206.png" alt></p><p>小米海外商城目前除了支付回调外，最常用的场景是订单数据同步。例如系统 A、B 进行数据同步，当系统 A 发生订单数据变更，先将数据变更消息写入小米 notify 系统（作用等同 mq），然后 notify 系统异步处理该消息来调用系统 B 提供的接口并进行重试到最大次数。</p><p><img src="../images/20201230/1609261860756.png" alt></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文介绍了分布式事务的一些基础理论，并对常用的分布式事务方案进行了讲解，在文章的后半部分主要给出了各种方案的常用场景。分布式事务本身就是一个技术难题，业务中具体使用哪种方案还是需要根据自身业务特点自行选择，每种方案在实际执行过程中需要考虑的点都非常多，复杂度较大，所以在非必要的情况下，分布式事务能不用就尽量不用。</p><p>参考：</p><ol><li>“分布式服务化系统一致性的“最佳实干” <a href="https://mp.weixin.qq.com/s/khAwfJvWcwgbAYbBHbU8aQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/khAwfJvWcwgbAYbBHbU8aQ</a></li><li>“常用的分布式事务解决方案” <a href="https://blog.csdn.net/u010425776/article/details/79516298?tt_from=weixin&amp;utm_source=weixin&amp;utm_medium=toutiao_ios&amp;utm_campaign=client_share&amp;wxshare_count=1" target="_blank" rel="noopener">https://blog.csdn.net/u010425776/article/details/79516298?tt_from=weixin&amp;utm_source=weixin&amp;utm_medium=toutiao_ios&amp;utm_campaign=client_share&amp;wxshare_count=1</a></li><li>“深入分布式事务” <a href="http://www.codeceo.com/article/distributed-transaction.html" target="_blank" rel="noopener">http://www.codeceo.com/article/distributed-transaction.html</a></li><li>CAP 原则 <a href="https://baike.baidu.com/item/CAP%E5%8E%9F%E5%88%99" target="_blank" rel="noopener">https://baike.baidu.com/item/CAP%E5%8E%9F%E5%88%99</a></li><li>事务 <a href="https://baike.baidu.com/item/%E4%BA%8B%E5%8A%A1/5945882" target="_blank" rel="noopener">https://baike.baidu.com/item/%E4%BA%8B%E5%8A%A1/5945882</a></li><li>布式事务 <a href="https://baike.baidu.com/item/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1" target="_blank" rel="noopener">https://baike.baidu.com/item/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1</a></li><li>《Atomic Distributed Transactions: a RESTful Design》</li></ol><hr><p><strong>作者</strong></p><p>李文华，小米信息技术部海外商城组</p><p>原文链接[<a href="https://xiaomi-info.github.io/2020/01/02/distributed-transaction/]" target="_blank" rel="noopener">https://xiaomi-info.github.io/2020/01/02/distributed-transaction/]</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;[作者简介]&lt;/strong&gt; 李文华，小米信息技术部海外商城组&lt;/p&gt;
&lt;p&gt;随着互联网技术的不断发展，系统越来越复杂，几乎所有 IT 公司的系统都已经完成从单体架构到分布式架构的转变，分布式系统几乎无处不在。谈到分布式系统，特别是微服务架构，我们不得不谈
      
    
    </summary>
    
      <category term="技术" scheme="https://zguishen.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="转载" scheme="https://zguishen.com/tags/%E8%BD%AC%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>微服务要点梳理</title>
    <link href="https://zguishen.com/posts/f08cd80.html"/>
    <id>https://zguishen.com/posts/f08cd80.html</id>
    <published>2020-12-21T16:00:00.000Z</published>
    <updated>2021-07-19T05:30:14.072Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>微服务是一种用于构建应用的架构方案。微服务架构有别于更为传统的单体式方案，可将应用拆分成多个核心功能。每个功能都被称为一项服务，可以单独构建和部署，这意味着各项服务在工作（和出现故障）时不会相互影响。<br><a id="more"></a></p></blockquote><!-- TOC --><ul><li><a href="#1-实施微服务好处">1. 实施微服务好处</a></li><li><a href="#2-带来的问题">2. 带来的问题</a></li><li><a href="#3-spring-cloud-组件">3. Spring Cloud 组件</a></li><li><a href="#4-限流方法流量控制熔断降级系统负载保护">4. 限流方法（流量控制、熔断降级、系统负载保护）</a></li><li><a href="#5-限流算法">5. 限流算法</a></li><li><a href="#6-负载均衡方法">6. 负载均衡方法</a></li><li><a href="#7-分布式锁">7. 分布式锁</a></li><li><a href="#8-cap理论">8. CAP理论</a></li><li><a href="#9-base-理论">9. BASE 理论</a></li><li><a href="#10-分布式事务">10. 分布式事务</a></li><li><a href="#11-分布式事务框架">11. 分布式事务框架</a></li><li><a href="#12-seata-4种事务模式">12. Seata 4种事务模式</a></li><li><a href="#13-分布式链路跟踪">13. 分布式链路跟踪</a></li><li><a href="#14-分布式-id-生成方式">14. 分布式 id 生成方式</a></li></ul><!-- /TOC --><h3 id="1-实施微服务好处"><a href="#1-实施微服务好处" class="headerlink" title="1. 实施微服务好处"></a>1. 实施微服务好处</h3><ul><li>针对特定服务发布，影响小，风险小，成本低</li><li>频繁发布版本，快速交付需求</li><li>低成本扩容，弹性伸缩，适应云环境</li></ul><h3 id="2-带来的问题"><a href="#2-带来的问题" class="headerlink" title="2. 带来的问题"></a>2. 带来的问题</h3><ul><li>分布式系统的复杂性</li><li>部署，测试和监控的成本问题</li><li>分布式事务和CAP的相关问题</li></ul><h3 id="3-Spring-Cloud-组件"><a href="#3-Spring-Cloud-组件" class="headerlink" title="3. Spring Cloud 组件"></a>3. Spring Cloud 组件</h3><ul><li>注册中心 Eureka，其他的还有 Zookeeper、Consul 和 Nacos。用于服务发现；</li><li>配置中心 Spring Cloud Config</li><li>网关 Spring Gateway 和 Zuul</li><li>客户端负载均衡 Ribbon，默认策略是轮询</li><li>断路器 Hystix</li><li>RPC 客户端 Feign</li></ul><h3 id="4-限流方法（流量控制、熔断降级、系统负载保护）"><a href="#4-限流方法（流量控制、熔断降级、系统负载保护）" class="headerlink" title="4. 限流方法（流量控制、熔断降级、系统负载保护）"></a>4. 限流方法（流量控制、熔断降级、系统负载保护）</h3><ul><li>Hystrix 熔断策略基于异常比率；限流基于 QPS，支持基于调用关系的限流</li><li>Sentinel  熔断策略基于响应时间、异常比率、异常数；限流支持有限（并发线程数或信号量大小）</li><li>Redis + Lua 脚本。<br>  判断 key 是否存在，若不存在设置 key 过期时间和对应 value 为1；<br>  若存在判断在过期时间内 key 对应的 value 值是否大于限制数量，大于返回 false，小于自增加2并返回 true。</li></ul><h3 id="5-限流算法"><a href="#5-限流算法" class="headerlink" title="5. 限流算法"></a>5. 限流算法</h3><ul><li>计数器（固定窗口）</li><li>滑动窗口（Sentinel）</li><li>漏桶（Java 线程池）</li><li>令牌桶（Guava RateLimiter）</li></ul><h3 id="6-负载均衡方法"><a href="#6-负载均衡方法" class="headerlink" title="6. 负载均衡方法"></a>6. 负载均衡方法</h3><ul><li>随机</li><li>轮询</li><li>加权响应：响应时间短的权重就大</li></ul><h3 id="7-分布式锁"><a href="#7-分布式锁" class="headerlink" title="7. 分布式锁"></a>7. 分布式锁</h3><ul><li>数据库级别：读频繁用乐观锁，写频繁用悲观锁<ul><li>乐观锁：基于版本号实现</li><li>悲观锁：基于数据库级别的 for update</li></ul></li><li>基于 Redis 原子性操作，使用 setnx 和 expire 实现</li><li>基于 Rdisson 框架实现</li><li>基于 Zookeeper，使用 InterprocessMutex 实现</li></ul><h3 id="8-CAP理论"><a href="#8-CAP理论" class="headerlink" title="8. CAP理论"></a>8. CAP理论</h3><ul><li>Consistency 一致性：写之后的操作，必须返回该值。分布式系统中任意一个节点都会查询到相同的信息。</li><li>Availability 可用性：正常响应时间，服务一直可用。只要收到用户请求，服务器就必须做出响应。</li><li>Partition tolerance 分区容错性：区之间通讯可能失败，容忍某些区奔溃。当部分节点出现问题的时候，系统依然能正常堆外提供服务。</li></ul><h3 id="9-BASE-理论"><a href="#9-BASE-理论" class="headerlink" title="9. BASE 理论"></a>9. BASE 理论</h3><ul><li>Basically Available（基本可用）</li><li>Soft state（软状态）</li><li>Eventually consistent（最终一致性）</li></ul><h3 id="10-分布式事务"><a href="#10-分布式事务" class="headerlink" title="10. 分布式事务"></a>10. 分布式事务</h3><p>分布式事务是指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于不同的分布式系统的不同节点之上。常用的解决方案有：</p><ul><li>基于 XA 协议的 2PC （两阶段提交）和 3PC。Seata 常用模式</li><li>基于业务层的 TCC 方案。Try Confirm Cancel 三阶段，代码实现复杂度相对较高</li><li>使用应用消息队列 + 本地消息表实现的最终一致性方案。跨行转账可通过该方案实现。目前市面上支持该方案的 mq 只有阿里的 rocketmq，单消息队列可用于：<ul><li>用户注册成功后发送邮件</li><li>电商系统给用户发送优惠券</li></ul></li><li>最大努力通知。例如支付回调和其他一些回调通知</li></ul><h3 id="11-分布式事务框架"><a href="#11-分布式事务框架" class="headerlink" title="11. 分布式事务框架"></a>11. 分布式事务框架</h3><ul><li>Seata：提供 AT、TCC、SAGA 和 XA 事务模式</li><li>TX-LCN：提供LCN（2pc）、TCC、TXC 三种事务模式</li><li>Raincat </li></ul><h3 id="12-Seata-4种事务模式"><a href="#12-Seata-4种事务模式" class="headerlink" title="12. Seata 4种事务模式"></a>12. Seata 4种事务模式</h3><p>（AT、TCC、Saga、XA）模式分析<br>四种分布式事务模式，分别在不同的时间被提出，每种模式都有它的适用场景。</p><ul><li>AT 模式是无侵入的分布式事务解决方案，适用于不希望对业务进行改造的场景，几乎0学习成本。</li><li>TCC 模式是高性能分布式事务解决方案，适用于核心系统等对性能有很高要求的场景。</li><li>Saga 模式是长事务解决方案，适用于业务流程长且需要保证事务最终一致性的业务系统，Saga 模式一阶段就会提交本地事务，无锁，长流程情况下可以保证性能，多用于渠道层、集成层业务系统。事务参与者可能是其它公司的服务或者是遗留系统的服务，无法进行改造和提供 TCC 要求的接口，也可以使用 Saga 模式。</li><li>XA模式是分布式强一致性的解决方案，但性能低而使用较少。</li></ul><h3 id="13-分布式链路跟踪"><a href="#13-分布式链路跟踪" class="headerlink" title="13. 分布式链路跟踪"></a>13. 分布式链路跟踪</h3><ul><li>Spring Cloud Sleuth</li><li>ZipKin</li></ul><h3 id="14-分布式-id-生成方式"><a href="#14-分布式-id-生成方式" class="headerlink" title="14. 分布式 id 生成方式"></a>14. 分布式 id 生成方式</h3><ul><li>UUID</li><li>数据库自增 ID</li><li>号段模式</li><li>Redis</li><li>雪花算法</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;微服务是一种用于构建应用的架构方案。微服务架构有别于更为传统的单体式方案，可将应用拆分成多个核心功能。每个功能都被称为一项服务，可以单独构建和部署，这意味着各项服务在工作（和出现故障）时不会相互影响。&lt;br&gt;
    
    </summary>
    
      <category term="技术" scheme="https://zguishen.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="面试" scheme="https://zguishen.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Java内存模型和JVM</title>
    <link href="https://zguishen.com/posts/59848d11.html"/>
    <id>https://zguishen.com/posts/59848d11.html</id>
    <published>2020-12-20T16:00:00.000Z</published>
    <updated>2021-07-19T05:30:14.072Z</updated>
    
    <content type="html"><![CDATA[<p>对于Java开发而言，找工作面试基本上都会问道 JVM 这个知识点，其中涉及结构组成、作用原理、异常排查和参数调优等等。</p><a id="more"></a><h2 id="1-Java-内存模型"><a href="#1-Java-内存模型" class="headerlink" title="1. Java 内存模型"></a>1. Java 内存模型</h2><h3 id="1-1-概念"><a href="#1-1-概念" class="headerlink" title="1.1. 概念"></a>1.1. 概念</h3><p>Java 内存模型(即 Java Memory Model，简称 JMM )本身是一种抽象的概念，并不真实存在，它描述的是一组规则或规范，通过这组规范定义了程序中各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式。</p><h3 id="1-2-JMM-关于同步的规定"><a href="#1-2-JMM-关于同步的规定" class="headerlink" title="1.2. JMM 关于同步的规定"></a>1.2. JMM 关于同步的规定</h3><ol><li>线程解锁前，必须把共享变量的值刷新回主内存；</li><li>线程加锁前，必须读取主内存的最新值到自己的工作内存；</li><li>加锁解锁为同一把锁。</li></ol><h3 id="1-3-主内存和工作内存"><a href="#1-3-主内存和工作内存" class="headerlink" title="1.3. 主内存和工作内存"></a>1.3. 主内存和工作内存</h3><ul><li>Java 内存模型规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存，线程的工作内存中保存了该线程使用到的变量的主内存副本拷贝。</li><li>线程对变量的所有操作（读取、赋值）都必须在工作内存中进行，而不能直接读写主内存中的变量。  </li><li>不同线程之间无法直接访问对方工作内存中的变量，线程间变量值的传递均需要在主内存来完成。</li></ul><h3 id="1-4-并发编程三个特性"><a href="#1-4-并发编程三个特性" class="headerlink" title="1.4. 并发编程三个特性"></a>1.4. 并发编程三个特性</h3><ul><li>原子性：一个操作中 cpu 不能中断，要么不执行，要么执行完成</li><li>可见性：多线程访问变量，一个线程修改了变量，其他线程能够立即看到修改值</li><li>有序性：按照代码顺序执行</li></ul><h3 id="1-5-Happens-Before规则"><a href="#1-5-Happens-Before规则" class="headerlink" title="1.5. Happens-Before规则"></a>1.5. Happens-Before规则</h3><ul><li>程序顺序规则：一个线程中的每一个操作，happens-before 于该线程中的任意后续操作。</li><li>监视器规则：对一个锁的解锁，happens-before 于随后对这个锁的加锁。</li><li>volatile 规则：对一个 volatile 变量的写，happens-before 于任意后续对一个 volatile 变量的读。</li><li>传递性：如果 A happens-before B，B happens-before C，那么 A happens-before C。</li><li>线程启动规则：Thread 对象的 start() 方法，happens-before 于这个线程的任意后续操作。</li><li>线程终止规则：线程中的任意操作，happens-before 于该线程的终止监测。我们可以通过 Thread.join() 方法结束、Thread.isAlive() 的返回值等手段检测到线程已经终止执行。</li><li>线程中断操作：对线程 interrupt() 方法的调用，happens-before 于被中断线程的代码检测到中断事件的发生，可以通过 Thread.interrupted() 方法检测到线程是否有中断发生。</li><li>对象终结规则：一个对象的初始化完成，happens-before 于这个对象的 finalize() 方法的开始。</li></ul><h3 id="1-6-Java-8种关于主内存和工作内存的交互协议操作"><a href="#1-6-Java-8种关于主内存和工作内存的交互协议操作" class="headerlink" title="1.6. Java 8种关于主内存和工作内存的交互协议操作"></a>1.6. Java 8种关于主内存和工作内存的交互协议操作</h3><p>lock：作用于主内存，锁住主内存主变量。</p><p>unlock：作用于主内存，解锁主内存主变量。</p><p>read：作用主内存，主内存传递到工作内存。</p><p>load：作用于工作内存，主内存传递来的值赋给工作内存工作变量。</p><p>use：作用工作内存，工作内存工作变量值传给执行引擎。</p><p>assign：作用工作内存，引擎的结果值赋值给工作内存工作变量。</p><p>store：作用于工作内存的变量，工作内存工作变量传送到主内存中。</p><p>write：作用于主内存的变量，工作内存传来工作变量赋值给主内存主变量。</p><p>read and load 从主存复制变量到当前工作内存；<br>use and assign  执行代码，改变共享变量值；<br>store and write 用工作内存数据刷新主存相关内容。</p><p>其中use and assign 可以多次出现。<br>但是这一些操作并不是原子性，也就是 在read load之后，如果主内存count变量发生修改之后，线程工作内存中的值由于已经加载，不会产生对应的变化，所以计算出来的结果会和预期不一样。</p><p>对于volatile修饰的变量，jvm虚拟机只是保证从主内存加载到线程工作内存的值是最新的。</p><h3 id="1-7-volatile-禁止指令重排序，保证变量对所有线程的可见性"><a href="#1-7-volatile-禁止指令重排序，保证变量对所有线程的可见性" class="headerlink" title="1.7. volatile 禁止指令重排序，保证变量对所有线程的可见性"></a>1.7. volatile 禁止指令重排序，保证变量对所有线程的可见性</h3><p>一旦一个共享变量（类的成员变量、类的静态成员变量）被 volatile 修饰之后，那么就具备了两层语义：<br>1）保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的，volatile 关键字会强制将修改的值立即写入主存。<br>2）禁止进行指令重排序。<br>volatile 不是原子性操作，只保证可见性和有序性，不保证原子性。<br>使用 volatile 一般用于<strong>状态标记量</strong>和<strong>单例模式的双检锁。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000L</span>);<span class="comment">//延迟一下让主线程循环跑起来</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        flag = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadTest threadTest = <span class="keyword">new</span> ThreadTest();</span><br><span class="line">        threadTest.start();</span><br><span class="line"></span><br><span class="line">        System.out.println(threadTest.flag);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (threadTest.flag) &#123;<span class="comment">//主程读取</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"do something."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多核 CPU 下如果 flag 变量不加 volatile 关键字，主程读取 flag 变量这里可能一直读到的是 false，volatile 关键字会强制子线程将修改的值立即写入主存，并将其他线程下的缓存行失效，强制其他线程再访问此变量时从主内存中获取，达到可见性的效果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();<span class="comment">//创建对象并不是一个原子操作</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单例模式用到，new 对象不是原子操作，分三步：</p><ul><li>分配内存空间</li><li>初始化对象</li><li>对象引用指向分配的地址  </li></ul><p>由于 CPU 可能的优化排序，第三步可能会先与第二步执行，这时其他线程读到就会由问题，可用 volatile 禁止指令重排序避免此问题。</p><p>volatile 关键字使用的是 Lock 指令，volatile 的作用取决于 Lock 指令。CAS 不是保证原子的更新，而是使用死循环保证更新成功时候只有一个线程更新，不包括主工作内存的同步。 CAS 配合 volatile 既保证了只有一个线程更新又保证了多个线程更新获得的是最新的值互不影响。</p><h2 id="2-JVM"><a href="#2-JVM" class="headerlink" title="2. JVM"></a>2. JVM</h2><h3 id="2-1-JVM-内存模型"><a href="#2-1-JVM-内存模型" class="headerlink" title="2.1. JVM 内存模型"></a>2.1. JVM 内存模型</h3><ul><li>类加载器子系统</li><li>运行时数据区</li><li>执行引擎</li></ul><p><img src="https://raw.githubusercontent.com/zgshen/code-note/master/doc/images/jvm-struct.png" alt="img"></p><h3 id="2-2-运行时数据区"><a href="#2-2-运行时数据区" class="headerlink" title="2.2. 运行时数据区"></a>2.2. 运行时数据区</h3><h4 id="2-2-1-虚拟机栈"><a href="#2-2-1-虚拟机栈" class="headerlink" title="2.2.1. 虚拟机栈"></a>2.2.1. 虚拟机栈</h4><p>栈是线程私有，用来存放局部变量、对象引用和常量池引用。方法执行的时候会创建一个栈帧，存储了<strong>局部变量表、操作数栈、动态链接和方法出口信息</strong>。每个方法从调用到执行完毕，对应一个栈帧在虚拟机中的入栈和出栈。<br>Java 虚拟机栈会出现两种异常：<br><strong>StackOverFlowError</strong> ：若 Java 虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 StackOverFlowError 错误。<br><strong>OutOfMemoryError</strong> ： 若 Java 虚拟机栈的内存允许动态扩展，并且当线程请求栈时内存用完了，无法再动态扩展了，就会抛出 OutOfMemoryError 异常。</p><h4 id="2-2-2-本地方法栈"><a href="#2-2-2-本地方法栈" class="headerlink" title="2.2.2. 本地方法栈"></a>2.2.2. 本地方法栈</h4><p>线程私有，和虚拟机栈类似，主要为虚拟机使用到的 Native 方法服务，也会抛出 <code>StackOverFlowError</code> 和 <code>OutOfMemoryError</code> 错误。</p><h4 id="2-2-3-程序计数器"><a href="#2-2-3-程序计数器" class="headerlink" title="2.2.3. 程序计数器"></a>2.2.3. 程序计数器</h4><p>线程私有，是当前线程锁执行字节码的行号治时期，每条线程都有一个独立的程序计数器，这类内存也称为“线程私有”的内存。正在执行 Java 方法的话，计数器记录的是虚拟机字节码指令的地址（当前指令的地址）。如果是 Native 方法，则为空。</p><h4 id="2-2-4-堆"><a href="#2-2-4-堆" class="headerlink" title="2.2.4. 堆"></a>2.2.4. 堆</h4><p>线程共享，在虚拟机启动的时候创建，用于存放对象实例。通过-Xmx 和-Xms 来控制大小。<br>堆区域可分为新生代、老年代。（方法区中的永久代在 JDK 1.8及之后已经移除，实现为元空间）。<br>新生代可分为 Eden 空间、From Survivor 和 To Survivor 空间等。<br>堆容易出现的错误是 <code>OutOfMemoryError</code> 错误，表现有几种：</p><ul><li><code>OutOfMemoryError: GC Overhead Limit Exceeded</code> ：当JVM花太多时间执行垃圾回收并且只能回收很少的堆空间时，就会发生此错误。</li><li><code>java.lang.OutOfMemoryError: Java heap space</code> ：假如在创建新的对象时, 堆内存中的空间不足以存放新创建的对象, 就会引发这个错误(和本机物理内存无关，和你配置的堆内存大小有关)。</li></ul><h4 id="2-2-5-方法区"><a href="#2-2-5-方法区" class="headerlink" title="2.2.5. 方法区"></a>2.2.5. 方法区</h4><p>线程共享，用于存储已被 JVM 加载的类信息、静态变量、常量、属性和方法信息。<br>永久代和元空间都是方法区的一种实现，JDK1.8 之前永久代还没被彻底移除的时候通常通过下面这些参数来调节方法区大小：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:PermSize=N //方法区 (永久代) 初始大小</span><br><span class="line">-XX:MaxPermSize=N //方法区 (永久代) 最大大小,超过这个值将会抛出 OutOfMemoryError 异常 `java.lang.OutOfMemoryError: PermGen`</span><br></pre></td></tr></table></figure></p><p>JDK 1.8及之后永久代被彻底移除了，取代的是元空间，元空间使用的是直接内存，常用设置参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:MetaspaceSize=N //设置 Metaspace 的初始（和最小大小）</span><br><span class="line">-XX:MaxMetaspaceSize=N //设置 Metaspace 的最大大小</span><br></pre></td></tr></table></figure></p><p>永久代 (PermGen) 替换为元空间 (MetaSpace) 的原因是永久代有一个 JVM 本身设置固定大小上限，无法进行调整，而元空间使用的是直接内存，只受本机可用内存的限制。元空间也会溢出，但比原来出现的几率小。  </p><h3 id="2-3-三种常量池"><a href="#2-3-三种常量池" class="headerlink" title="2.3. 三种常量池"></a>2.3. 三种常量池</h3><h4 id="2-3-1-常量池"><a href="#2-3-1-常量池" class="headerlink" title="2.3.1. 常量池"></a>2.3.1. 常量池</h4><p>常量池，即 class 文件常量池，是 class 文件的一部分，用于保存编译时确定的数据；<br><img src="https://raw.githubusercontent.com/zgshen/code-note/master/doc/images/constant.png" alt="常量池"></p><h4 id="2-3-2-运行时常量池"><a href="#2-3-2-运行时常量池" class="headerlink" title="2.3.2. 运行时常量池"></a>2.3.2. 运行时常量池</h4><p>类加载后，常量池信息就会放入运行时常量池，并将常量池内符号引用替换成直接引用。运行时常量池是动态的，程序运行期间也可能产生新的常量，这些常量被放到运行时常量池中。  </p><p>运行时常量池也是方法区的一部分。</p><h4 id="2-3-3-字符串常量池"><a href="#2-3-3-字符串常量池" class="headerlink" title="2.3.3. 字符串常量池"></a>2.3.3. 字符串常量池</h4><p>字符串常量池是由 StringTable 实现的，其实就是一个 HashTable，存储在堆区。<br>字符串常量池保存着所有字符串字面量（literal strings），这些字面量在编译时期就确定。不仅如此，还可以使用 String 的 intern() 方法在运行过程将字符串添加到 String Pool 中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">String a = <span class="string">"123"</span>;</span><br><span class="line">String b = <span class="string">"123"</span>;</span><br><span class="line"></span><br><span class="line">String c = <span class="keyword">new</span> String(<span class="string">"123"</span>);</span><br><span class="line">String d = <span class="keyword">new</span> String(<span class="string">"123"</span>);</span><br><span class="line"></span><br><span class="line">String e = <span class="string">"12"</span>;</span><br><span class="line">String f = <span class="string">"3"</span>;</span><br><span class="line">String g = e + f;</span><br><span class="line">g.intern();<span class="comment">//池化后没返回</span></span><br><span class="line"></span><br><span class="line">System.out.println(a == b);<span class="comment">//true  a 和 b 都指向同一引用对象</span></span><br><span class="line">System.out.println(c == d);<span class="comment">//false 在堆中是两个不同对象</span></span><br><span class="line">System.out.println(a == c);<span class="comment">//false a 在 String Pool 中，c 在堆中，不同对象</span></span><br><span class="line">System.out.println(a == g);<span class="comment">//false + 号是使用 StringBuilder 实现拼接的</span></span><br><span class="line">g = g.intern();</span><br><span class="line">System.out.println(a == g);<span class="comment">//true g 池化后返回给 g，跟 a 指向同一对象</span></span><br></pre></td></tr></table></figure><p>对以上各种 String 对象创建的解释：<br><code>String a = &quot;123&quot;;</code> 在堆中创建对象，这个 String 对象包含了各种指针类型的成员对象，其内部实现 value 则是指向了存储在字符串常量池的字符串“123”；  </p><p><code>String c = new String(&quot;123&quot;);</code>  如果字符串常量池中不存在“123”字符串，直接在堆中创建对象然后返回给变量；如果字符串常量池中存在“123”字符串，会先在堆中创建一个 c 变量的对象引用，再将引用指向已经存在的常量对象，其实就是上面的 a 指向的对象；</p><p><code>g = g.intern()</code> 如果当前字符串内容存在于字符串常量池，那直接返回此字符串在常量池的引用；如果之前不在字符串常量池中，那么在常量池创建一个引用并且指向堆中已存在的字符串，然后返回常量池中的地址。</p><p><strong>存储位置及区别区别</strong><br>字符串常量池和运行时常量池是两个独立不同的东西。<br>JDK1.7 之前的运行时常量池，字符串常量池存放在方法区，JDK1.7 开始把字符串常量池方法区拿到了堆中，运行时常量池还在方法区。<br>到 JDK1.8 使用元空间替代永久区来实现方法区，此时运行时常量池在元空间，字符串常量池在堆。  </p><h2 id="3-类加载机制"><a href="#3-类加载机制" class="headerlink" title="3. 类加载机制"></a>3. 类加载机制</h2><h3 id="3-1-类加载过程"><a href="#3-1-类加载过程" class="headerlink" title="3.1. 类加载过程"></a>3.1. 类加载过程</h3><p><img src="https://raw.githubusercontent.com/zgshen/code-note/master/doc/images/classinit.png" alt="类加载过程"></p><p>其中验证，准备，解析一般合称链接。</p><ul><li>加载：<ul><li>获取类的二进制字节流</li><li>将字节流代表的静态存储结构转化为方法区运行时数据结构</li><li>在堆中生成class字节码对象</li></ul></li><li>验证：连接过程的第一步，确保 class 文件的字节流中的信息符合当前 JVM 的要求，不会危害 JVM 的安全</li><li>准备：为类的静态变量分配内存并将其初始化为默认值（不包含 final 修饰的静态变量，因为 final 变量在编译时分配）</li><li>解析：JVM 将常量池内符号引用替换成直接引用的过程。直接引用为直接指向目标指针或者相对偏移量等</li><li>初始化：完成静态块执行以及静态变量的赋值，先初始化父类，再初始化子类。只有对类主动使用才会初始化。<br>触发条件包括：创建类实例时，访问类静态变量和静态方法时，使用 Class.forName 反射类时或者某个子类初始化时。</li></ul><h3 id="3-2-类加载器"><a href="#3-2-类加载器" class="headerlink" title="3.2. 类加载器"></a>3.2. 类加载器</h3><p><img src="https://raw.githubusercontent.com/zgshen/code-note/master/doc/images/classload.png" alt="类加载器"></p><ul><li>启动类加载器 BootstrapClassLoad  rt.jar</li><li>扩展类加载器 ExtClassLoad  ext 目录下扩展 jar</li><li>应用程序类加载器 AppClassLoad  claddpath 上的类</li></ul><p>Java 自带的加载器的类，在虚拟机的生命周期中是不会被卸载的，只有用户自定义的加载器加载的类才可以被卸载。</p><h3 id="3-3-双亲委派机制"><a href="#3-3-双亲委派机制" class="headerlink" title="3.3. 双亲委派机制"></a>3.3. 双亲委派机制</h3><p>一个类加载器首先将类加载请求转发到父类加载器，只有当父类加载器无法完成时才尝试自己加载。<br>优点：  </p><ul><li>避免类的重复加载；</li><li>避免 Java 的核心 API 被篡改。</li></ul><h3 id="3-4-双亲委派机制如何打破"><a href="#3-4-双亲委派机制如何打破" class="headerlink" title="3.4. 双亲委派机制如何打破"></a>3.4. 双亲委派机制如何打破</h3><ul><li>自定义类加载器实现，重写自定义加载器的 loadClass()，JDk 不推荐。一般都只是重写 findClass()，这样可以保持双亲委派机制。而 loadClass 方法加载规则由自己定义，就可以随心所欲的加载类了。</li><li>JDBC驱动例子，DriverManager 在 jre/lib/rt.jar 中，加载器是 BootstrapClassLoader，但其实现则在各厂商 SPI 实现的 jar 包中。<br>根据类加载机制，若A类调用B类，则B类由A类的加载器加载。也就是启动类加载器需要加载实现类，这就出现问题，实现类不在 rt.jar 里而是在开发工程目录下。此时 SPI 是通过线程上下文类加载器 <code>Thread.currentThread().getContextClassLoader()</code> 来加载实现类。线程上下文类加载器就是当前线程的 CurrentClassloader。</li></ul><h3 id="3-5-类初始化顺序"><a href="#3-5-类初始化顺序" class="headerlink" title="3.5. 类初始化顺序"></a>3.5. 类初始化顺序</h3><ul><li>静态变量/静态代码块，普通代码块，构造器</li><li>父类静态变量/静态代码块→子类静态变量/静态代码块→父类普通代码块→父类构造器→子类普通代码块→子类构造器</li><li>子类的静态变量和静态初始化块的初始化是在父类的变量、初始化块和构造器初始化之前就完成了；（父类静态-子类静态-父类普通初始化块-子类普通初始化块。跟上面其实重复）</li><li>静态变量、静态初始化块顺序取决于它们在类中出现的先后顺序</li><li>变量、初始化块初始化顺序取决于它们在类中出现的先后顺序</li></ul><h3 id="3-6-Java的对象结构"><a href="#3-6-Java的对象结构" class="headerlink" title="3.6. Java的对象结构"></a>3.6. Java的对象结构</h3><p>Java 对象由三个部分组成：对象头、实例数据、对齐填充。</p><ul><li>对象头：由两部分组成，第一部分存储对象自身的运行时数据：哈希码、GC 分代年龄、锁标识状态、线程持有的锁、偏向线程 ID（一般占32/64 bit）。第二部分是指针类型，指向对象的类元数据类型（即对象代表哪个类）。如果是数组对象，则对象头中还有一部分用来记录数组长度。</li><li>实例数据：用来存储对象真正的有效信息（包括父类继承下来的和自己定义的）。</li><li>对齐填充：JVM 要求对象起始地址必须是8字节的整数倍（8字节对齐）。</li></ul><h2 id="4-内存分配与垃圾回收"><a href="#4-内存分配与垃圾回收" class="headerlink" title="4. 内存分配与垃圾回收"></a>4. 内存分配与垃圾回收</h2><h3 id="4-1-内存分配策略"><a href="#4-1-内存分配策略" class="headerlink" title="4.1. 内存分配策略"></a>4.1. 内存分配策略</h3><ul><li><strong>对象优先分配在 Eden 区</strong>，如果 Eden 区没有足够的空间时，虚拟机执行一次 Minor GC。</li><li><strong>大对象直接进入老年代</strong>（大对象是指需要大量连续内存空间的对象）。这样做的目的是避免在 Eden 区和两个 Survivor 区之间发生大量的内存拷贝（新生代采用复制算法收集内存）。</li><li><strong>长期存活的对象进入老年代</strong>。虚拟机为每个对象定义了一个年龄计数器，如果对象经过了1次 Minor GC 那么对象会进入 Survivor 区，之后每经过一次 Minor GC 那么对象的年龄加1，知道达到阀值对象进入老年区。</li><li><strong>动态对象年龄判定</strong>。如果 Survivor 区中相同年龄的所有对象大小的总和大于 Survivor 空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代。</li><li><strong>空间分配担保</strong>。每次进行 Minor GC 时，JVM 会计算 Survivor 区移至老年区的对象的平均大小，如果这个值大于老年区的剩余值大小则进行一次 Full GC，如果小于检查 HandlePromotionFailure 设置，如果 true 则只进行 Monitor GC,如果 false 则进行 Full GC。</li></ul><h3 id="4-2-垃圾回收判断"><a href="#4-2-垃圾回收判断" class="headerlink" title="4.2. 垃圾回收判断"></a>4.2. 垃圾回收判断</h3><ul><li>引用计数算法：引用数为0的对象回收，难以解决对象循环引用问题</li><li>根搜索法（可达性分析）：从 GC Root 对象开始向下搜索，可达的对象都是存活的，不可达的对象无法被回收</li></ul><h3 id="4-3-垃圾回收算法"><a href="#4-3-垃圾回收算法" class="headerlink" title="4.3. 垃圾回收算法"></a>4.3. 垃圾回收算法</h3><p>判断对象已死去的方法有引用计数法（已淘汰）和根搜索法（可达性分析算法）</p><ul><li>标记-清除算法：先标记需要清除对象，遍历清除，容易产生内存碎片</li><li>复制算法：分两块内存，把存活对象复制到另一块内存上，再把第一块内存所有对象清除</li><li>标记-整理算法：将标记的存活对象都像一端移动，清理端边界以外的内存（老年代）</li><li>增量算法</li><li>分代收集算法：不同的代采用不同是算法。<ul><li>年轻代采用复制算法，因为大部分对象都是朝生夕死；</li><li>Eden 区和 From Survivor 回收后存活对象复制到 To Survivor</li><li>默认15次没被回收的对象会被复制到 Old 区</li><li>Old 区也被填满时，进行 Full GC，对 Old 区进行垃圾回收</li></ul></li></ul><h3 id="4-4-垃圾回收器"><a href="#4-4-垃圾回收器" class="headerlink" title="4.4. 垃圾回收器"></a>4.4. 垃圾回收器</h3><ul><li>Serial 收集器</li><li>ParNew 收集器</li><li>Parallel Scavenge 收集器</li><li>Serial Old 收集器</li><li>Parallel Old 收集器</li><li>CMS 收集器</li><li>G1 收集器</li></ul><h3 id="4-5-GC-回收机制"><a href="#4-5-GC-回收机制" class="headerlink" title="4.5. GC 回收机制"></a>4.5. GC 回收机制</h3><h4 id="4-5-1-详细说明"><a href="#4-5-1-详细说明" class="headerlink" title="4.5.1. 详细说明"></a>4.5.1. 详细说明</h4><p><img src="https://raw.githubusercontent.com/zgshen/code-note/master/doc/images/jvm-gc.webp" alt="img"></p><p>年轻代分为 Eden 区和 Survivor 区（两块分别为 From Survivor  和 To Survivor 交替使用，哪个被回收了就由 From 变成 To），且 Eden:From:To = 8:1:1。  </p><ol><li>新产生的对象优先分配在 Eden 区（除非配置了<code>-XX:PretenureSizeThreshold</code>，大于该值的对象会直接进入年老代）; </li><li>当 Eden 区满了或放不下了，这时候其中存活的对象会复制到 From 区（如果存活下来的对象 From 区都放不下，则这些存活下来的对象全部进入年老代，即依赖老年代空间担保。之后 Eden 区的内存全部回收掉）；</li><li>之后产生的对象继续分配在 Eden 区，当 Eden 区又满了或放不下了，这时候将会把 Eden 区和 From 区存活下来的对象复制到 To 区（同理，如果存活下来的对象 To 区都放不下，则这些存活下来的对象全部进入年老代），之后回收掉 Eden 区和 From 区的所有内存；</li><li>如上这样，会有很多对象会被复制很多次（每复制一次，对象的年龄就+1），默认情况下，当对象被复制了15次，就会进入年老代了；</li><li>当年老代满了或者存放不下将要进入年老代的存活对象的时候，就会发生一次 Full GC（这个是我们最需要减少的，因为耗时很严重）。</li></ol><h4 id="4-5-2-为什么有两个-Survivor-区"><a href="#4-5-2-为什么有两个-Survivor-区" class="headerlink" title="4.5.2. 为什么有两个 Survivor 区"></a>4.5.2. 为什么有两个 Survivor 区</h4><p>因为新生代内存区域我们使用了复制算法，而使用复制算法的目的，也是为了消除内存碎片。  </p><p>新建的对象放到 Eden 中，一旦 Eden 满了，触发 Minor GC，Eden 中的存活对象就会被移动到Survivor 区。下一次 Eden 满了的时候，再进行Minor GC，Eden 和 Survivor 各有一些存活对象，如果只有一个 Survivor，Eden 第二次的 GC 的存活对象也是放在唯一的一个 Survivor 区域中。但此时把 Eden 区的存活对象硬放到 Survivor 区，很明显这两部分对象所占有的内存是不连续的，也就导致了内存碎片化。</p><h4 id="4-5-3-相关参数"><a href="#4-5-3-相关参数" class="headerlink" title="4.5.3. 相关参数"></a>4.5.3. 相关参数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-Xms20m  设置堆最小内存<span class="number">20</span>MB</span><br><span class="line">-Xmx20M  设置堆最大内存<span class="number">20</span>MB</span><br><span class="line">当-Xms和-Xmx值相同表示不允许堆内存进行扩展</span><br><span class="line"></span><br><span class="line">-Xmn5m  表示新生代内存为<span class="number">5</span>MB</span><br><span class="line">-XX:NewRatio=<span class="number">3</span>  表示新生代占堆内存<span class="number">1</span>/<span class="number">3</span></span><br><span class="line">-XX:SurvivorRatio=<span class="number">8</span>  表示Eden:<span class="number">2</span>个Survivor = <span class="number">8</span>:<span class="number">2</span></span><br></pre></td></tr></table></figure><h3 id="4-6-Minor-GC-和-Full-GC"><a href="#4-6-Minor-GC-和-Full-GC" class="headerlink" title="4.6. Minor GC 和 Full GC"></a>4.6. Minor GC 和 Full GC</h3><ul><li>Minor GC（MGC 也叫 YGC）：回收新生代，因为新生代对象存活时间很短，因此会频繁执行，速度较快</li><li>Full GC（也叫 Major GC ，FGC）：回收老年代和新生代，老年代对象存活时间长，因此 Full GC 很少执行，<br>执行速度会比 Minor GC 慢很多</li></ul><h3 id="4-7-Full-GC-触发条件"><a href="#4-7-Full-GC-触发条件" class="headerlink" title="4.7. Full GC 触发条件"></a>4.7. Full GC 触发条件</h3><ul><li>调用 System.gc()</li><li>空间分配担保失败</li><li>JDK1.7 以前的永久代空间不足</li></ul><h2 id="5-JVM-问题和调优"><a href="#5-JVM-问题和调优" class="headerlink" title="5. JVM 问题和调优"></a>5. JVM 问题和调优</h2><h3 id="5-1-内存泄漏和内存溢出的区别"><a href="#5-1-内存泄漏和内存溢出的区别" class="headerlink" title="5.1. 内存泄漏和内存溢出的区别"></a>5.1. 内存泄漏和内存溢出的区别</h3><ul><li>内存溢出(out of memory)：指程序在申请内存时，没有足够的内存空间供其使用，出现 out of memory。</li><li>内存泄露(memory leak)：指程序在申请内存后，无法释放已申请的内存空间，内存泄露堆积会导致内存被占光。(静态集合类、各类数据库和网络连接用完不关闭、内部类持有外部类、改变哈希值)</li><li>memory leak 最终会导致 out of memory。</li></ul><h3 id="5-2-OOM相关"><a href="#5-2-OOM相关" class="headerlink" title="5.2. OOM相关"></a>5.2. OOM相关</h3><h5 id="5-2-1-堆溢出"><a href="#5-2-1-堆溢出" class="headerlink" title="5.2.1. 堆溢出"></a>5.2.1. 堆溢出</h5><ul><li>1)内存泄漏（Memory Leak）：使用工具查看泄漏对象到 GC ROOTS 的引用链，找到泄漏对象是通过怎么样的路径与 GC Roots 相关联并导致垃圾收集器无法自动回收他们，准确地定位出泄漏代码的位置。</li><li>2)内存溢出(Memory overflow)：如果不是内存泄漏，换句话说，就是内存中的对象确实都还必须活着，那就应当检查虚拟机的堆参数（-Xmx 与 -Xms），与机器物理内存对比看是否还可以调大，从代码上检查是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期的内存消耗。<h5 id="5-2-2-栈内存溢出（-Xss）"><a href="#5-2-2-栈内存溢出（-Xss）" class="headerlink" title="5.2.2. 栈内存溢出（-Xss）"></a>5.2.2. 栈内存溢出（-Xss）</h5></li><li>1)如果线程请求的深度大于虚拟机所允许的最大深度，将抛出 StackOverflowError 异常。如果栈的深度小或者栈针的容量比较大、用递归时，都可能引起。</li><li>2)如果是虚拟机在扩展时无法申请到足够的内存空间，则抛出 OutOfMemoryError 异常。当使用多线程的时候，需要注意。<h5 id="5-2-3-方法区和运行时常量池溢出（-XX-PermSize-XX-MaxPermSize）"><a href="#5-2-3-方法区和运行时常量池溢出（-XX-PermSize-XX-MaxPermSize）" class="headerlink" title="5.2.3. 方法区和运行时常量池溢出（-XX:PermSize -XX:MaxPermSize）"></a>5.2.3. 方法区和运行时常量池溢出（-XX:PermSize -XX:MaxPermSize）</h5></li><li>1)常量池中存放大量的 String 对象，并保持对这些对象的引用，避免 Full GC 回收常量池，就会产生 OutOfMemoryError 异常，后面跟的提示信息是“PermGen space”,说明运行时常量池属于方法区。</li><li>2)方法区用于存放 Class 的相关信息，如类名、访问修饰符、常量池、字段描述、方法描述等。当产生大量的类去填充满方法区，就会溢出</li><li>3)Jdk1.8之后方法区由元空间替代，字符串常量池和类静态变量都放到堆中了，因为不好指定大小和容易内存溢出，增加GC复杂度，回事效率低<h5 id="5-2-4-本机直接内存溢出（-MaxDirectMemorySize）"><a href="#5-2-4-本机直接内存溢出（-MaxDirectMemorySize）" class="headerlink" title="5.2.4. 本机直接内存溢出（-MaxDirectMemorySize）"></a>5.2.4. 本机直接内存溢出（-MaxDirectMemorySize）</h5>DirectMemory 容量可通过 MaxDirectMemorySize 指定，如果不指定，则默认与 Java 堆最大值一样。虽然 DirectMemory 内存溢出时也会抛出内存溢出异常，但它抛出的异常时并没有真正向操作系统申请内存分配，于是手动抛出异常。一个明显的特征是在 Heap Dump 文件中不会看见明显的异常，如果发现 OOM 之后 Dump 文件很小，而且程序中又直接或者间接使用了 NIO，那就可以考虑检查一下是不是这方面的原因。</li></ul><h3 id="5-3-OOM-常见原因"><a href="#5-3-OOM-常见原因" class="headerlink" title="5.3. OOM 常见原因"></a>5.3. OOM 常见原因</h3><ul><li>内存加载的数据量太大，一次性从数据库获取太多数据</li><li>集合类中有对对象的引用，使用后未清空， GC 不能回收</li><li>代码存在循环产生过多的重复对象</li><li>启动参数堆内存太小</li></ul><h3 id="5-4-各类-OOM-和解决方法"><a href="#5-4-各类-OOM-和解决方法" class="headerlink" title="5.4. 各类 OOM 和解决方法"></a>5.4. 各类 OOM 和解决方法</h3><ul><li>Java堆空间<ul><li>原因：无法在 Java 堆中分配对象；应用程序无意中保存了对象引用，对象无法被 GC 回收；应用程序过度使用 finalizer。finalizer 对象不能被 GC 立刻回收。finalizer 由结束队列服务的守护线程调用，有时 finalizer 线程的处理能力无法跟上结束队列的增长</li><li>解决：使用 -Xmx 增加堆大小；修复应用程序中的内存泄漏</li></ul></li><li>GC 开销超过限制<ul><li>原因：Java 进程98%的时间在进行垃圾回收，恢复了不到2%的堆空间，最后连续5个（编译时常量）垃圾回收一直如此。</li><li>解决：使用 -Xmx 增加堆大小;使用 -XX:-UseGCOverheadLimit 取消 GC 开销限制;修复应用程序中的内存泄漏</li></ul></li><li>Requested array size exceeds VM limit 应用程序试图分配一个大于堆大小的数组<ul><li>原因：应用程序试图分配一个超过堆大小的数组</li><li>解决：使用 -Xmx 增加堆大小;修复应用程序中分配巨大数组的 bug</li></ul></li><li>Perm gen 空间<ul><li>原因：当 Perm gen 空间用尽时，将抛出异常。Perm gen 空间包含：类的名字、字段、方法；与类相关的对象数组和类型数组；JIT 编译器优化</li><li>解决：使用 -XX: MaxPermSize 增加 Permgen 大小；不重启应用部署应用程序可能会导致此问题。重启 JVM 解决</li></ul></li><li>Metaspace 元空间<ul><li>原因：从 Java 8 开始 Perm gen 改成了 Metaspace，在本机内存中分配 class 元数据（称为 metaspace）。如果 metaspace 耗尽，则抛出异常</li><li>解决：通过命令行设置 -XX: MaxMetaSpaceSize 增加 metaspace 大小；取消 -XX: maxmetsspacedize；减小 Java 堆大小,为 MetaSpace 提供更多的可用空间；为服务器分配更多的内存；修复bug</li></ul></li><li>unable to create new native thread 无法新建本机线程<ul><li>原因：内存不足，无法创建新线程。由于线程在本机内存中创建，报告这个错误表明本机内存空间不足</li><li>解决：将 heap 及 perm 的最大值下调，并将线程栈内存 -Xss 调小；修复应用程序中的线程泄漏；增加操作系统级别的限制<br><code>ulimit -a</code>；用户进程数增大 (-u) 1800；使用 -Xss 减小线程堆栈大小</li></ul></li><li>杀死进程或子进程<ul><li>原因：内核任务在可用内存极低的情况下会杀死进程</li><li>解决：将进程迁移到不同的机器上；给机器增加更多内存；与其他 OOM 错误不同，这是由操作系统而非 JVM 触发的</li></ul></li><li>发生 stack_trace_with_native_method<ul><li>原因：本机方法（native method）分配失败；打印的堆栈跟踪信息，最顶层的帧是本机方法</li><li>解决：使用操作系统本地工具进行诊断</li></ul></li></ul><h3 id="5-5-JVM-调优"><a href="#5-5-JVM-调优" class="headerlink" title="5.5. JVM 调优"></a>5.5. JVM 调优</h3><p>JVM调优是比较高深的学问，包括设置合理的内存参数，选择合理垃圾回收器甚至修改 JVM 代码等等。在一般项目中很少会去做具体调优。比较常用简单的优化：</p><ul><li>堆设置合理的-Xmx 和-Xms大小，一般两个值设为一样，避免每次 GC 后调整堆的大小；</li><li>XX:NewSize：新生代大小</li><li>XX:NewRatio 设置新生代和老年代比例；</li><li>开启 GC 日志，查看 GC 情况，排查解决 Full GC 频繁原因；</li><li>使用  Jconsole 监控工具监控线程和堆空间分配。</li></ul><h3 id="5-6-调优命令"><a href="#5-6-调优命令" class="headerlink" title="5.6. 调优命令"></a>5.6. 调优命令</h3><p>Sun JDK监控和故障处理命令有 jps jstat jmap jhat jstack jinfo</p><ul><li>jps，JVM Process Status Tool，显示指定系统内所有的 HotSpot 虚拟机进程；</li><li>jstat，JVM statistics Monitoring，用于监视虚拟机运行时状态信息的命令，它可以显示出虚拟机进程中的类装载、内存、垃圾收集、JIT 编译等运行数据；</li><li>jmap，JVM Memory Map 命令用于生成 heap dump 文件；</li><li>jhat，JVM Heap Analysis Tool 命令是与 jmap 搭配使用，用来分析 jmap 生成的 dump 文件，jhat 内置了一个微型的 HTTP/HTML 服务器，生成 dump 的分析结果后，可以在浏览器中查看；</li><li>jstack，用于生成java虚拟机当前时刻的线程快照；</li><li>jinfo，JVM Configuration info 这个命令作用是实时查看和调整虚拟机运行参数。</li></ul><h3 id="5-7-调优工具"><a href="#5-7-调优工具" class="headerlink" title="5.7. 调优工具"></a>5.7. 调优工具</h3><p>常用调优工具分为两类，JDK 自带监控工具：jconsole 和 jvisualvm，第三方有：MAT(Memory Analyzer Tool)、GChisto。</p><ul><li>jconsole，Java Monitoring and Management Console 是从 Java5 开始，在 JDK 中自带的 Java 监控和管理控制台，用于对JVM中内存，线程和类等的监控;</li><li>jvisualvm，JDK 自带全能工具，可以分析内存快照、线程快照；监控内存变化、GC 变化等;</li><li>MAT，Memory Analyzer Tool，一个基于Eclipse的内存分析工具，是一个快速、功能丰富的Java heap分析工具，它可以帮助我们查找内存泄漏和减少内存消耗;</li><li>GChisto，一款专业分析gc日志的工具。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于Java开发而言，找工作面试基本上都会问道 JVM 这个知识点，其中涉及结构组成、作用原理、异常排查和参数调优等等。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://zguishen.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="面试" scheme="https://zguishen.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>【转载】不可不说的Java“锁”事</title>
    <link href="https://zguishen.com/posts/86818cd5.html"/>
    <id>https://zguishen.com/posts/86818cd5.html</id>
    <published>2020-12-19T16:00:00.000Z</published>
    <updated>2021-07-19T05:30:14.068Z</updated>
    
    <content type="html"><![CDATA[<p>2018年11月15日 作者: 家琪 <a href="https://tech.meituan.com/2018/11/15/java-lock.html" target="_blank" rel="noopener">文章链接</a> 13658字 28分钟阅读</p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h1><p>Java提供了种类丰富的锁，每种锁因其特性的不同，在适当的场景下能够展现出非常高的效率。本文旨在对锁相关源码（本文中的源码来自JDK 8和Netty 3.10.6）、使用场景进行举例，为读者介绍主流锁的知识点，以及不同的锁的适用场景。</p><p>Java中往往是按照是否含有某一特性来定义锁，我们通过特性将锁进行分组归类，再使用对比的方式进行介绍，帮助大家更快捷的理解相关知识。下面给出本文内容的总体分类目录：</p><p><img src="https://www.notion.so/image/https%3A%2F%2Fawps-assets.meituan.net%2Fmit-x%2Fblog-images-bundle-2018b%2F7f749fc8.png?table=block&amp;id=6f741f78-8b4f-4912-97aa-02051f9a6875&amp;userId=93367cc7-49d0-4a25-8448-cdca8735d6a0&amp;cache=v2" alt="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/7f749fc8.png"></p><h3 id="1-乐观锁-VS-悲观锁"><a href="#1-乐观锁-VS-悲观锁" class="headerlink" title="1. 乐观锁 VS 悲观锁"></a><strong>1. 乐观锁 VS 悲观锁</strong></h3><p>乐观锁与悲观锁是一种广义上的概念，体现了看待线程同步的不同角度。在Java和数据库中都有此概念对应的实际应用。</p><p>先说概念。对于同一个数据的并发操作，悲观锁认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。Java中，synchronized关键字和Lock的实现类都是悲观锁。</p><p>而乐观锁认为自己在使用数据时不会有别的线程修改数据，所以不会添加锁，只是在更新数据的时候去判断之前有没有别的线程更新了这个数据。如果这个数据没有被更新，当前线程将自己修改的数据成功写入。如果数据已经被其他线程更新，则根据不同的实现方式执行不同的操作（例如报错或者自动重试）。</p><p>乐观锁在Java中是通过使用无锁编程来实现，最常采用的是CAS算法，Java原子类中的递增操作就通过CAS自旋实现的。</p><p><img src="https://www.notion.so/image/https%3A%2F%2Fawps-assets.meituan.net%2Fmit-x%2Fblog-images-bundle-2018b%2Fc8703cd9.png?table=block&amp;id=48bdc159-26d1-4457-ad5f-9182ecbf828e&amp;userId=93367cc7-49d0-4a25-8448-cdca8735d6a0&amp;cache=v2" alt="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/c8703cd9.png"></p><p>根据从上面的概念描述我们可以发现：</p><ul><li>悲观锁适合写操作多的场景，先加锁可以保证写操作时数据正确。</li><li>乐观锁适合读操作多的场景，不加锁的特点能够使其读操作的性能大幅提升。</li></ul><p>光说概念有些抽象，我们来看下乐观锁和悲观锁的调用方式示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ------------------------- 悲观锁的调用方式 -------------------------</span></span><br><span class="line"><span class="comment">// synchronized</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">testMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 操作同步资源</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ReentrantLock</span></span><br><span class="line"><span class="keyword">private</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock(); <span class="comment">// 需要保证多个线程使用的是同一个锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">modifyPublicResources</span><span class="params">()</span> </span>&#123;</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="comment">// 操作同步资源</span></span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ------------------------- 乐观锁的调用方式 -------------------------</span></span><br><span class="line"><span class="keyword">private</span> AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger();  <span class="comment">// 需要保证多个线程使用的是同一个AtomicInteger</span></span><br><span class="line">atomicInteger.incrementAndGet(); <span class="comment">//执行自增1</span></span><br></pre></td></tr></table></figure><p>通过调用方式示例，我们可以发现悲观锁基本都是在显式的锁定之后再操作同步资源，而乐观锁则直接去操作同步资源。那么，为何乐观锁能够做到不锁定同步资源也可以正确的实现线程同步呢？我们通过介绍乐观锁的主要实现方式 “CAS” 的技术原理来为大家解惑。</p><p>CAS全称 Compare And Swap（比较与交换），是一种无锁算法。在不使用锁（没有线程被阻塞）的情况下实现多线程之间的变量同步。java.util.concurrent包中的原子类就是通过CAS来实现了乐观锁。</p><p>CAS算法涉及到三个操作数：</p><ul><li>需要读写的内存值 V。</li><li>进行比较的值 A。</li><li>要写入的新值 B。</li></ul><p>当且仅当 V 的值等于 A 时，CAS通过原子方式用新值B来更新V的值（“比较+更新”整体是一个原子操作），否则不会执行任何操作。一般情况下，“更新”是一个不断重试的操作。</p><p>之前提到java.util.concurrent包中的原子类，就是通过CAS来实现了乐观锁，那么我们进入原子类AtomicInteger的源码，看一下AtomicInteger的定义：</p><p><img src="https://www.notion.so/image/https%3A%2F%2Fawps-assets.meituan.net%2Fmit-x%2Fblog-images-bundle-2018b%2Ffeda866e.png?table=block&amp;id=48e5da13-2a87-43ef-a569-44001e452b3b&amp;userId=93367cc7-49d0-4a25-8448-cdca8735d6a0&amp;cache=v2" alt="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/feda866e.png"></p><p>根据定义我们可以看出各属性的作用：</p><ul><li>unsafe： 获取并操作内存的数据。</li><li>valueOffset： 存储value在AtomicInteger中的偏移量。</li><li>value： 存储AtomicInteger的int值，该属性需要借助volatile关键字保证其在线程间是可见的。</li></ul><p>接下来，我们查看AtomicInteger的自增函数incrementAndGet()的源码时，发现自增函数底层调用的是unsafe.getAndAddInt()。但是由于JDK本身只有Unsafe.class，只通过class文件中的参数名，并不能很好的了解方法的作用，所以我们通过OpenJDK 8 来查看Unsafe的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ------------------------- JDK 8 -------------------------</span></span><br><span class="line"><span class="comment">// AtomicInteger 自增方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Unsafe.class</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> var5;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">      var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">  &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line">  <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ------------------------- OpenJDK 8 -------------------------</span></span><br><span class="line"><span class="comment">// Unsafe.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> v;</span><br><span class="line">   <span class="keyword">do</span> &#123;</span><br><span class="line">       v = getIntVolatile(o, offset);</span><br><span class="line">   &#125; <span class="keyword">while</span> (!compareAndSwapInt(o, offset, v, v + delta));</span><br><span class="line">   <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据OpenJDK 8的源码我们可以看出，getAndAddInt()循环获取给定对象o中的偏移量处的值v，然后判断内存值是否等于v。如果相等则将内存值设置为 v + delta，否则返回false，继续循环进行重试，直到设置成功才能退出循环，并且将旧值返回。整个“比较+更新”操作封装在compareAndSwapInt()中，在JNI里是借助于一个CPU指令完成的，属于原子操作，可以保证多个线程都能够看到同一个变量的修改值。</p><p>后续JDK通过CPU的cmpxchg指令，去比较寄存器中的 A 和 内存中的值 V。如果相等，就把要写入的新值 B 存入内存中。如果不相等，就将内存值 V 赋值给寄存器中的值 A。然后通过Java代码中的while循环再次调用cmpxchg指令进行重试，直到设置成功为止。</p><p>CAS虽然很高效，但是它也存在三大问题，这里也简单说一下：</p><ol><li><strong>ABA问题</strong>。CAS需要在操作值的时候检查内存值是否发生变化，没有发生变化才会更新内存值。但是如果内存值原来是A，后来变成了B，然后又变成了A，那么CAS进行检查时会发现值没有发生变化，但是实际上是有变化的。ABA问题的解决思路就是在变量前面添加版本号，每次变量更新的时候都把版本号加一，这样变化过程就从“A－B－A”变成了“1A－2B－3A”。<ul><li>JDK从1.5开始提供了AtomicStampedReference类来解决ABA问题，具体操作封装在compareAndSet()中。compareAndSet()首先检查当前引用和当前标志与预期引用和预期标志是否相等，如果都相等，则以原子方式将引用值和标志的值设置为给定的更新值。</li></ul></li><li><strong>循环时间长开销大</strong>。CAS操作如果长时间不成功，会导致其一直自旋，给CPU带来非常大的开销。</li><li><strong>只能保证一个共享变量的原子操作</strong>。对一个共享变量执行操作时，CAS能够保证原子操作，但是对多个共享变量操作时，CAS是无法保证操作的原子性的。<ul><li>Java从1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，可以把多个变量放在一个对象里来进行CAS操作。</li></ul></li></ol><h3 id="2-自旋锁-VS-适应性自旋锁"><a href="#2-自旋锁-VS-适应性自旋锁" class="headerlink" title="2. 自旋锁 VS 适应性自旋锁"></a><strong>2. 自旋锁 VS 适应性自旋锁</strong></h3><p>在介绍自旋锁前，我们需要介绍一些前提知识来帮助大家明白自旋锁的概念。</p><p>阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间。如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长。</p><p>在许多场景中，同步资源的锁定时间很短，为了这一小段时间去切换线程，线程挂起和恢复现场的花费可能会让系统得不偿失。如果物理机器有多个处理器，能够让两个或以上的线程同时并行执行，我们就可以让后面那个请求锁的线程不放弃CPU的执行时间，看看持有锁的线程是否很快就会释放锁。</p><p>而为了让当前线程“稍等一下”，我们需让当前线程进行自旋，如果在自旋完成后前面锁定同步资源的线程已经释放了锁，那么当前线程就可以不必阻塞而是直接获取同步资源，从而避免切换线程的开销。这就是自旋锁。</p><p><img src="https://www.notion.so/image/https%3A%2F%2Fawps-assets.meituan.net%2Fmit-x%2Fblog-images-bundle-2018b%2F452a3363.png?table=block&amp;id=e9206ac3-0155-4a34-a30e-b394fbf01a7d&amp;userId=93367cc7-49d0-4a25-8448-cdca8735d6a0&amp;cache=v2" alt="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/452a3363.png"></p><p>自旋锁本身是有缺点的，它不能代替阻塞。自旋等待虽然避免了线程切换的开销，但它要占用处理器时间。如果锁被占用的时间很短，自旋等待的效果就会非常好。反之，如果锁被占用的时间很长，那么自旋的线程只会白浪费处理器资源。所以，自旋等待的时间必须要有一定的限度，如果自旋超过了限定次数（默认是10次，可以使用-XX:PreBlockSpin来更改）没有成功获得锁，就应当挂起线程。</p><p>自旋锁的实现原理同样也是CAS，AtomicInteger中调用unsafe进行自增操作的源码中的do-while循环就是一个自旋操作，如果修改数值失败则通过循环来执行自旋，直至修改成功。</p><p><img src="https://www.notion.so/image/https%3A%2F%2Fawps-assets.meituan.net%2Fmit-x%2Fblog-images-bundle-2018b%2F83b3f85e.png?table=block&amp;id=deb4464a-3d0d-4f66-9f98-01f8b0cb11b1&amp;userId=93367cc7-49d0-4a25-8448-cdca8735d6a0&amp;cache=v2" alt="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/83b3f85e.png"></p><p>自旋锁在JDK1.4.2中引入，使用-XX:+UseSpinning来开启。JDK 6中变为默认开启，并且引入了自适应的自旋锁（适应性自旋锁）。</p><p>自适应意味着自旋的时间（次数）不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也是很有可能再次成功，进而它将允许自旋等待持续相对更长的时间。如果对于某个锁，自旋很少成功获得过，那在以后尝试获取这个锁时将可能省略掉自旋过程，直接阻塞线程，避免浪费处理器资源。</p><p>在自旋锁中 另有三种常见的锁形式:TicketLock、CLHlock和MCSlock，本文中仅做名词介绍，不做深入讲解，感兴趣的同学可以自行查阅相关资料。</p><h3 id="3-无锁-VS-偏向锁-VS-轻量级锁-VS-重量级锁"><a href="#3-无锁-VS-偏向锁-VS-轻量级锁-VS-重量级锁" class="headerlink" title="3. 无锁 VS 偏向锁 VS 轻量级锁 VS 重量级锁"></a><strong>3. 无锁 VS 偏向锁 VS 轻量级锁 VS 重量级锁</strong></h3><p>这四种锁是指锁的状态，专门针对synchronized的。在介绍这四种锁状态之前还需要介绍一些额外的知识。</p><p>首先为什么Synchronized能实现线程同步？</p><p>在回答这个问题之前我们需要了解两个重要的概念：“Java对象头”、“Monitor”。</p><h3 id="Java对象头"><a href="#Java对象头" class="headerlink" title="Java对象头"></a><strong>Java对象头</strong></h3><p>synchronized是悲观锁，在操作同步资源之前需要给同步资源先加锁，这把锁就是存在Java对象头里的，而Java对象头又是什么呢？</p><p>我们以Hotspot虚拟机为例，Hotspot的对象头主要包括两部分数据：Mark Word（标记字段）、Klass Pointer（类型指针）。</p><p><strong>Mark Word</strong>：默认存储对象的HashCode，分代年龄和锁标志位信息。这些信息都是与对象自身定义无关的数据，所以Mark Word被设计成一个非固定的数据结构以便在极小的空间内存存储尽量多的数据。它会根据对象的状态复用自己的存储空间，也就是说在运行期间Mark Word里存储的数据会随着锁标志位的变化而变化。</p><p><strong>Klass Point</strong>：对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</p><h3 id="Monitor"><a href="#Monitor" class="headerlink" title="Monitor"></a><strong>Monitor</strong></h3><p>Monitor可以理解为一个同步工具或一种同步机制，通常被描述为一个对象。每一个Java对象就有一把看不见的锁，称为内部锁或者Monitor锁。</p><p>Monitor是线程私有的数据结构，每一个线程都有一个可用monitor record列表，同时还有一个全局的可用列表。每一个被锁住的对象都会和一个monitor关联，同时monitor中有一个Owner字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用。</p><p>现在话题回到synchronized，synchronized通过Monitor来实现线程同步，Monitor是依赖于底层的操作系统的Mutex Lock（互斥锁）来实现的线程同步。</p><p>如同我们在自旋锁中提到的“阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间。如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长”。这种方式就是synchronized最初实现同步的方式，这就是JDK 6之前synchronized效率低的原因。这种依赖于操作系统Mutex Lock所实现的锁我们称之为“重量级锁”，JDK 6中为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”。</p><p>所以目前锁一共有4种状态，级别从低到高依次是：无锁、偏向锁、轻量级锁和重量级锁。锁状态只能升级不能降级。</p><p>通过上面的介绍，我们对synchronized的加锁机制以及相关知识有了一个了解，那么下面我们给出四种锁状态对应的的Mark Word内容，然后再分别讲解四种锁状态的思路以及特点：</p><table><thead><tr><th style="text-align:left">锁状态</th><th style="text-align:left">存储内容</th><th style="text-align:left">存储内容</th></tr></thead><tbody><tr><td style="text-align:left">无锁</td><td style="text-align:left">对象的hashCode、对象分代年龄、是否是偏向锁（0）</td><td style="text-align:left">01</td></tr><tr><td style="text-align:left">偏向锁</td><td style="text-align:left">偏向线程ID、偏向时间戳、对象分代年龄、是否是偏向锁（1）</td><td style="text-align:left">01</td></tr><tr><td style="text-align:left">轻量级锁</td><td style="text-align:left">指向栈中锁记录的指针</td><td style="text-align:left">00</td></tr><tr><td style="text-align:left">重量级锁</td><td style="text-align:left">指向互斥量（重量级锁）的指针</td><td style="text-align:left">10</td></tr></tbody></table><p><strong>无锁</strong></p><p>无锁没有对资源进行锁定，所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成功。</p><p>无锁的特点就是修改操作在循环内进行，线程会不断的尝试修改共享资源。如果没有冲突就修改成功并退出，否则就会继续循环尝试。如果有多个线程修改同一个值，必定会有一个线程能修改成功，而其他修改失败的线程会不断重试直到修改成功。上面我们介绍的CAS原理及应用即是无锁的实现。无锁无法全面代替有锁，但无锁在某些场合下的性能是非常高的。</p><p><strong>偏向锁</strong></p><p>偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁，降低获取锁的代价。</p><p>在大多数情况下，锁总是由同一线程多次获得，不存在多线程竞争，所以出现了偏向锁。其目标就是在只有一个线程执行同步代码块时能够提高性能。</p><p>当一个线程访问同步代码块并获取锁时，会在Mark Word里存储锁偏向的线程ID。在线程进入和退出同步块时不再通过CAS操作来加锁和解锁，而是检测Mark Word里是否存储着指向当前线程的偏向锁。引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径，因为轻量级锁的获取及释放依赖多次CAS原子指令，而偏向锁只需要在置换ThreadID的时候依赖一次CAS原子指令即可。</p><p>偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程不会主动释放偏向锁。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有字节码正在执行），它会首先暂停拥有偏向锁的线程，判断锁对象是否处于被锁定状态。撤销偏向锁后恢复到无锁（标志位为“01”）或轻量级锁（标志位为“00”）的状态。</p><p>偏向锁在JDK 6及以后的JVM里是默认启用的。可以通过JVM参数关闭偏向锁：-XX:-UseBiasedLocking=false，关闭之后程序默认会进入轻量级锁状态。</p><p><strong>轻量级锁</strong></p><p>是指当锁是偏向锁的时候，被另外的线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，从而提高性能。</p><p>在代码进入同步块的时候，如果同步对象锁状态为无锁状态（锁标志位为“01”状态，是否为偏向锁为“0”），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝，然后拷贝对象头中的Mark Word复制到锁记录中。</p><p>拷贝成功后，虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针，并将Lock Record里的owner指针指向对象的Mark Word。</p><p>如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位设置为“00”，表示此对象处于轻量级锁定状态。</p><p>如果轻量级锁的更新操作失败了，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行，否则说明多个线程竞争锁。</p><p>若当前只有一个等待线程，则该线程通过自旋进行等待。但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁升级为重量级锁。</p><p><strong>重量级锁</strong></p><p>升级为重量级锁时，锁标志的状态值变为“10”，此时Mark Word中存储的是指向重量级锁的指针，此时等待锁的线程都会进入阻塞状态。</p><p>整体的锁状态升级流程如下：</p><p><img src="https://www.notion.so/image/https%3A%2F%2Fawps-assets.meituan.net%2Fmit-x%2Fblog-images-bundle-2018b%2F8afdf6f2.png?table=block&amp;id=155fe7b8-c9ef-475e-9001-cc33884001d6&amp;userId=93367cc7-49d0-4a25-8448-cdca8735d6a0&amp;cache=v2" alt="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/8afdf6f2.png"></p><p>综上，偏向锁通过对比Mark Word解决加锁问题，避免执行CAS操作。而轻量级锁是通过用CAS操作和自旋来解决加锁问题，避免线程阻塞和唤醒而影响性能。重量级锁是将除了拥有锁的线程以外的线程都阻塞。</p><h3 id="4-公平锁-VS-非公平锁"><a href="#4-公平锁-VS-非公平锁" class="headerlink" title="4. 公平锁 VS 非公平锁"></a><strong>4. 公平锁 VS 非公平锁</strong></h3><p>公平锁是指多个线程按照申请锁的顺序来获取锁，线程直接进入队列中排队，队列中的第一个线程才能获得锁。公平锁的优点是等待锁的线程不会饿死。缺点是整体吞吐效率相对非公平锁要低，等待队列中除第一个线程以外的所有线程都会阻塞，CPU唤醒阻塞线程的开销比非公平锁大。</p><p>非公平锁是多个线程加锁时直接尝试获取锁，获取不到才会到等待队列的队尾等待。但如果此时锁刚好可用，那么这个线程可以无需阻塞直接获取到锁，所以非公平锁有可能出现后申请锁的线程先获取锁的场景。非公平锁的优点是可以减少唤起线程的开销，整体的吞吐效率高，因为线程有几率不阻塞直接获得锁，CPU不必唤醒所有线程。缺点是处于等待队列中的线程可能会饿死，或者等很久才会获得锁。</p><p>直接用语言描述可能有点抽象，这里作者用从别处看到的一个例子来讲述一下公平锁和非公平锁。</p><p><img src="https://www.notion.so/image/https%3A%2F%2Fawps-assets.meituan.net%2Fmit-x%2Fblog-images-bundle-2018b%2Fa23d746a.png?table=block&amp;id=04c89d23-7788-4958-bfd6-4709f50d5598&amp;userId=93367cc7-49d0-4a25-8448-cdca8735d6a0&amp;cache=v2" alt="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/a23d746a.png"></p><p>如上图所示，假设有一口水井，有管理员看守，管理员有一把锁，只有拿到锁的人才能够打水，打完水要把锁还给管理员。每个过来打水的人都要管理员的允许并拿到锁之后才能去打水，如果前面有人正在打水，那么这个想要打水的人就必须排队。管理员会查看下一个要去打水的人是不是队伍里排最前面的人，如果是的话，才会给你锁让你去打水；如果你不是排第一的人，就必须去队尾排队，这就是公平锁。</p><p>但是对于非公平锁，管理员对打水的人没有要求。即使等待队伍里有排队等待的人，但如果在上一个人刚打完水把锁还给管理员而且管理员还没有允许等待队伍里下一个人去打水时，刚好来了一个插队的人，这个插队的人是可以直接从管理员那里拿到锁去打水，不需要排队，原本排队等待的人只能继续等待。如下图所示：</p><p><img src="https://www.notion.so/image/https%3A%2F%2Fawps-assets.meituan.net%2Fmit-x%2Fblog-images-bundle-2018b%2F4499559e.png?table=block&amp;id=b47ae8bf-b461-4a42-a11f-028956f6fe7c&amp;userId=93367cc7-49d0-4a25-8448-cdca8735d6a0&amp;cache=v2" alt="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/4499559e.png"></p><p>接下来我们通过ReentrantLock的源码来讲解公平锁和非公平锁。</p><p><img src="https://www.notion.so/image/https%3A%2F%2Fawps-assets.meituan.net%2Fmit-x%2Fblog-images-bundle-2018b%2F6edea205.png?table=block&amp;id=2016f625-4500-4403-a836-dcff4bd5ddd6&amp;userId=93367cc7-49d0-4a25-8448-cdca8735d6a0&amp;cache=v2" alt="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/6edea205.png"></p><p>根据代码可知，ReentrantLock里面有一个内部类Sync，Sync继承AQS（AbstractQueuedSynchronizer），添加锁和释放锁的大部分操作实际上都是在Sync中实现的。它有公平锁FairSync和非公平锁NonfairSync两个子类。ReentrantLock默认使用非公平锁，也可以通过构造器来显示的指定使用公平锁。</p><p>下面我们来看一下公平锁与非公平锁的加锁方法的源码:</p><p><img src="https://www.notion.so/image/https%3A%2F%2Fawps-assets.meituan.net%2Fmit-x%2Fblog-images-bundle-2018b%2Fbc6fe583.png?table=block&amp;id=a824e10b-44c6-4ee8-b3e2-2ad829f8c694&amp;userId=93367cc7-49d0-4a25-8448-cdca8735d6a0&amp;cache=v2" alt="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/bc6fe583.png"></p><p>通过上图中的源代码对比，我们可以明显的看出公平锁与非公平锁的lock()方法唯一的区别就在于公平锁在获取同步状态时多了一个限制条件：hasQueuedPredecessors()。</p><p><img src="https://www.notion.so/image/https%3A%2F%2Fawps-assets.meituan.net%2Fmit-x%2Fblog-images-bundle-2018b%2Fbd0036bb.png?table=block&amp;id=553d3750-168f-4424-9370-d6fd7cdcd4d4&amp;userId=93367cc7-49d0-4a25-8448-cdca8735d6a0&amp;cache=v2" alt="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/bd0036bb.png"></p><p>再进入hasQueuedPredecessors()，可以看到该方法主要做一件事情：主要是判断当前线程是否位于同步队列中的第一个。如果是则返回true，否则返回false。</p><p>综上，公平锁就是通过同步队列来实现多个线程按照申请锁的顺序来获取锁，从而实现公平的特性。非公平锁加锁时不考虑排队等待问题，直接尝试获取锁，所以存在后申请却先获得锁的情况。</p><h3 id="5-可重入锁-VS-非可重入锁"><a href="#5-可重入锁-VS-非可重入锁" class="headerlink" title="5. 可重入锁 VS 非可重入锁"></a><strong>5. 可重入锁 VS 非可重入锁</strong></h3><p>可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁（前提锁对象得是同一个对象或者class），不会因为之前已经获取过还没释放而阻塞。Java中ReentrantLock和synchronized都是可重入锁，可重入锁的一个优点是可一定程度避免死锁。下面用示例代码来进行分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Widget</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"方法1执行..."</span>);</span><br><span class="line">        doOthers();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doOthers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"方法2执行..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，类中的两个方法都是被内置锁synchronized修饰的，doSomething()方法中调用doOthers()方法。因为内置锁是可重入的，所以同一个线程在调用doOthers()时可以直接获得当前对象的锁，进入doOthers()进行操作。</p><p>如果是一个不可重入锁，那么当前线程在调用doOthers()之前需要将执行doSomething()时获取当前对象的锁释放掉，实际上该对象锁已被当前线程所持有，且无法释放。所以此时会出现死锁。</p><p>而为什么可重入锁就可以在嵌套调用时可以自动获得锁呢？我们通过图示和源码来分别解析一下。</p><p>还是打水的例子，有多个人在排队打水，此时管理员允许锁和同一个人的多个水桶绑定。这个人用多个水桶打水时，第一个水桶和锁绑定并打完水之后，第二个水桶也可以直接和锁绑定并开始打水，所有的水桶都打完水之后打水人才会将锁还给管理员。这个人的所有打水流程都能够成功执行，后续等待的人也能够打到水。这就是可重入锁。</p><p><img src="https://www.notion.so/image/https%3A%2F%2Fawps-assets.meituan.net%2Fmit-x%2Fblog-images-bundle-2018b%2F58fc5bc9.png?table=block&amp;id=cb6c3923-09ea-4c00-9b4e-92077ba22637&amp;userId=93367cc7-49d0-4a25-8448-cdca8735d6a0&amp;cache=v2" alt="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/58fc5bc9.png"></p><p>但如果是非可重入锁的话，此时管理员只允许锁和同一个人的一个水桶绑定。第一个水桶和锁绑定打完水之后并不会释放锁，导致第二个水桶不能和锁绑定也无法打水。当前线程出现死锁，整个等待队列中的所有线程都无法被唤醒。</p><p><img src="https://www.notion.so/image/https%3A%2F%2Fawps-assets.meituan.net%2Fmit-x%2Fblog-images-bundle-2018b%2Fea597a0c.png?table=block&amp;id=100c54c2-8dcd-4cd0-a30a-3d906031d832&amp;userId=93367cc7-49d0-4a25-8448-cdca8735d6a0&amp;cache=v2" alt="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/ea597a0c.png"></p><p>之前我们说过ReentrantLock和synchronized都是重入锁，那么我们通过重入锁ReentrantLock以及非可重入锁NonReentrantLock的源码来对比分析一下为什么非可重入锁在重复调用同步资源时会出现死锁。</p><p>首先ReentrantLock和NonReentrantLock都继承父类AQS，其父类AQS中维护了一个同步状态status来计数重入次数，status初始值为0。</p><p>当线程尝试获取锁时，可重入锁先尝试获取并更新status值，如果status == 0表示没有其他线程在执行同步代码，则把status置为1，当前线程开始执行。如果status != 0，则判断当前线程是否是获取到这个锁的线程，如果是的话执行status+1，且当前线程可以再次获取锁。而非可重入锁是直接去获取并尝试更新当前status的值，如果status != 0的话会导致其获取锁失败，当前线程阻塞。</p><p>释放锁时，可重入锁同样先获取当前status的值，在当前线程是持有锁的线程的前提下。如果status-1 == 0，则表示当前线程所有重复获取锁的操作都已经执行完毕，然后该线程才会真正释放锁。而非可重入锁则是在确定当前线程是持有锁的线程之后，直接将status置为0，将锁释放。</p><p><img src="https://www.notion.so/image/https%3A%2F%2Fawps-assets.meituan.net%2Fmit-x%2Fblog-images-bundle-2018b%2F32536e7a.png?table=block&amp;id=8f7ba837-94e0-4f34-9bea-10437716184f&amp;userId=93367cc7-49d0-4a25-8448-cdca8735d6a0&amp;cache=v2" alt="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/32536e7a.png"></p><h3 id="6-独享锁-VS-共享锁"><a href="#6-独享锁-VS-共享锁" class="headerlink" title="6. 独享锁 VS 共享锁"></a><strong>6. 独享锁 VS 共享锁</strong></h3><p>独享锁和共享锁同样是一种概念。我们先介绍一下具体的概念，然后通过ReentrantLock和ReentrantReadWriteLock的源码来介绍独享锁和共享锁。</p><p>独享锁也叫排他锁，是指该锁一次只能被一个线程所持有。如果线程T对数据A加上排它锁后，则其他线程不能再对A加任何类型的锁。获得排它锁的线程即能读数据又能修改数据。JDK中的synchronized和JUC中Lock的实现类就是互斥锁。</p><p>共享锁是指该锁可被多个线程所持有。如果线程T对数据A加上共享锁后，则其他线程只能对A再加共享锁，不能加排它锁。获得共享锁的线程只能读数据，不能修改数据。</p><p>独享锁与共享锁也是通过AQS来实现的，通过实现不同的方法，来实现独享或者共享。</p><p>下图为ReentrantReadWriteLock的部分源码：</p><p><img src="https://www.notion.so/image/https%3A%2F%2Fawps-assets.meituan.net%2Fmit-x%2Fblog-images-bundle-2018b%2F762a042b.png?table=block&amp;id=06dc9e64-56ad-4bfb-b264-68f180ff2f49&amp;userId=93367cc7-49d0-4a25-8448-cdca8735d6a0&amp;cache=v2" alt="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/762a042b.png"></p><p>我们看到ReentrantReadWriteLock有两把锁：ReadLock和WriteLock，由词知意，一个读锁一个写锁，合称“读写锁”。再进一步观察可以发现ReadLock和WriteLock是靠内部类Sync实现的锁。Sync是AQS的一个子类，这种结构在CountDownLatch、ReentrantLock、Semaphore里面也都存在。</p><p>在ReentrantReadWriteLock里面，读锁和写锁的锁主体都是Sync，但读锁和写锁的加锁方式不一样。读锁是共享锁，写锁是独享锁。读锁的共享锁可保证并发读非常高效，而读写、写读、写写的过程互斥，因为读锁和写锁是分离的。所以ReentrantReadWriteLock的并发性相比一般的互斥锁有了很大提升。</p><p>那读锁和写锁的具体加锁方式有什么区别呢？在了解源码之前我们需要回顾一下其他知识。 在最开始提及AQS的时候我们也提到了state字段（int类型，32位），该字段用来描述有多少线程获持有锁。</p><p>在独享锁中这个值通常是0或者1（如果是重入锁的话state值就是重入的次数），在共享锁中state就是持有锁的数量。但是在ReentrantReadWriteLock中有读、写两把锁，所以需要在一个整型变量state上分别描述读锁和写锁的数量（或者也可以叫状态）。于是将state变量“按位切割”切分成了两个部分，高16位表示读锁状态（读锁个数），低16位表示写锁状态（写锁个数）。如下图所示：</p><p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/8793e00a.png" alt="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/8793e00a.png"></p><p>了解了概念之后我们再来看代码，先看写锁的加锁源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">Thread current = Thread.currentThread();</span><br><span class="line"><span class="keyword">int</span> c = getState(); <span class="comment">// 取到当前锁的个数</span></span><br><span class="line">    <span class="keyword">int</span> w = exclusiveCount(c); <span class="comment">// 取写锁的个数w</span></span><br><span class="line">    <span class="keyword">if</span> (c != <span class="number">0</span>) &#123; <span class="comment">// 如果已经有线程持有了锁(c!=0)</span></span><br><span class="line">        <span class="comment">// (Note: if c != 0 and w == 0 then shared count != 0)</span></span><br><span class="line">        <span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread()) <span class="comment">// 如果写线程数（w）为0（换言之存在读锁） 或者持有锁的线程不是当前线程就返回失败return false;</span></span><br><span class="line"><span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)    <span class="comment">// 如果写入锁的数量大于最大数（65535，2的16次方-1）就抛出一个Error。</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line"><span class="comment">// Reentrant acquire</span></span><br><span class="line">    setState(c + acquires);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (writerShouldBlock() || !compareAndSetState(c, c + acquires)) <span class="comment">// 如果当且写线程数为0，并且当前线程需要阻塞那么就返回失败；或者如果通过CAS增加写线程数失败也返回失败。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">setExclusiveOwnerThread(current); <span class="comment">// 如果c=0，w=0或者c&gt;0，w&gt;0（重入），则设置当前线程或锁的拥有者</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这段代码首先取到当前锁的个数c，然后再通过c来获取写锁的个数w。因为写锁是低16位，所以取低16位的最大值与当前的c做与运算（ int w = exclusiveCount©; ），高16位和0与运算后是0，剩下的就是低位运算的值，同时也是持有写锁的线程数目。</li><li>在取到写锁线程的数目后，首先判断是否已经有线程持有了锁。如果已经有线程持有了锁(c!=0)，则查看当前写锁线程的数目，如果写线程数为0（即此时存在读锁）或者持有锁的线程不是当前线程就返回失败（涉及到公平锁和非公平锁的实现）。</li><li>如果写入锁的数量大于最大数（65535，2的16次方-1）就抛出一个Error。</li><li>如果当且写线程数为0（那么读线程也应该为0，因为上面已经处理c!=0的情况），并且当前线程需要阻塞那么就返回失败；如果通过CAS增加写线程数失败也返回失败。</li><li>如果c=0,w=0或者c&gt;0,w&gt;0（重入），则设置当前线程或锁的拥有者，返回成功！</li></ul><p>tryAcquire()除了重入条件（当前线程为获取了写锁的线程）之外，增加了一个读锁是否存在的判断。如果存在读锁，则写锁不能被获取，原因在于：必须确保写锁的操作对读锁可见，如果允许读锁在已被获取的情况下对写锁的获取，那么正在运行的其他读线程就无法感知到当前写线程的操作。</p><p>因此，只有等待其他读线程都释放了读锁，写锁才能被当前线程获取，而写锁一旦被获取，则其他读写线程的后续访问均被阻塞。写锁的释放与ReentrantLock的释放过程基本类似，每次释放均减少写状态，当写状态为0时表示写锁已被释放，然后等待的读写线程才能够继续访问读写锁，同时前次写线程的修改对后续的读写线程可见。</p><p>接着是读锁的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">        getExclusiveOwnerThread() != current)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;                                   <span class="comment">// 如果其他线程已经获取了写锁，则当前线程获取读锁失败，进入等待状态</span></span><br><span class="line">    <span class="keyword">int</span> r = sharedCount(c);</span><br><span class="line">    <span class="keyword">if</span> (!readerShouldBlock() &amp;&amp;</span><br><span class="line">        r &lt; MAX_COUNT &amp;&amp;</span><br><span class="line">        compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line">            firstReader = current;</span><br><span class="line">            firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">            firstReaderHoldCount++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            HoldCounter rh = cachedHoldCounter;</span><br><span class="line">            <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                cachedHoldCounter = rh = readHolds.get();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                readHolds.set(rh);</span><br><span class="line">            rh.count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fullTryAcquireShared(current);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到在tryAcquireShared(int unused)方法中，如果其他线程已经获取了写锁，则当前线程获取读锁失败，进入等待状态。如果当前线程获取了写锁或者写锁未被获取，则当前线程（线程安全，依靠CAS保证）增加读状态，成功获取读锁。读锁的每次释放（线程安全的，可能有多个读线程同时释放读锁）均减少读状态，减少的值是“1&lt;&lt;16”。所以读写锁才能实现读读的过程共享，而读写、写读、写写的过程互斥。</p><p>此时，我们再回头看一下互斥锁ReentrantLock中公平锁和非公平锁的加锁源码：</p><p><img src="https://www.notion.so/image/https%3A%2F%2Fawps-assets.meituan.net%2Fmit-x%2Fblog-images-bundle-2018b%2F8b7878ec.png?table=block&amp;id=fd281dee-65f4-404d-a152-39b5af3bf37b&amp;userId=93367cc7-49d0-4a25-8448-cdca8735d6a0&amp;cache=v2" alt="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/8b7878ec.png"></p><p>我们发现在ReentrantLock虽然有公平锁和非公平锁两种，但是它们添加的都是独享锁。根据源码所示，当某一个线程调用lock方法获取锁时，如果同步资源没有被其他线程锁住，那么当前线程在使用CAS更新state成功后就会成功抢占该资源。而如果公共资源被占用且不是被当前线程占用，那么就会加锁失败。所以可以确定ReentrantLock无论读操作还是写操作，添加的锁都是都是独享锁。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a><strong>结语</strong></h1><p>本文Java中常用的锁以及常见的锁的概念进行了基本介绍，并从源码以及实际应用的角度进行了对比分析。限于篇幅以及个人水平，没有在本篇文章中对所有内容进行深层次的讲解。</p><p>其实Java本身已经对锁本身进行了良好的封装，降低了研发同学在平时工作中的使用难度。但是研发同学也需要熟悉锁的底层原理，不同场景下选择最适合的锁。而且源码中的思路都是非常好的思路，也是值得大家去学习和借鉴的。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><strong>参考资料</strong></h1><ol><li>《Java并发编程艺术》</li><li><a href="https://blog.csdn.net/u013256816/article/details/51204385" target="_blank" rel="noopener">Java中的锁</a></li><li><a href="https://juejin.im/post/5a73cbbff265da4e807783f5" target="_blank" rel="noopener">Java CAS 原理剖析</a></li><li><a href="https://juejin.im/post/5b42c2546fb9a04f8751eabc" target="_blank" rel="noopener">Java并发——关键字synchronized解析</a></li><li><a href="https://zhuanlan.zhihu.com/p/29866981" target="_blank" rel="noopener">Java synchronized原理总结</a></li><li><a href="http://www.infoq.com/cn/articles/java-se-16-synchronized" target="_blank" rel="noopener">聊聊并发（二）——Java SE1.6中的Synchronized</a></li><li><a href="https://blog.csdn.net/qq_19431333/article/details/70568478" target="_blank" rel="noopener">深入理解读写锁—ReadWriteLock源码分析</a></li><li><a href="https://www.cnblogs.com/twoheads/p/9635309.html" target="_blank" rel="noopener">【JUC】JDK1.8源码分析之ReentrantReadWriteLock</a></li><li><a href="https://my.oschina.net/adan1/blog/158107" target="_blank" rel="noopener">Java多线程（十）之ReentrantReadWriteLock深入分析</a></li><li><a href="https://mrdear.cn/2018/06/23/java/java--readwritelock" target="_blank" rel="noopener">Java–读写锁的实现原理</a></li></ol><h1 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a><strong>作者简介</strong></h1><ul><li>家琪，美团点评后端工程师。2017 年加入美团点评，负责美团点评境内度假的业务开发。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;2018年11月15日 作者: 家琪 &lt;a href=&quot;https://tech.meituan.com/2018/11/15/java-lock.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;文章链接&lt;/a&gt; 13658字 28分钟阅读&lt;/p&gt;
      
    
    </summary>
    
      <category term="技术" scheme="https://zguishen.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="转载" scheme="https://zguishen.com/tags/%E8%BD%AC%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>夜空中最亮的星</title>
    <link href="https://zguishen.com/posts/25d4f6f2.html"/>
    <id>https://zguishen.com/posts/25d4f6f2.html</id>
    <published>2020-12-16T16:00:00.000Z</published>
    <updated>2021-07-19T05:30:14.068Z</updated>
    
    <content type="html"><![CDATA[<p>夜空中最亮的星，请指引我前行。</p><iframe src="//player.bilibili.com/player.html?aid=41848470&bvid=BV1Jt411t7Zu&cid=73477775&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" height="500" width="100%"> </iframe>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;夜空中最亮的星，请指引我前行。&lt;/p&gt;
&lt;iframe src=&quot;//player.bilibili.com/player.html?aid=41848470&amp;bvid=BV1Jt411t7Zu&amp;cid=73477775&amp;page=1&quot; scrolling=&quot;no&quot; bor
      
    
    </summary>
    
      <category term="生活" scheme="https://zguishen.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="其他" scheme="https://zguishen.com/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title>Github Actions deploy Hexo blog</title>
    <link href="https://zguishen.com/posts/a5d4fd44.html"/>
    <id>https://zguishen.com/posts/a5d4fd44.html</id>
    <published>2020-12-15T16:00:00.000Z</published>
    <updated>2021-07-19T05:30:14.068Z</updated>
    
    <content type="html"><![CDATA[<h2 id="新建分支或-git-库存放-Hexo-源文件"><a href="#新建分支或-git-库存放-Hexo-源文件" class="headerlink" title="新建分支或 git 库存放 Hexo 源文件"></a>新建分支或 git 库存放 Hexo 源文件</h2><p>折腾一下把 Hexo 网站用 Github Actions 进行自动化部署，基本流程是这样的</p><p><img src="../images/20201216/e8f634bcc01f.png" alt="image-20201216172358832"></p><ul><li>master：主干是原来的静态网站资源，也就是 hexo 编译后 public 下的文件；</li><li>hexo-blog：新建一个分支，放 hexo 的源文件，包括配置、主题和 markdown 文本等。</li></ul><p>流程就是我们写 markdown 文章后，就推送到 hexo-blog 分支，触发 Github Actions 进行自动化部署编译，并把编译完的资源推送到 master 分支，这就完成一次 Hexo 博客的更新。</p><p>这里用的是新建 hexo-blog 分支放 Hexo 源文件，新建一个 git 库也是可以，当然 Github Actions 也是在新建的 git 库上。</p><h2 id="配置公私密钥"><a href="#配置公私密钥" class="headerlink" title="配置公私密钥"></a>配置公私密钥</h2><p>因为涉及代码的 ssh 推送等交互，所以需要设置私钥和公钥。这里因为是用一个 git 库两个分支来做的，所以公私钥都在当前 git 库设置，如果用的是新建 git 库存放 Hexo 源文件，那私钥要放在 Hexo 源文件 git 库，公钥放在静态网站库上。</p><p>生成密钥</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 4096 -C <span class="string">"xx@xx.com"</span> -f github-deploy-key -N <span class="string">""</span></span><br></pre></td></tr></table></figure><p>生成两个文件：</p><ul><li><code>github-deploy-key.pub</code> 公钥</li><li><code>github-deploy-key</code> 私钥</li></ul><p>打开 <a href="https://github.com/xxx/xxx.github.io/settings/keys" target="_blank" rel="noopener">https://github.com/xxx/xxx.github.io/settings/keys</a> 填写公钥，xxx github 用户名</p><ul><li><code>Title</code> 输入 <code>HEXO_DEPLOY_PUB</code> （自定义名称，后面自动化部署脚本用到，一致就行）</li><li><code>Key</code> 输入生成的 <code>github-deploy-key.pub</code> 的内容</li><li>勾选 <code>Allow write access</code> 用于推送分支</li></ul><p>打开 <a href="https://github.com/xxx/xxx.github.io/settings/secrets/actions" target="_blank" rel="noopener">https://github.com/xxx/xxx.github.io/settings/secrets/actions</a> 填写私钥（新建git库方式私钥在新建git库上设置）</p><ul><li><code>Name</code> 输入 <code>HEXO_DEPLOY_PRI</code></li><li><code>Value</code> 输入生成的 <code>github-deploy-key</code> 的内容</li></ul><h2 id="自动化部署脚本"><a href="#自动化部署脚本" class="headerlink" title="自动化部署脚本"></a>自动化部署脚本</h2><p>在 hexo-blog 分支根目录下创建 .github 文件夹再进去创建 workflows 文件夹再创建 HexoCI.yml 文件</p><p>编辑 HexoCI.yml 文件，内容找个别人的抄来用，<a href="https://blog.csdn.net/xinruodingshui/article/details/105499161#t4" target="_blank" rel="noopener">https://blog.csdn.net/xinruodingshui/article/details/105499161#t4</a></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">CI</span></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">hexo-blog</span> <span class="comment">##分支名</span></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Checkout</span> <span class="string">source</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/checkout@v1</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">ref:</span> <span class="string">hexo-blog</span> <span class="comment">##分支名</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Use</span> <span class="string">Node.js</span> <span class="string">$&#123;&#123;</span> <span class="string">matrix.node_version</span> <span class="string">&#125;&#125;</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/setup-node@v1</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">version:</span> <span class="string">$&#123;&#123;</span> <span class="string">matrix.node_version</span> <span class="string">&#125;&#125;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Setup</span> <span class="string">hexo</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">          <span class="attr">ACTION_DEPLOY_KEY:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.HEXO_DEPLOY_PRI</span> <span class="string">&#125;&#125;</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line">          <span class="string">mkdir</span> <span class="string">-p</span> <span class="string">~/.ssh/</span></span><br><span class="line">          <span class="string">echo</span> <span class="string">"$ACTION_DEPLOY_KEY"</span> <span class="string">&gt;</span> <span class="string">~/.ssh/id_rsa</span></span><br><span class="line">          <span class="string">chmod</span> <span class="number">600</span> <span class="string">~/.ssh/id_rsa</span></span><br><span class="line">          <span class="string">ssh-keyscan</span> <span class="string">github.com</span> <span class="string">&gt;&gt;</span> <span class="string">~/.ssh/known_hosts</span></span><br><span class="line">          <span class="string">git</span> <span class="string">config</span> <span class="string">--global</span> <span class="string">user.email</span> <span class="string">"zguishen@foxmail.com"</span></span><br><span class="line">          <span class="string">git</span> <span class="string">config</span> <span class="string">--global</span> <span class="string">user.name</span> <span class="string">"zguishen"</span></span><br><span class="line">          <span class="string">npm</span> <span class="string">install</span> <span class="string">hexo-cli</span> <span class="string">-g</span></span><br><span class="line">          <span class="string">npm</span> <span class="string">install</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Hexo</span> <span class="string">deploy</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line">          <span class="string">hexo</span> <span class="string">clean</span></span><br><span class="line">          <span class="string">hexo</span> <span class="string">d</span></span><br></pre></td></tr></table></figure><h2 id="构建结果"><a href="#构建结果" class="headerlink" title="构建结果"></a>构建结果</h2><p>Actions 里可以看到每次构建流程，失败的可以进去查看日志定位问题。</p><p><img src="../images/20201216/f5826da6fa20.png" alt="image-20201216180620677"></p><h2 id="链接优化"><a href="#链接优化" class="headerlink" title="链接优化"></a>链接优化</h2><p>安装 hexo-abbrlink 插件， package.json 中<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">"hexo-abbrlink": "^2.2.1",</span><br></pre></td></tr></table></figure></p><p>配置文件<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">url:</span> <span class="string">https://zguishen.com</span></span><br><span class="line"><span class="attr">root:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">posts/:abbrlink.html</span></span><br><span class="line"><span class="attr">abbrlink:</span></span><br><span class="line">  <span class="attr">alg:</span> <span class="string">crc32</span>  <span class="comment"># 算法：crc16(default) and crc32</span></span><br><span class="line">  <span class="attr">rep:</span> <span class="string">hex</span>    <span class="comment"># 进制：dec(default) and hex</span></span><br><span class="line"><span class="attr">permalink_defaults:</span></span><br></pre></td></tr></table></figure></p><p>不同组合链接形式不同。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;新建分支或-git-库存放-Hexo-源文件&quot;&gt;&lt;a href=&quot;#新建分支或-git-库存放-Hexo-源文件&quot; class=&quot;headerlink&quot; title=&quot;新建分支或 git 库存放 Hexo 源文件&quot;&gt;&lt;/a&gt;新建分支或 git 库存放 Hexo 源
      
    
    </summary>
    
      <category term="技术" scheme="https://zguishen.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="博客" scheme="https://zguishen.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>但行好事，莫问前程</title>
    <link href="https://zguishen.com/posts/ed4fd972.html"/>
    <id>https://zguishen.com/posts/ed4fd972.html</id>
    <published>2020-09-01T16:00:00.000Z</published>
    <updated>2021-07-19T05:30:14.068Z</updated>
    
    <content type="html"><![CDATA[<p><em>“所有漂泊的人生都梦想着平静、童年、杜鹃花，正如所有平静的人生都幻想伏特加、乐队和醉生梦死。”</em></p><p>现在是2020年9月份，今年已经过去了四分之三，离职两个月，毕业工作四年，在广州八年了。酸甜苦辣各有尝过，但没丢过生活的信心，但现在感觉已经陷入了迷雾之中，不知道该往哪里走。</p><p>有的人希望能平静度过一生，有的人渴望轰轰烈烈地活着，但是还有的人，对生活失去所有的兴趣，不知道生活的意义是什么，更甚者选择结束自己生命。  </p><a id="more"></a><p>去年年底公司已经取消班车，也没有给点交通补贴，从此开始挤公交的生活。工作项目上人员和业务变动，甲方换人，事情越来越多而且混乱，奇葩需求随便提，越感身心疲惫，感觉也是到了离开的时候。</p><p>六月初提出离职，交接了一个月，七月三日从就职将近三年的公司离职，到现在九月，时间过了四个月。但是这四个月过去了，我依然没想好自己到底要干什么。毕业四年，尝试出去面试，才发现现在招聘市场不再像以前那么景气，但要求越高了，自身水平赶不上，觉得自己是个five，想努力一把，但永远认真不起来。</p><p>从小身体不好，性格孤僻，虽然日子清苦，但至少没有什么大风大浪。按部就班大学毕业，进入企业上班，自己从来不是那优秀的一波人，比上不足，比下有余。害怕失去一切却又渴望改变，整个人都是矛盾的。</p><p>今天在v2上看到一个帖子（<a href="https://www.v2ex.com/t/703468" target="_blank" rel="noopener">https://www.v2ex.com/t/703468</a> ），没想到有不少人也是一样的状态，许多网友也给出了很好意见。</p><p>其实归根到底的原因是自己不够强，人生的许多决定都是处于被动中，一路走来都是被人推着走。生活没有什么大目标，赚不到大钱但也饿不死。与其抱怨时代背景下阶级的固化，竞争的激烈，不如干脆暂时不想，找个事做先让自己忙起来。祝愿自己早点走出困境，找到目标。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;“所有漂泊的人生都梦想着平静、童年、杜鹃花，正如所有平静的人生都幻想伏特加、乐队和醉生梦死。”&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;现在是2020年9月份，今年已经过去了四分之三，离职两个月，毕业工作四年，在广州八年了。酸甜苦辣各有尝过，但没丢过生活的信心，但现在感觉已经陷入了迷雾之中，不知道该往哪里走。&lt;/p&gt;
&lt;p&gt;有的人希望能平静度过一生，有的人渴望轰轰烈烈地活着，但是还有的人，对生活失去所有的兴趣，不知道生活的意义是什么，更甚者选择结束自己生命。  &lt;/p&gt;
    
    </summary>
    
      <category term="生活" scheme="https://zguishen.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="其他" scheme="https://zguishen.com/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title>省博物馆</title>
    <link href="https://zguishen.com/posts/b354297a.html"/>
    <id>https://zguishen.com/posts/b354297a.html</id>
    <published>2020-07-15T16:00:00.000Z</published>
    <updated>2021-07-19T05:30:14.072Z</updated>
    
    <content type="html"><![CDATA[<p>之前去广东省博物馆古生物馆没开放，没看着恐龙，这次总算看到了。<br><img src="https://user-images.githubusercontent.com/20520272/87894007-14129280-ca74-11ea-8e21-ebc6939874f4.jpg" alt="IMG_20200716_133743"><br><a id="more"></a><br><img src="https://user-images.githubusercontent.com/20520272/87894396-3822a380-ca75-11ea-8f57-2fe779a4c2b0.jpg" alt="IMG_20200716_140349"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前去广东省博物馆古生物馆没开放，没看着恐龙，这次总算看到了。&lt;br&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/20520272/87894007-14129280-ca74-11ea-8e21-ebc6939874f4.jpg&quot; alt=&quot;IMG_20200716_133743&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="生活" scheme="https://zguishen.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="其他" scheme="https://zguishen.com/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title>2020年3月</title>
    <link href="https://zguishen.com/posts/e042aa0.html"/>
    <id>https://zguishen.com/posts/e042aa0.html</id>
    <published>2020-03-26T16:00:00.000Z</published>
    <updated>2021-07-19T05:30:14.068Z</updated>
    
    <content type="html"><![CDATA[<p>现在已经是20年的三月份了，又大半年没有写什么东西了，三月本来按计划是准备跳槽重新找机会。但这半年发生太多的事情，新冠疫情依然严重，相信很多人的计划都被打乱了。<br><a id="more"></a>  </p><p>去年9月初婆婆去世，得知消息居然没有那么多悲伤，更多的是麻木了，人说没就没了，而我们什么也做不了。每次想起家人的离去还是难受，奶奶是最疼我最关心我的人，每逢节日都会问我回不回家，而我平常却很少打电话问好，现在想起来甚是后悔。  </p><p>9月份公司部门旅游我没心情参加，这段时间以来每天浑浑噩噩,上班都要应对处理各类乱七八糟的需求，下班也需要应对线上随时可能出现的问题，甲方越来越离谱，上班不开心，很不开心，不该在外包项目待这么长时间。想忍到新年过后离职重新找工作，结果新冠疫情爆发，各地封锁甚至封城，各行业有的停产有的关门，大量线下门店因此破产倒闭。进而导致许多人都降薪或者被裁了。相反的某些互联网线上业务却因此火爆起来，这段时间在家办公，加班加点赶项目反而比在公司上班更累，007工作时间，24小时 on call ，还好目前疫情总算稳定，可以到公司上班了。新年就如此艰难，2020注定给人们留下深刻的记忆。</p><iframe width="560" height="315" src="https://www.youtube.com/embed/lyUmfiD3Dzk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;现在已经是20年的三月份了，又大半年没有写什么东西了，三月本来按计划是准备跳槽重新找机会。但这半年发生太多的事情，新冠疫情依然严重，相信很多人的计划都被打乱了。&lt;br&gt;
    
    </summary>
    
      <category term="生活" scheme="https://zguishen.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="其他" scheme="https://zguishen.com/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title>Mysql清除错误临时表</title>
    <link href="https://zguishen.com/posts/85573622.html"/>
    <id>https://zguishen.com/posts/85573622.html</id>
    <published>2019-09-25T16:00:00.000Z</published>
    <updated>2021-07-19T05:30:14.072Z</updated>
    
    <content type="html"><![CDATA[<p>去年对数据库一个大表做了 optimize 操作，由于不了解具体操作就草草执行了。此操作会拷贝原表数据到临时表，如果此时硬盘空间不够，就会报错，或者表太大，执行时间将及其漫长，反正哪种都是不可接受的。<br><a id="more"></a><br>这是当时的日志<br><img src="https://user-images.githubusercontent.com/20520272/65656809-c0057000-e053-11e9-82ba-399e98adcd48.png" alt="image"></p><p>当时就把进程 kill 掉了，但是留下了一个 75G 没有用的临时表，后来因为服务器加了硬盘空间，就没有去管它。最近硬盘又快占满，这个 75G 废弃文件实在碍眼，就着手看看怎么安全删除。</p><p>首先暴力 rm 必定不可取，参考互联网资料，这个应该是官方的一个解决方案<br><a href="https://mariadb.com/resources/blog/get-rid-of-orphaned-innodb-temporary-tables-the-right-way/" target="_blank" rel="noopener">https://mariadb.com/resources/blog/get-rid-of-orphaned-innodb-temporary-tables-the-right-way/</a></p><p><img src="https://user-images.githubusercontent.com/20520272/65656922-2094ad00-e054-11e9-8c49-2ee8d50397e6.png" alt="image"></p><p>试着按参考链接执行建同名表，正常建表命令肯定不会影响数据库，找到原来的表结构建表<br>CREATE TABLE <code>#sql-5df6_36c</code> (<br>  <code>id</code> bigint(32) NOT NULL AUTO_INCREMENT,<br>  <code>card</code> varchar(50) DEFAULT NULL COMMENT ‘卡券号’,<br>  <code>createTime</code> datetime DEFAULT NULL COMMENT ‘创建时间’,<br>  <code>status</code> varchar(1) DEFAULT NULL COMMENT ‘状态’,<br>  <code>posData</code> text COMMENT ‘POS请求的数据’,<br>  <code>ffData</code> text COMMENT ‘飞凡返回的data’,<br>  <code>reason</code> varchar(500) DEFAULT NULL,<br>  PRIMARY KEY (<code>id</code>),<br>  KEY <code>card_index</code> (<code>card</code>)<br>) ENGINE=InnoDB AUTO_INCREMENT=152943355 DEFAULT CHARSET=utf8;</p><p><img src="https://user-images.githubusercontent.com/20520272/65656942-2e4a3280-e054-11e9-90e6-6f338e8b5416.png" alt="image"></p><p>结果残缺的 #sql-5df6_36c.frm 被自动删掉<br><img src="https://user-images.githubusercontent.com/20520272/65656964-3ace8b00-e054-11e9-8237-80a89a339ce7.png" alt="image"></p><p>接下来剩下缺失表结构的大文件<br>cp cc_card_log.frm /app/mysql/data/watsons_coupon/#sql-ib2460-3936078760.frm<br>复制表结构命名与临时表相同</p><p><img src="https://user-images.githubusercontent.com/20520272/65656989-4ae66a80-e054-11e9-9cd5-c9d36f4b2757.png" alt="image"></p><p>再 drop 表，提示表不存在<br><img src="https://user-images.githubusercontent.com/20520272/65657013-5cc80d80-e054-11e9-9c0a-100e0467ce8b.png" alt="image"></p><p>先再建表<br><img src="https://user-images.githubusercontent.com/20520272/65657025-66ea0c00-e054-11e9-9bc2-4bb41efbe406.png" alt="image"></p><p>可以看到与临时表同名多会生成这两个文件，原来的两个文件也还在的<br><img src="https://user-images.githubusercontent.com/20520272/65657033-70737400-e054-11e9-9e00-4b53ba93e40f.png" alt="image"></p><p>再试试 drop 表<br><img src="https://user-images.githubusercontent.com/20520272/65657048-7cf7cc80-e054-11e9-9c28-189f9c8de552.png" alt="image"></p><p>发现不行，四个文件都还在<br>再尝试<br><img src="https://user-images.githubusercontent.com/20520272/65657062-8aad5200-e054-11e9-920a-8cd054a5ccc1.png" alt="image"></p><p>@0023sql@002dib2460@002d3936078760 两个文件倒是删掉了</p><p>#sql-ib2460-3936078760 两个还好好的<br>仔细一看</p><p>#sql-ib2460-3936078760.frm  用户组用户都是 root ，cp 的时候用了 sudo 执行，需要授权用户</p><p>chown mysql:mysql #sql-ib2460-3936078760.frm<br><img src="https://user-images.githubusercontent.com/20520272/65657080-9ac53180-e054-11e9-939e-6c5c0cdb95ce.png" alt="image"></p><p>再 drop 表<br><img src="https://user-images.githubusercontent.com/20520272/65657103-a9134d80-e054-11e9-8dcd-88cecd594ce1.png" alt="image"></p><p>75G文件5s多drop掉，总算删掉了</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;去年对数据库一个大表做了 optimize 操作，由于不了解具体操作就草草执行了。此操作会拷贝原表数据到临时表，如果此时硬盘空间不够，就会报错，或者表太大，执行时间将及其漫长，反正哪种都是不可接受的。&lt;br&gt;
    
    </summary>
    
      <category term="技术" scheme="https://zguishen.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技术" scheme="https://zguishen.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>20190812-20190819</title>
    <link href="https://zguishen.com/posts/9727cb5.html"/>
    <id>https://zguishen.com/posts/9727cb5.html</id>
    <published>2019-08-18T16:00:00.000Z</published>
    <updated>2021-07-19T05:30:14.068Z</updated>
    
    <content type="html"><![CDATA[<p>《漫威蜘蛛侠》白金纪念。能力越大，责任越大。<br><img src="../images/backup/Marvel&#39;s Spider-Man_20190818214045.jpg" alt="img"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;《漫威蜘蛛侠》白金纪念。能力越大，责任越大。&lt;br&gt;&lt;img src=&quot;../images/backup/Marvel&amp;#39;s Spider-Man_20190818214045.jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;

      
    
    </summary>
    
      <category term="生活" scheme="https://zguishen.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="其他" scheme="https://zguishen.com/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title>20190805-20190811周报</title>
    <link href="https://zguishen.com/posts/a83f3ead.html"/>
    <id>https://zguishen.com/posts/a83f3ead.html</id>
    <published>2019-08-11T16:00:00.000Z</published>
    <updated>2021-07-19T05:30:14.068Z</updated>
    
    <content type="html"><![CDATA[<p>最近公司的版本管理工具从 svn 迁移到 git ，总算告别了五六个需求混在一起，只上线部分的麻烦问题。不够 git 毕竟不熟悉，经常切着分支就搞错了，什么变基操作，fetch、merge 和 pull 的用法区别等等其他东西的还是很生疏。</p><p>离职真需要下很大的决心，几个月之前就一直想要离职了，想着准备好出去面试一波。但是准备准备着就懈怠了，一天工作下来晚上根本就不想动了。叫我再去学习敲代码刷 <a href="https://leetcode.com/" target="_blank" rel="noopener">LeetCode</a> 太累了，刷番剧看沙雕视频喝快乐水实在太快乐了233，但是一想到工资就快乐不起来了。</p><p>最近流行玩蚂蚁森林养小鸡，同事纷纷加我好友，嗯，好吧，小鸡天天被揍，能量天天被头。他们玩得也太疯了吧，还买摇步器刷步数攒能量，还抓那啥妖怪来的。</p><p>电视剧《长安十二时辰》已经播到尾声了，这部剧大家都夸道具化妆太好了，力求还原唐时代元素。随着剧情的发展，人物的刻画也逐渐鲜明，可以看到大家对龙波（萧规）和张小敬的态度反转，从一开始认为龙波是个来破环长安的坏人，慢慢地理解他的行为，而张小敬的行为反而慢慢不被理解，许多人都认为长安已经腐朽，不值得去守护了。但是，如果冷静下来看看两人的行为，龙波用现代的词语来说就是一个彻头彻尾的恐怖分子，不应该为他叫好。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近公司的版本管理工具从 svn 迁移到 git ，总算告别了五六个需求混在一起，只上线部分的麻烦问题。不够 git 毕竟不熟悉，经常切着分支就搞错了，什么变基操作，fetch、merge 和 pull 的用法区别等等其他东西的还是很生疏。&lt;/p&gt;
&lt;p&gt;离职真需要下很大的
      
    
    </summary>
    
      <category term="生活" scheme="https://zguishen.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="其他" scheme="https://zguishen.com/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
</feed>
