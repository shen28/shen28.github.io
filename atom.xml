<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>啊深的博客</title>
  <subtitle>这个人很懒，神马都没有写…</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://javazgs.com/"/>
  <updated>2017-05-06T15:01:53.417Z</updated>
  <id>http://javazgs.com/</id>
  
  <author>
    <name>Shen</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>eclipse neon版本打开某些javascript文件异常问题</title>
    <link href="http://javazgs.com/2017/05/02/eclipse%20neon%E7%89%88%E6%9C%AC%E6%89%93%E5%BC%80%E6%9F%90%E4%BA%9Bjavascript%E6%96%87%E4%BB%B6%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98/"/>
    <id>http://javazgs.com/2017/05/02/eclipse neon版本打开某些javascript文件异常问题/</id>
    <published>2017-05-01T16:00:00.000Z</published>
    <updated>2017-05-06T15:01:53.417Z</updated>
    
    <content type="html"><![CDATA[<p>eclipse neon版本的javascript编辑器无法处理某些异常信息，比如本人在用require js和vue js的时候碰过这种异常<br><code>java.lang.NoSuchMethodError:jdk.nashorn.internal.runtime.ECMAException.getEcmaError()Ljava/lang/Object;</code><br>然后js文件直接就打不开了，最终在stackoverflow找到相关问题，链接<br><a href="http://stackoverflow.com/questions/38089331/eclipse-neon-java-ee-ide-javascript-editor-broken" target="_blank" rel="external">http://stackoverflow.com/questions/38089331/eclipse-neon-java-ee-ide-javascript-editor-broken</a></p>
<p>照回答者意思是javascript开发工具没法解析某些特殊语法的js代码；<br>另一个回答是说新版本的jdk已经解决这个问题，尝试卸了jdk（一直用的1.8.0_05版），装上最新版本的（目前是1.8.0_131版），问题解决。（仅供参考）</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;eclipse neon版本的javascript编辑器无法处理某些异常信息，比如本人在用require js和vue js的时候碰过这种异常&lt;br&gt;&lt;code&gt;java.lang.NoSuchMethodError:jdk.nashorn.internal.runtime
    
    </summary>
    
    
      <category term="其他" scheme="http://javazgs.com/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title>Linux下安装Nginx并配置一个图片服务器</title>
    <link href="http://javazgs.com/2017/04/21/Linux%E4%B8%8B%E5%AE%89%E8%A3%85Nginx%E5%B9%B6%E9%85%8D%E7%BD%AE%E4%B8%80%E4%B8%AA%E5%9B%BE%E7%89%87%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>http://javazgs.com/2017/04/21/Linux下安装Nginx并配置一个图片服务器/</id>
    <published>2017-04-20T16:00:00.000Z</published>
    <updated>2017-05-06T14:58:19.808Z</updated>
    
    <content type="html"><![CDATA[<p>首先到Nginx官网下载tar.gz格式的安装包，这里下载的是nginx-1.10.3版本，环境使用centos的虚拟机</p>
<p>1、将安装包上传，解压，命令tar -xvf nginx-1.10.3.tar.gz；</p>
<p>2、自定义创建一个文件夹作为Nginx安装目录，这里在home下创建nginx文件夹；<br><a id="more"></a><br><img src="http://img.blog.csdn.net/20170421004011580?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjgwOTA2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>3、在解压的文件夹（nginx-1.10.3）下执行./configure –prefix=/home/nginx 命令。<br>意思即配置安装环境，将会把Nginx安装到/home/nginx下；</p>
<p>若出现缺少依赖包则先安装依赖包，以下纯净centos mini版碰到的两个依赖包问题<br><img src="http://img.blog.csdn.net/20170421004354876?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjgwOTA2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>出现上面这个执行 yum -y install pcre-devel 安装依赖，</p>
<p><img src="http://img.blog.csdn.net/20170421004425814?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjgwOTA2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>出现这个yum install -y zlib-devel 安装依赖，</p>
<p>若还有其他依赖问题，根据缺少的文件提示安装相应的东西；</p>
<p>4、编译：在解压的文件夹下先后执行make 和 make install 命令</p>
<p>5、Nginx默认使用端口是80，这里直接先把Nginx端口改为8088，vi /home/nginx/conf/nginx.conf，修改server的端口，并配置一个图片服务器</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#user  nobody;</div><div class="line">worker_processes  1;</div><div class="line"></div><div class="line">#error_log  logs/error.log;</div><div class="line">#error_log  logs/error.log  notice;</div><div class="line">#error_log  logs/error.log  info;</div><div class="line"></div><div class="line">#pid        logs/nginx.pid;</div><div class="line"></div><div class="line"></div><div class="line">events &#123;</div><div class="line">    worker_connections  1024;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">http &#123;</div><div class="line">    include       mime.types;</div><div class="line">    default_type  application/octet-stream;</div><div class="line"></div><div class="line">    #log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '</div><div class="line">    #                  '$status $body_bytes_sent "$http_referer" '</div><div class="line">    #                  '"$http_user_agent" "$http_x_forwarded_for"';</div><div class="line"></div><div class="line">    #access_log  logs/access.log  main;</div><div class="line"></div><div class="line">    sendfile        on;</div><div class="line">    #tcp_nopush     on;</div><div class="line"></div><div class="line">    #keepalive_timeout  0;</div><div class="line">    keepalive_timeout  65;</div><div class="line"></div><div class="line">    #gzip  on;</div><div class="line"></div><div class="line">    server &#123;</div><div class="line">        listen       8088;</div><div class="line">        server_name  localhost;</div><div class="line"></div><div class="line">        #charset koi8-r;</div><div class="line"></div><div class="line">        #access_log  logs/host.access.log  main;</div><div class="line">	</div><div class="line">		location ~ .*\.(gif|jpg|jpeg|png)$ &#123;  </div><div class="line">            expires 24h;  </div><div class="line">            root /home/images/;#指定图片存放路径  </div><div class="line">            access_log /home/nginx/logs/images.log;#图片 日志路径  </div><div class="line">            proxy_store on;  </div><div class="line">            proxy_store_access user:rw group:rw all:rw;  </div><div class="line">            proxy_temp_path         /home/images/;#代理临时路径</div><div class="line">            proxy_redirect          off;  </div><div class="line"></div><div class="line">            proxy_set_header        Host 127.0.0.1;  </div><div class="line">            proxy_set_header        X-Real-IP $remote_addr;  </div><div class="line">            proxy_set_header        X-Forwarded-For $proxy_add_x_forwarded_for;  </div><div class="line">            client_max_body_size    10m;  </div><div class="line">            client_body_buffer_size 1280k;  </div><div class="line">            proxy_connect_timeout   900;  </div><div class="line">            proxy_send_timeout      900;  </div><div class="line">            proxy_read_timeout      900;  </div><div class="line">            proxy_buffer_size       40k;  </div><div class="line">            proxy_buffers           40 320k;  </div><div class="line">            proxy_busy_buffers_size 640k;  </div><div class="line">            proxy_temp_file_write_size 640k;  </div><div class="line">            if ( !-e $request_filename)  </div><div class="line">            &#123;  </div><div class="line">                 proxy_pass  http://127.0.0.1:8088;#代理访问地址  </div><div class="line">            &#125;  </div><div class="line">        &#125;</div><div class="line"></div><div class="line">        location / &#123;</div><div class="line">            root   html;</div><div class="line">            index  index.html index.htm;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        #error_page  404              /404.html;</div><div class="line"></div><div class="line">        # redirect server error pages to the static page /50x.html</div><div class="line">        #</div><div class="line">        error_page   500 502 503 504  /50x.html;</div><div class="line">        location = /50x.html &#123;</div><div class="line">            root   html;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        # proxy the PHP scripts to Apache listening on 127.0.0.1:80</div><div class="line">        #</div><div class="line">        #location ~ \.php$ &#123;</div><div class="line">        #    proxy_pass   http://127.0.0.1;</div><div class="line">        #&#125;</div><div class="line"></div><div class="line">        # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</div><div class="line">        #</div><div class="line">        #location ~ \.php$ &#123;</div><div class="line">        #    root           html;</div><div class="line">        #    fastcgi_pass   127.0.0.1:9000;</div><div class="line">        #    fastcgi_index  index.php;</div><div class="line">        #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;</div><div class="line">        #    include        fastcgi_params;</div><div class="line">        #&#125;</div><div class="line"></div><div class="line">        # deny access to .htaccess files, if Apache's document root</div><div class="line">        # concurs with nginx's one</div><div class="line">        #</div><div class="line">        #location ~ /\.ht &#123;</div><div class="line">        #    deny  all;</div><div class="line">        #&#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    # another virtual host using mix of IP-, name-, and port-based configuration</div><div class="line">    #</div><div class="line">    #server &#123;</div><div class="line">    #    listen       8000;</div><div class="line">    #    listen       somename:8080;</div><div class="line">    #    server_name  somename  alias  another.alias;</div><div class="line"></div><div class="line">    #    location / &#123;</div><div class="line">    #        root   html;</div><div class="line">    #        index  index.html index.htm;</div><div class="line">    #    &#125;</div><div class="line">    #&#125;</div><div class="line"></div><div class="line"></div><div class="line">    # HTTPS server</div><div class="line">    #</div><div class="line">    #server &#123;</div><div class="line">    #    listen       443 ssl;</div><div class="line">    #    server_name  localhost;</div><div class="line"></div><div class="line">    #    ssl_certificate      cert.pem;</div><div class="line">    #    ssl_certificate_key  cert.key;</div><div class="line"></div><div class="line">    #    ssl_session_cache    shared:SSL:1m;</div><div class="line">    #    ssl_session_timeout  5m;</div><div class="line"></div><div class="line">    #    ssl_ciphers  HIGH:!aNULL:!MD5;</div><div class="line">    #    ssl_prefer_server_ciphers  on;</div><div class="line"></div><div class="line">    #    location / &#123;</div><div class="line">    #        root   html;</div><div class="line">    #        index  index.html index.htm;</div><div class="line">    #    &#125;</div><div class="line">    #&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>server下listen的端口改为8088，并增加一个location配置，用于访问图片文件，这一串配置有#号在前面的注释掉的都可以删掉，免得看起来又长又乱。</p>
<p>6、启动命令： /home/nginx/sbin/nginx -c /home/nginx/conf/nginx.conf。<br>打开防火墙对应端口供访问，8088，当然也可以直接关了防火墙。<br>若修改了nginx.conf配置，则需要重启才生效，命令：/home/nginx/sbin/nginx -s reload</p>
<p>7、访问。<br>输入ifconfig命令查看虚拟机ip，测试：</p>
<p><img src="http://img.blog.csdn.net/20170421010243601?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjgwOTA2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title="" width="400px" height="200px"></p>
<p>在/home/images下放张图片，测试访问：<br><img src="http://img.blog.csdn.net/20170421005903034?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjgwOTA2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="doge" title="" width="300px" height="250px"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;首先到Nginx官网下载tar.gz格式的安装包，这里下载的是nginx-1.10.3版本，环境使用centos的虚拟机&lt;/p&gt;
&lt;p&gt;1、将安装包上传，解压，命令tar -xvf nginx-1.10.3.tar.gz；&lt;/p&gt;
&lt;p&gt;2、自定义创建一个文件夹作为Nginx安装目录，这里在home下创建nginx文件夹；&lt;br&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://javazgs.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>eclipse neon git 提交窗口太小问题</title>
    <link href="http://javazgs.com/2017/04/16/eclipse%20neon%20git%20%E6%8F%90%E4%BA%A4%E7%AA%97%E5%8F%A3%E5%A4%AA%E5%B0%8F%E9%97%AE%E9%A2%98/"/>
    <id>http://javazgs.com/2017/04/16/eclipse neon git 提交窗口太小问题/</id>
    <published>2017-04-15T16:00:00.000Z</published>
    <updated>2017-05-06T14:54:22.536Z</updated>
    
    <content type="html"><![CDATA[<p>eclipse neon版本的javascript编辑器无法处理某些异常信息，比如本人在用require js和vue js的时候碰过这种异常<br><code>java.lang.NoSuchMethodError:jdk.nashorn.internal.runtime.ECMAException.getEcmaError()Ljava/lang/Object;</code><br>然后js文件直接就打不开了，最终在stackoverflow找到相关问题，链接<br><a href="http://stackoverflow.com/questions/38089331/eclipse-neon-java-ee-ide-javascript-editor-broken" target="_blank" rel="external">http://stackoverflow.com/questions/38089331/eclipse-neon-java-ee-ide-javascript-editor-broken</a></p>
<p>照回答者意思是javascript开发工具没法解析某些特殊语法的js代码；<br>另一个回答是说新版本的jdk已经解决这个问题，尝试卸了jdk（一直用的1.8.0_05版），装上最新版本的（目前是1.8.0_131版），问题解决。（仅供参考）</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;eclipse neon版本的javascript编辑器无法处理某些异常信息，比如本人在用require js和vue js的时候碰过这种异常&lt;br&gt;&lt;code&gt;java.lang.NoSuchMethodError:jdk.nashorn.internal.runtime
    
    </summary>
    
    
      <category term="其他" scheme="http://javazgs.com/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title>反射</title>
    <link href="http://javazgs.com/2017/04/04/%E5%8F%8D%E5%B0%84/"/>
    <id>http://javazgs.com/2017/04/04/反射/</id>
    <published>2017-04-03T16:00:00.000Z</published>
    <updated>2017-05-06T15:01:43.492Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>相信大家经常听说某些框架设计用到了反射机制啥啥，但自己对此概念却了解甚少，虽然一般开发不会用到，但还是有必要知道反射的基本原理和操作。</p>
</blockquote>
<p>  使用反射，可以做到：</p>
<ul>
<li>在运行中分析类的能力。</li>
<li>在运行中查看对象，例如，编写一个toString方法供所有类使用。</li>
<li>实现数组的操作代码。</li>
<li>利用Method对象，这个对象很像C++中的函数指针。</li>
</ul>
<p>反射操作主要用到的类有Class（类）、Field（属性）、Method（成员函数）、Constructor（构造）和Modifier（修饰符）<br><a id="more"></a><br>一、反射获取类</p>
<p>新建一个Student类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</div><div class="line">	<span class="keyword">private</span> String name;</div><div class="line">	</div><div class="line">	<span class="comment">//无参构造</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="comment">//有参构造</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(<span class="keyword">int</span> age, String name)</span></span>&#123;</div><div class="line">		<span class="keyword">this</span>.age = age;</div><div class="line">		<span class="keyword">this</span>.name = name;</div><div class="line">		System.out.println(<span class="string">"My name is "</span>+name+<span class="string">",I'm "</span>+age+<span class="string">" years old."</span>);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.age = age;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.name = name;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> age;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> name;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">learning</span><span class="params">()</span> </span>&#123;</div><div class="line">		System.out.println(<span class="string">"learning..."</span>);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>测试类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">public class ReflexTest &#123;</div><div class="line">	public static void main(String[] args) throws ClassNotFoundException &#123;</div><div class="line">		Student student = new Student(20, &quot;shen&quot;);//一般创建对象</div><div class="line">		</div><div class="line">		Class stu = Class.forName(&quot;com.test.reflex.Student&quot;);//通过Class获取指定类的完整结构</div><div class="line">		System.out.println(&quot;getName---&gt;&quot;+stu.getName());</div><div class="line">		</div><div class="line">		Student s = null;</div><div class="line">		Student s1 = null; </div><div class="line">		try &#123;</div><div class="line">			s = (Student)stu.newInstance();//默认构造的是无参构造，若存在有参构造，这里将报错</div><div class="line">			</div><div class="line">			Constructor constructor = stu.getConstructor(int.class, String.class);//获取有参构造,已知确定参数</div><div class="line">			s1 = (Student)constructor.newInstance(23, &quot;shen&quot;);//有参构造</div><div class="line">			</div><div class="line">			Constructor[] constructors = stu.getConstructors();//所有构造</div><div class="line">			s1 = (Student)constructors[0].newInstance();//第一个构造(无参那个)</div><div class="line">		&#125; catch (Exception e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>输出：<br><img src="http://img.blog.csdn.net/20170403212710052?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjgwOTA2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>Class类forName方法通过完整包路径类型来实例化Class对象，再通过Class对象获取Student类实例；<br>再使用newInstance()创建对象，这里要注意Student的构造方法，默认使用的试试无参构造，可使用Constructor类操作构造方法。</p>
<p>二、获取类的基本结构</p>
<p>1、使用反射操作对象属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">public class Test01 &#123;</div><div class="line">	public static void main(String[] args) throws Exception, Exception &#123;</div><div class="line">		try &#123;</div><div class="line">			Class stu = Class.forName(&quot;com.test.reflex.Student&quot;);</div><div class="line">			</div><div class="line">			Constructor constructor = stu.getConstructor(int.class, String.class);//获取有参构造,已知确定参数</div><div class="line">			Student s = (Student)constructor.newInstance(23, &quot;shen&quot;);//有参构造</div><div class="line">			</div><div class="line">			//Field[] fields = stu.getFields();//获取public的属性</div><div class="line">			Field[] fields = stu.getDeclaredFields();//获取所有属性</div><div class="line">			for(Field field : fields)&#123;</div><div class="line">				System.out.println(&quot;属性--&gt;&quot;+field);</div><div class="line">			&#125;</div><div class="line">			</div><div class="line">			Field fieldName = stu.getDeclaredField(&quot;name&quot;);//获取私有变量name</div><div class="line">			fieldName.setAccessible(true);</div><div class="line">			System.out.println(fieldName.getName());//私有属性名称</div><div class="line">			System.out.println(fieldName.get(s));//私有属性值</div><div class="line">			</div><div class="line">			fieldName.set(s, &quot;a-shen&quot;);</div><div class="line">			System.out.println(fieldName.get(s));//改变私有属性值</div><div class="line">			</div><div class="line">		&#125; catch (ClassNotFoundException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>结果输出<br><img src="http://img.blog.csdn.net/20170403212205519?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjgwOTA2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>其中对于fieldName.setAccessible(true);使用java反射获取类的属性值时，如果该属性被声明为private 的，需要将setAccessible设置为true. 默认的值为false</p>
<p>2、使用反射访问成员函数<br>通过反射调用方法，使用invoke方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">public class Test02 &#123;</div><div class="line">	public static void main(String[] args) throws Exception, Exception &#123;</div><div class="line">		try &#123;</div><div class="line">			Class stu = Class.forName(&quot;com.test.reflex.Student&quot;);</div><div class="line">			</div><div class="line">			Constructor constructor = stu.getConstructor(int.class, String.class);//获取有参构造,已知确定参数</div><div class="line">			Constructor[] constructors = stu.getConstructors();</div><div class="line">			Student s = (Student)constructors[0].newInstance();//无参构造对象</div><div class="line">			</div><div class="line">			//Method[] methods = stu.getMethods();//获取类所有方法，包括继承自父类和实现接口的方法</div><div class="line">			Method[] methods = stu.getDeclaredMethods();//获取类本身各类方法和实现接口的方法及重写的方法，不包括继承的方法</div><div class="line">			for(Method method : methods)&#123;</div><div class="line">				System.out.println(&quot;成员函数---&gt;&quot;+method);</div><div class="line">			&#125;</div><div class="line">			</div><div class="line">			Method m1 = s.getClass().getMethod(&quot;setName&quot;, String.class);</div><div class="line">			m1.invoke(s, &quot;ashen&quot;);//设置name值为&quot;ashen&quot;</div><div class="line">			</div><div class="line">			Method m2 = s.getClass().getMethod(&quot;getName&quot;);</div><div class="line">			String name = (String) m2.invoke(s);</div><div class="line">			System.out.println(&quot;getName---&gt;&quot;+name);//输出name值</div><div class="line">			</div><div class="line">		&#125;catch (ClassNotFoundException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结果输出<br><img src="http://img.blog.csdn.net/20170404015222950?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjgwOTA2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;相信大家经常听说某些框架设计用到了反射机制啥啥，但自己对此概念却了解甚少，虽然一般开发不会用到，但还是有必要知道反射的基本原理和操作。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;  使用反射，可以做到：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在运行中分析类的能力。&lt;/li&gt;
&lt;li&gt;在运行中查看对象，例如，编写一个toString方法供所有类使用。&lt;/li&gt;
&lt;li&gt;实现数组的操作代码。&lt;/li&gt;
&lt;li&gt;利用Method对象，这个对象很像C++中的函数指针。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;反射操作主要用到的类有Class（类）、Field（属性）、Method（成员函数）、Constructor（构造）和Modifier（修饰符）&lt;br&gt;
    
    </summary>
    
    
      <category term="Java基础" scheme="http://javazgs.com/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Mysql存储过程</title>
    <link href="http://javazgs.com/2017/02/26/Mysql%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/"/>
    <id>http://javazgs.com/2017/02/26/Mysql存储过程/</id>
    <published>2017-02-25T16:00:00.000Z</published>
    <updated>2017-05-06T15:01:26.783Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>当需要实现复杂的逻辑，需要写多条sql语句或写的sql比较复杂时，可以考虑使用存储过程来处理，最终返回需要的结果集。存储过程即一组SQL语句集。</p>
</blockquote>
<p>存储过程的基本语法也不算复杂，以下为创建一个存储过程的模板<br><a id="more"></a><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> TEST_FUNCTION;</div><div class="line"><span class="comment">/*定义存储过程名称，设置入参，指定类型和大小*/</span></div><div class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> TEST_FUNCTION(<span class="keyword">in</span> DATA_A <span class="built_in">INT</span>(<span class="number">20</span>),<span class="keyword">in</span> DATA_B <span class="built_in">INT</span>(<span class="number">20</span>),<span class="keyword">in</span> B_TYPE <span class="built_in">varchar</span>(<span class="number">20</span>))</div><div class="line"><span class="keyword">BEGIN</span></div><div class="line">     <span class="comment">/*DECLARE 关键字用于定义变量*/</span></div><div class="line">    <span class="keyword">DECLARE</span> <span class="keyword">SUM</span> <span class="built_in">int</span> <span class="keyword">default</span> <span class="number">0</span>;</div><div class="line">    <span class="keyword">DECLARE</span> t_error <span class="built_in">INTEGER</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</div><div class="line">    <span class="keyword">DECLARE</span> CONTINUE <span class="keyword">HANDLER</span> <span class="keyword">FOR</span> SQLEXCEPTION <span class="keyword">SET</span> t_error=<span class="number">1</span>;<span class="comment">/*异常标志*/</span></div><div class="line">    </div><div class="line">    <span class="keyword">START</span> <span class="keyword">TRANSACTION</span>;<span class="comment">/*启动事务*/</span></div><div class="line">    <span class="comment">/*字符串的判断，STRCMP用法类似于C++*/</span></div><div class="line">    if STRCMP(B_TYPE,'SUM')=0 then</div><div class="line">    <span class="keyword">begin</span></div><div class="line">         <span class="keyword">SELECT</span>  DATA_A+DATA_B <span class="keyword">INTO</span> <span class="keyword">SUM</span>;<span class="comment">/*INTO 把值放到变量中*/</span></div><div class="line">         <span class="keyword">SELECT</span> <span class="keyword">SUM</span>;</div><div class="line">    <span class="keyword">end</span>;<span class="comment">/*一个begin对应一个end*/</span></div><div class="line">    <span class="keyword">end</span> <span class="keyword">if</span>;<span class="comment">/*一个if对应一个end if*/</span></div><div class="line">    </div><div class="line">    IF t_error = 1 THEN  </div><div class="line">    <span class="keyword">ROLLBACK</span>;<span class="comment">/*异常回滚*/</span></div><div class="line">    ELSE</div><div class="line">    <span class="keyword">COMMIT</span>;<span class="comment">/*正常提交*/</span></div><div class="line">    <span class="keyword">END</span> <span class="keyword">IF</span>;</div><div class="line"><span class="keyword">END</span>;</div></pre></td></tr></table></figure></p>
<p>创建生成的样子</p>
<p><img src="http://img.blog.csdn.net/20170226161939611?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjgwOTA2Mg==/font/5a6L5L2T/fontsize/200/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>DEFINER的信息是’用户名’@’host’</p>
<p>输入参数值测试<br><img src="http://img.blog.csdn.net/20170226162314021?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjgwOTA2Mg==/font/5a6L5L2T/fontsize/200/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>调用存储使用call命令<br><img src="http://img.blog.csdn.net/20170226162538526?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjgwOTA2Mg==/font/5a6L5L2T/fontsize/200/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;当需要实现复杂的逻辑，需要写多条sql语句或写的sql比较复杂时，可以考虑使用存储过程来处理，最终返回需要的结果集。存储过程即一组SQL语句集。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;存储过程的基本语法也不算复杂，以下为创建一个存储过程的模板&lt;br&gt;
    
    </summary>
    
    
      <category term="数据库" scheme="http://javazgs.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>内部类相关——定义、匿名内部类、回调实现及静态内部类</title>
    <link href="http://javazgs.com/2017/02/23/%E5%86%85%E9%83%A8%E7%B1%BB%E7%9B%B8%E5%85%B3%E2%80%94%E2%80%94%E5%AE%9A%E4%B9%89%E3%80%81%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E3%80%81%E5%9B%9E%E8%B0%83%E5%AE%9E%E7%8E%B0%E5%8F%8A%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB/"/>
    <id>http://javazgs.com/2017/02/23/内部类相关——定义、匿名内部类、回调实现及静态内部类/</id>
    <published>2017-02-22T16:00:00.000Z</published>
    <updated>2017-05-06T14:53:09.456Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>内部类，顾名思义就是在一个类中的类。内部类可以访问所在类的数据，包括私有数据，而又可以对其他类隐藏，在快速实现回调函数时可以使用匿名内部类，比较便捷。</p>
</blockquote>
<p>1、以下为一个简单的内部类例子，内部类可以定义为私有以对其他类隐藏起来；可以用内部类来达到实现多继承的效果。需要注意的是，通过成员函数传入内部类的变量必须定义为final类型，以保证数据的一致性。<a id="more"></a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Walk</span></span>&#123;</div><div class="line">	<span class="comment">//private私有类，继承Walk和Eat</span></div><div class="line">	<span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">LittleCat</span> <span class="keyword">extends</span> <span class="title">Eat</span> </span>&#123;</div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</div><div class="line">			System.out.println(<span class="string">"Walking....Eating...."</span>);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		LittleCat lCat = <span class="keyword">new</span> Cat().new LittleCat();<span class="comment">//创建内部类对象方式，通过先创建所在外围类对象再创建内部类对象</span></div><div class="line">		lCat.doSomething();</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">event</span><span class="params">(<span class="keyword">final</span> String name)</span> </span>&#123;</div><div class="line">		<span class="class"><span class="keyword">class</span> <span class="title">EatFish</span></span>&#123;</div><div class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</div><div class="line">				<span class="comment">//name = "Tom";//在这里修改会报错，name 必须为final类型，保证数据一致</span></div><div class="line">				System.out.println(name);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		EatFish test = <span class="keyword">new</span> EatFish();</div><div class="line">		test.eat();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>两个父类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">public class Walk &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">public class Eat &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>2、匿名内部类<br>从名称可以知道匿名就是没有类名的类，匿名内部类用于快速调用接口或抽象类等等中的方法，不需要多写一个实现类来实现调用。</p>
<p>抽象类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public abstract class Dog &#123;</div><div class="line">	abstract void eat();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>接口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface Animal &#123;</div><div class="line">	void eat();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>测试类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">public class AnonymousDemo &#123;</div><div class="line">	</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		 </div><div class="line">		/**</div><div class="line">		 * 通过创建的一个接口或抽象类分引用，快速便捷重写需要实现的方法，不需要先写一个实现类再实例化以调用方法</div><div class="line">		 */</div><div class="line">		</div><div class="line">		//实现接口方式</div><div class="line">		Animal dog = new Animal() &#123;</div><div class="line">			@Override</div><div class="line">			public void eat() &#123;</div><div class="line">				System.out.println(&quot;like bone.&quot;);</div><div class="line">			&#125;</div><div class="line">		&#125;;</div><div class="line">		dog.eat();//向上转型的实例，直接调用重写的eat方法</div><div class="line">		</div><div class="line">		//继承抽象类的方式</div><div class="line">		Dog littleDog = new Dog() &#123;</div><div class="line">			@Override</div><div class="line">			void eat() &#123;</div><div class="line">				System.out.println(&quot;I like bone.&quot;);</div><div class="line">			&#125;</div><div class="line">		&#125;;</div><div class="line">		littleDog.eat();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>此外，Java的回调函数式可以通过匿名内部类来实现，比如以下例子</p>
<p>(1)封装的类和提供的接口<br>封装给别人调用的类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public class Person &#123;</div><div class="line">	</div><div class="line">	private EatFood eatFood;</div><div class="line">	</div><div class="line">	/**</div><div class="line">	 * 普通方式，构造传递引用</div><div class="line">	 */</div><div class="line">	public Person(EatFood eatSomething)&#123;</div><div class="line">		this.eatFood = eatSomething;//构造时传入引用</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	</div><div class="line">	/**</div><div class="line">	 * 普通方式，成员函数传递引用</div><div class="line">	 */</div><div class="line">	public Person()&#123;</div><div class="line">	&#125;</div><div class="line">	public void setCallBack(EatFood eatSomething) &#123;</div><div class="line">		this.eatFood = eatSomething;//用成员函数传入引用</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	//需要调用的方法</div><div class="line">	public void eatFood() &#123;</div><div class="line">		eatFood.eat();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>调用类需要的接口定义<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface EatFood &#123;</div><div class="line">	void eat();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>(2)实际调用<br>一般做法都会写一个类实现接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class EatRice implements EatFood &#123;</div><div class="line">	@Override</div><div class="line">	public void eat() &#123;</div><div class="line">		// TODO Auto-generated method stub</div><div class="line">		System.out.println(&quot;It&apos;s time to eat rice.&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后是实际使用的类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class PeronEatTest &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		//普通方式，构造传递引用</div><div class="line">		Person personOne = new Person(new EatRice());//EatRice实现类方式。多写一个方法传入也可</div><div class="line">		personOne.eatFood();</div><div class="line"></div><div class="line">		//普通方式，成员函数传递引用</div><div class="line">		Person personOne = new Person();</div><div class="line">		EatRice eatRice = new EatRice();</div><div class="line">		personOne.setCallBack(eatRice);</div><div class="line">		personOne.eatFood();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果使用匿名内部类就便捷了许多<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class PeronEatTest &#123;</div><div class="line">	public static void main(String[] args) &#123;	</div><div class="line">		Person personTwo = new Person(new EatFood() &#123;</div><div class="line">			@Override</div><div class="line">			public void eat() &#123;</div><div class="line">				// TODO Auto-generated method stub</div><div class="line">				System.out.println(&quot;It&apos;s time to eat rice.&quot;);</div><div class="line">			&#125;</div><div class="line">		&#125;);</div><div class="line">		personTwo.eatFood();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>3、静态内部类<br>创建是不需要依赖于外围类，但也不能使用任何外围类的非static成员变量和方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">public class Cat&#123;</div><div class="line">	</div><div class="line">	private String str = &quot;cat&quot;;</div><div class="line">	private static String str_static = &quot;cat&quot;;</div><div class="line">	</div><div class="line">	private class LittleCat&#123;</div><div class="line">		//public static String str_test = &quot;test&quot;;//错误，非静态内部类变量不能为静态</div><div class="line">		public static final String str_test = &quot;test&quot;;//但加上final就可以</div><div class="line">		public void doSomething() &#123;</div><div class="line">			str = &quot;little cat&quot;;</div><div class="line">			System.out.println(&quot;Walking....Eating....&quot;);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	static class BigCat&#123;</div><div class="line">		public void doSomething() &#123;</div><div class="line">			//str = &quot;little cat&quot;;//错误，静态内部类反问外围非静态变量和方法</div><div class="line">			str_static = &quot;big cat&quot;;</div><div class="line">			System.out.println(&quot;I am a big cat.&quot;);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		LittleCat lCat = new Cat().new LittleCat();//依赖外围类</div><div class="line">		lCat.doSomething();</div><div class="line">		</div><div class="line">		BigCat bigCat = new BigCat();//不依赖外围类</div><div class="line">		bigCat.doSomething();</div><div class="line">	&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;内部类，顾名思义就是在一个类中的类。内部类可以访问所在类的数据，包括私有数据，而又可以对其他类隐藏，在快速实现回调函数时可以使用匿名内部类，比较便捷。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1、以下为一个简单的内部类例子，内部类可以定义为私有以对其他类隐藏起来；可以用内部类来达到实现多继承的效果。需要注意的是，通过成员函数传入内部类的变量必须定义为final类型，以保证数据的一致性。
    
    </summary>
    
    
      <category term="Java基础" scheme="http://javazgs.com/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>无题</title>
    <link href="http://javazgs.com/2017/02/14/0214%E5%B9%BF%E5%B7%9E/"/>
    <id>http://javazgs.com/2017/02/14/0214广州/</id>
    <published>2017-02-13T16:00:00.000Z</published>
    <updated>2017-05-06T14:55:57.511Z</updated>
    
    <content type="html"><![CDATA[<h1 id="本命年"><a href="#本命年" class="headerlink" title="本命年"></a>本命年</h1><p>暂且不用去想太多破事，认真过好今年</p>
<p>E时光上的广州<br><img src="\assets\articleImg\fyetime.jpg" alt="方圆E时光上的广州"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;本命年&quot;&gt;&lt;a href=&quot;#本命年&quot; class=&quot;headerlink&quot; title=&quot;本命年&quot;&gt;&lt;/a&gt;本命年&lt;/h1&gt;&lt;p&gt;暂且不用去想太多破事，认真过好今年&lt;/p&gt;
&lt;p&gt;E时光上的广州&lt;br&gt;&lt;img src=&quot;\assets\articleImg\f
    
    </summary>
    
    
      <category term="其他" scheme="http://javazgs.com/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title>鸡年大吉</title>
    <link href="http://javazgs.com/2017/01/27/%E9%99%A4%E5%A4%95/"/>
    <id>http://javazgs.com/2017/01/27/除夕/</id>
    <published>2017-01-26T16:00:00.000Z</published>
    <updated>2017-05-06T14:56:30.940Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2017"><a href="#2017" class="headerlink" title="2017"></a>2017</h1><p>除夕<br>辞旧迎新<br>新年快乐<br><img src="\assets\articleImg\chuxi.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;2017&quot;&gt;&lt;a href=&quot;#2017&quot; class=&quot;headerlink&quot; title=&quot;2017&quot;&gt;&lt;/a&gt;2017&lt;/h1&gt;&lt;p&gt;除夕&lt;br&gt;辞旧迎新&lt;br&gt;新年快乐&lt;br&gt;&lt;img src=&quot;\assets\articleImg\chuxi.png&quot; 
    
    </summary>
    
    
      <category term="其他" scheme="http://javazgs.com/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title>给博客换个主题</title>
    <link href="http://javazgs.com/2016/12/29/%E7%BB%99%E5%8D%9A%E5%AE%A2%E6%8D%A2%E4%B8%AA%E4%B8%BB%E9%A2%98/"/>
    <id>http://javazgs.com/2016/12/29/给博客换个主题/</id>
    <published>2016-12-28T16:00:00.000Z</published>
    <updated>2017-05-06T15:01:10.006Z</updated>
    
    <content type="html"><![CDATA[<p>搭好了博客之后，想把博客换了个hexo主题，挑来挑去最后选了Litten的Yilia主题。事实好多主题都做得很棒，现在不管是网站和移动端的应用，都很注重页面展示和交互体验，由此前端的技术也是日新月异，作为一个后端，看得真是眼花缭乱。</p>
<p>转眼间2016也即将过去了，这年毕业了，开始工作，真正地靠自己生活着，做了许多事情，也学会很多东西。整体上马马虎虎，但事实还有许多事情没有做好，找个时间再写个年终总结吧。</p>
<ul>
<li>加首歌试试</li>
</ul>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=848867&auto=0&height=66"></iframe>

<hr>
<p>markdown真是好用啊。顺便加上多说评论。</p>
<p><strong>以下测试</strong>    <a id="more"></a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">	 System.out.println(<span class="string">"欢迎来到啊深的博客。"</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>故人西辞黄鹤楼，烟花三月下扬州。孤帆远影碧空尽，惟见长江天际流。</p>
</blockquote>
<p>16/12/29</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;搭好了博客之后，想把博客换了个hexo主题，挑来挑去最后选了Litten的Yilia主题。事实好多主题都做得很棒，现在不管是网站和移动端的应用，都很注重页面展示和交互体验，由此前端的技术也是日新月异，作为一个后端，看得真是眼花缭乱。&lt;/p&gt;
&lt;p&gt;转眼间2016也即将过去了，这年毕业了，开始工作，真正地靠自己生活着，做了许多事情，也学会很多东西。整体上马马虎虎，但事实还有许多事情没有做好，找个时间再写个年终总结吧。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;加首歌试试&lt;/li&gt;
&lt;/ul&gt;
&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=330 height=86 src=&quot;//music.163.com/outchain/player?type=2&amp;id=848867&amp;auto=0&amp;height=66&quot;&gt;&lt;/iframe&gt;

&lt;hr&gt;
&lt;p&gt;markdown真是好用啊。顺便加上多说评论。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;以下测试&lt;/strong&gt;
    
    </summary>
    
    
      <category term="博客" scheme="http://javazgs.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>欢迎来到我的博客</title>
    <link href="http://javazgs.com/2016/12/20/hello-world/"/>
    <id>http://javazgs.com/2016/12/20/hello-world/</id>
    <published>2016-12-19T16:00:00.000Z</published>
    <updated>2017-05-06T14:56:18.781Z</updated>
    
    <content type="html"><![CDATA[<p>之前鼓捣服务器的时候买了个域名耍耍，空间到期之后域名一直放着，不久前才想起github上能搭个博客能用自定义域名，而且刚好又不需要备案，就鼓捣了这个博客。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前鼓捣服务器的时候买了个域名耍耍，空间到期之后域名一直放着，不久前才想起github上能搭个博客能用自定义域名，而且刚好又不需要备案，就鼓捣了这个博客。&lt;/p&gt;

    
    </summary>
    
    
      <category term="其他" scheme="http://javazgs.com/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title>淘淘商城的实践(6)——单点登录、集群及总结</title>
    <link href="http://javazgs.com/2016/11/29/%E6%B7%98%E6%B7%98%E5%95%86%E5%9F%8E%E7%9A%84%E5%AE%9E%E8%B7%B5(6)%E2%80%94%E2%80%94%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%E3%80%81%E9%9B%86%E7%BE%A4%E5%8F%8A%E6%80%BB%E7%BB%93/"/>
    <id>http://javazgs.com/2016/11/29/淘淘商城的实践(6)——单点登录、集群及总结/</id>
    <published>2016-11-28T16:00:00.000Z</published>
    <updated>2017-05-06T15:03:14.659Z</updated>
    
    <content type="html"><![CDATA[<p>最后一篇，简单记录下剩下主要的内容和写个总结。整个项目基于各类技术的入门使用，展现开发中对于不同业务需要用到的技术和技术的整合，实际意义虽不大，但至少对当下流行的技术的初步了解还是有用的。</p>
<p>一、单点登录</p>
<p>SSO(Single Sign On)单点登录是在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统。它包括可以将这次主要的登录映射到其他应用中用于同一个用户的登录的机制。它是目前比较流行的企业业务整合的解决方案之一。</p>
<p>1、tomcat的session复制方式<br>tomcat实现单点登录是采用全局session复制方式，集群内每个tomcat的session完全同步。<br><a id="more"></a><br>2、redis<br>验证登录之后将session存放在redis服务器中，token作为键值，设置过期时间(比如半个小时)，客户端存放token，每当访问页面时先验证token是否过期。若token不存在或者过期则跳转到登录页面，若存在且有效则通过。<br>创建taotao-sso工程，配置跟之前普通war工程一样。所有工程的登录都跳转到本工程进行登录，并获取验证token凭证。</p>
<p>二、集群及其他<br>1、订单和购物车这些纯业务的东西没什么好讲的，看看就好；<br>2、集群功能方面，redis和solr还有tomcat等等大部分内容都是配置文件配置，模拟集群环境需要多个虚拟机，电脑跑不起来的也看看就好；<br>3、域名规划、项目部署和nginx的配置使用涉及内容琐碎繁多，在实际开发中整理学习比较实际。</p>
<p>三、总结<br>实际中一个项目从确定需求到选择框架，再到实际开发，解决各类各样的技术问题，最后项目上线，部署工程和服务器的配置等等，涉及许许多多的东西，不是一个培训班小项目就能看到多少东西。最后的单点登录和集群等功能扩展开来写的东西太多，干脆一笔带过，等学到时再做记录。到此，商城就酱紫。</p>
<p><a href="http://download.csdn.net/detail/u012809062/9759182" target="_blank" rel="external">最后整理的工程文件下载(仅参考)</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最后一篇，简单记录下剩下主要的内容和写个总结。整个项目基于各类技术的入门使用，展现开发中对于不同业务需要用到的技术和技术的整合，实际意义虽不大，但至少对当下流行的技术的初步了解还是有用的。&lt;/p&gt;
&lt;p&gt;一、单点登录&lt;/p&gt;
&lt;p&gt;SSO(Single Sign On)单点登录是在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统。它包括可以将这次主要的登录映射到其他应用中用于同一个用户的登录的机制。它是目前比较流行的企业业务整合的解决方案之一。&lt;/p&gt;
&lt;p&gt;1、tomcat的session复制方式&lt;br&gt;tomcat实现单点登录是采用全局session复制方式，集群内每个tomcat的session完全同步。&lt;br&gt;
    
    </summary>
    
    
      <category term="商城技术应用" scheme="http://javazgs.com/tags/%E5%95%86%E5%9F%8E%E6%8A%80%E6%9C%AF%E5%BA%94%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>淘淘商城的实践(5)——Solr全文检索</title>
    <link href="http://javazgs.com/2016/11/28/solr%E5%85%A8%E6%96%87%E6%A3%80%E7%B4%A2/"/>
    <id>http://javazgs.com/2016/11/28/solr全文检索/</id>
    <published>2016-11-27T16:00:00.000Z</published>
    <updated>2017-05-06T15:04:49.783Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p> 时间又过去了好久，最近在鼓捣微信开发停不来下…..在上一篇博文记录了使用redis为商城系统添加缓存服务，以提高网站的访问速度和性能。另外，我们很容易注意到搜索服务在商城网站中是必不可少的，事实上，在内容繁多的一般网站业也会有搜索功能，而这里很多人就想到Lucene或Solr。</p>
</blockquote>
<h5 id="一、Lucene和Solr"><a href="#一、Lucene和Solr" class="headerlink" title="一、Lucene和Solr"></a>一、Lucene和Solr</h5><p>一说到全文检索总会提到Lucene和Solr，但这两者有什么区别，<a href="http://lucene.apache.org/" target="_blank">官网</a>上已经解释了很清楚：</p>
<blockquote>
<ul>
<li>Lucene Core, our flagship sub-project, provides Java-based indexing and search technology, as well as spellchecking, hit highlighting and advanced analysis/tokenization capabilities.</li>
<li>Solr<sup>TM</sup> is a high performance search server built using Lucene Core, with XML/HTTP and JSON/Python/Ruby APIs, hit highlighting, faceted search, caching, replication, and a web admin interface.</li>
</ul>
</blockquote>
<p>说白了Lucene是个Java Library，而Solr是一个基于Lucene的全文搜索服务器。如果使用Lucene需要自行实现一堆东西，但更灵活；Solr作为企业级的搜索引擎系统，使用方便。商城这里用solr练手，实际的商城网站如京东或淘宝，当然，肯定是其他高大上的东西了。<a id="more"></a></p>
<h5 id="二、安装Solr"><a href="#二、安装Solr" class="headerlink" title="二、安装Solr"></a>二、安装Solr</h5><ol>
<li><p>先到Solr官网<a href="http://lucene.apache.org/solr/" target="_blank">下载</a>,Solr的版本基本是和Lucene一起更新的，不就前看到的时候5.5.0版，现在都到6.3.0版了。<br>商城教程使用的tomcat和solr版本都比较老，这里直接用tomcat8和solr6.3.0。在高版本solr中原商城教程有些方法已经过时，不推荐使用，这里会重新实现一遍。</p>
</li>
<li><p>解压solr压缩包，可以看到几个文件夹，有常规的docs文档、licenses版本信息和example例子。bin目录下是命令操作区，dos下在本目录执行 <strong>solr start</strong> 快速启动solr，在浏览器输入 localhost:8983 可看到solr的基本操作页面，这里我们不直接启动，而是将solr发布到tomcat。contrib文件包含了一些扩展工具包，dist是solr编译之后的目标文件夹，包含各类jar包，server文件夹即应用文件夹。</p>
</li>
<li><p>将solr-6.3.0\server\solr-webapp下的webapp文件复制到tomcat的webapps下并重命名为solr，即当成一个发布的工程。</p>
</li>
<li><p>将solr-6.3.0\server\lib\ext下的文件复制到刚重命名的solr工程中 WEB-INF\lib 目录下，在WEB-INF创建classes文件夹，将solr-6.3.0\server\resources下的log4j.properties复制到classes文件夹中，这些都是一些日志相关的东西。</p>
</li>
<li><p>接着需要创建一个solr home，随意在某个目录下创建一个文件夹并命名为solr_home，例如D盘下D:\solr_home，然后将solr-6.3.0\server\solr文件夹复制过来。编辑solr工程web.xml文件，指定solr home的路径为D:\solr_home。索引库默认存放在这个文件夹，并包含刚复制过来分配置文件。</p>
</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">env-entry</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">env-entry-name</span>&gt;</span>solr/home<span class="tag">&lt;/<span class="name">env-entry-name</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">env-entry-value</span>&gt;</span>D:/solr_home/solr<span class="tag">&lt;/<span class="name">env-entry-value</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">env-entry-type</span>&gt;</span>java.lang.String<span class="tag">&lt;/<span class="name">env-entry-type</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">env-entry</span>&gt;</span></div></pre></td></tr></table></figure>
<ol>
<li>尝试访问<a href="http://localhost:8080/solr/index.html" target="_blank">http://localhost:8080/solr/index.html</a>报错403，资源拒绝访问，回到solr工程的web.xml文件，可以看到有这么一段配置</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- Get rid of error message --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">security-constraint</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">web-resource-collection</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">web-resource-name</span>&gt;</span>Disable TRACE<span class="tag">&lt;/<span class="name">web-resource-name</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">http-method</span>&gt;</span>TRACE<span class="tag">&lt;/<span class="name">http-method</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">web-resource-collection</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">auth-constraint</span>/&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">security-constraint</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">security-constraint</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">web-resource-collection</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">web-resource-name</span>&gt;</span>Enable everything but TRACE<span class="tag">&lt;/<span class="name">web-resource-name</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">http-method-omission</span>&gt;</span>TRACE<span class="tag">&lt;/<span class="name">http-method-omission</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">web-resource-collection</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">security-constraint</span>&gt;</span></div></pre></td></tr></table></figure>
<p>注释掉本段配置，开放访问权限就能正常访问。</p>
<h5 id="三、创建core"><a href="#三、创建core" class="headerlink" title="三、创建core"></a>三、创建core</h5><ol>
<li><p>将solr-6.3.0/dist中的solr-dataimporthandler、solr-dataimporthandler-extras的jar包复制到tomcat\webapps\solr\WEB-INF\lib目录下；</p>
</li>
<li><p>在D:\solr_home\solr下创建taotao_core文件夹，并在taotao_core下创建data和conf文件夹。将solr-6.3.0\example\example-DIH\solr\solr\conf所有文件和文件夹复制到D:\solr_home\solr\taotao_core\conf目录下；</p>
</li>
<li><p>访问solr工程，创建core，instanceDir和name填core文件夹的名字，即taotao_core。</p>
</li>
</ol>
<h5 id="四、配置IK中文分词器"><a href="#四、配置IK中文分词器" class="headerlink" title="四、配置IK中文分词器"></a>四、配置IK中文分词器</h5><ol>
<li><p>下载跟solr对应版本的IK分词器<a href="http://download.csdn.net/detail/u012809062/9730367" target="_blank" rel="external">IK-analyze-solr6.3</a>，解压后将jar包复制到solr工程WEB-INF\lib目录下，将IKAnalyzer.cfg.xml配置文件和mydict.dic、stopword.dic两个词典复制到到solr工程WEB-INF\classes目录下。</p>
</li>
<li><p>配置业务字段：修改D:\solr_home\solr\taotao_core\conf下的managed-schema文件<br>在底部<strong>&lt; /schema&gt;</strong>线加上</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">fieldType</span> <span class="attr">name</span>=<span class="string">"text_ik"</span> <span class="attr">class</span>=<span class="string">"solr.TextField"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">analyzer</span> <span class="attr">class</span>=<span class="string">"org.wltea.analyzer.lucene.IKAnalyzer"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">fieldType</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">"item_title"</span> <span class="attr">type</span>=<span class="string">"text_ik"</span> <span class="attr">indexed</span>=<span class="string">"true"</span> <span class="attr">stored</span>=<span class="string">"true"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">"item_sell_point"</span> <span class="attr">type</span>=<span class="string">"text_ik"</span> <span class="attr">indexed</span>=<span class="string">"true"</span> <span class="attr">stored</span>=<span class="string">"true"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">"item_price"</span>  <span class="attr">type</span>=<span class="string">"long"</span> <span class="attr">indexed</span>=<span class="string">"true"</span> <span class="attr">stored</span>=<span class="string">"true"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">"item_image"</span> <span class="attr">type</span>=<span class="string">"string"</span> <span class="attr">indexed</span>=<span class="string">"false"</span> <span class="attr">stored</span>=<span class="string">"true"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">"item_category_name"</span> <span class="attr">type</span>=<span class="string">"string"</span> <span class="attr">indexed</span>=<span class="string">"true"</span> <span class="attr">stored</span>=<span class="string">"true"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">"item_desc"</span> <span class="attr">type</span>=<span class="string">"text_ik"</span> <span class="attr">indexed</span>=<span class="string">"true"</span> <span class="attr">stored</span>=<span class="string">"false"</span> /&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">"item_keywords"</span> <span class="attr">type</span>=<span class="string">"text_ik"</span> <span class="attr">indexed</span>=<span class="string">"true"</span> <span class="attr">stored</span>=<span class="string">"false"</span> <span class="attr">multiValued</span>=<span class="string">"true"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">copyField</span> <span class="attr">source</span>=<span class="string">"item_title"</span> <span class="attr">dest</span>=<span class="string">"item_keywords"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">copyField</span> <span class="attr">source</span>=<span class="string">"item_sell_point"</span> <span class="attr">dest</span>=<span class="string">"item_keywords"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">copyField</span> <span class="attr">source</span>=<span class="string">"item_category_name"</span> <span class="attr">dest</span>=<span class="string">"item_keywords"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">copyField</span> <span class="attr">source</span>=<span class="string">"item_desc"</span> <span class="attr">dest</span>=<span class="string">"item_keywords"</span>/&gt;</span></div></pre></td></tr></table></figure>
</li>
<li><p>重启服务器，选择taotao_core点击分词器 analysis，FieldType选择item_desc,贴上一段文本分析测试<br><img src="http://img.blog.csdn.net/20170111091018269?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjgwOTA2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
</li>
</ol>
<h5 id="五、在taotao-search整合并使用solr"><a href="#五、在taotao-search整合并使用solr" class="headerlink" title="五、在taotao-search整合并使用solr"></a>五、在taotao-search整合并使用solr</h5><ol>
<li>创建taotao-search工程，同样数据库、SpringMvc照着配置，没什么好说的，applicationContext-solr.xml需要修改一下，因为httpSolrServer在6.3版本已经过时了，换成HttpSolrClient连接solr服务。从原来的HttpSolrServer可以看到,类已经deprecated了，改为使用HttpSolrClient<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * <span class="doctag">@deprecated</span> Use &#123;<span class="doctag">@link</span> org.apache.solr.client.solrj.impl.HttpSolrClient&#125;</div><div class="line"> */</div><div class="line"><span class="meta">@Deprecated</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpSolrServer</span> <span class="keyword">extends</span> <span class="title">HttpSolrClient</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HttpSolrServer</span><span class="params">(String baseURL)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>(baseURL);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">HttpSolrServer</span><span class="params">(String baseURL, HttpClient client)</span> </span>&#123;</div><div class="line">	<span class="keyword">super</span>(baseURL, client);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">HttpSolrServer</span><span class="params">(String baseURL, HttpClient client, ResponseParser parser)</span> </span>&#123;</div><div class="line">	<span class="keyword">super</span>(baseURL, client, parser);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>再看下HttpSolrClient类中一个地方，baseURL参数依旧，注释给了个例子，如果是标准的solr玩意，照着这个规则配，当我们的solr是发布到tomcat的，一会配的url不行就改下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">   * <span class="doctag">@param</span> baseURL</div><div class="line">   *          The URL of the Solr server. For example, "</div><div class="line">   *          &lt;code&gt;http://localhost:8983/solr/&lt;/code&gt;" if you are using the</div><div class="line">   *          standard distribution Solr webapp on your local machine.</div><div class="line">   */</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">HttpSolrClient</span><span class="params">(String baseURL)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>(baseURL, <span class="keyword">null</span>, <span class="keyword">new</span> BinaryResponseParser());</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>applicationContext-solr.xml中bean的配置<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 配置SolrServer对象 --&gt;</span></div><div class="line">	<span class="comment">&lt;!-- 单机版 --&gt;</span></div><div class="line">	<span class="comment">&lt;!-- &lt;bean id="HttpSolrClient" class="org.apache.solr.client.solrj.impl.HttpSolrServer"&gt; --&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"HttpSolrClient"</span> <span class="attr">class</span>=<span class="string">"org.apache.solr.client.solrj.impl.HttpSolrClient"</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"baseURL"</span> <span class="attr">value</span>=<span class="string">"$&#123;SOLR.SERVER.URL&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line">	<span class="comment">&lt;!-- 集群版 --&gt;</span></div><div class="line">	<span class="comment">&lt;!-- &lt;bean id="cloudSolrServer" class="org.apache.solr.client.solrj.impl.CloudSolrServer"&gt;</span></div><div class="line">		&lt;constructor-arg name="zkHost" value="192.168.25.154:2181,192.168.25.154:2182,192.168.25.154:2183"&gt;&lt;/constructor-arg&gt;</div><div class="line">		&lt;property name="defaultCollection" value="collection2"&gt;&lt;/property&gt;</div><div class="line">	&lt;/bean&gt; --&gt;</div></pre></td></tr></table></figure></p>
<p>其中SOLR.SERVER.URL变量的配置在resource.properties中配置,指向solr下的core就是了，正常连接<a href="http://localhost:8080/solr/index.html#/taotao_core" target="_blank" rel="external">http://localhost:8080/solr/index.html#/taotao_core</a> 的<strong>index.html#</strong>去掉，如果在tomcat的server xml配了根路径，没有index.html，中间的#/同样需要去掉<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SOLR.SERVER.URL=http://localhost:8080/solr/taotao_core</div></pre></td></tr></table></figure></p>
<p>ItemServiceImpl改为注入HttpSolrClient<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//private SolrServer solrServer;//过时方法，废弃不用</span></div><div class="line"><span class="meta">@Autowired</span></div><div class="line"><span class="keyword">private</span> HttpSolrClient solrServer;<span class="comment">//使用HttpSolrClient，实例化名称solrServer懒得改，注意</span></div></pre></td></tr></table></figure></p>
<p>SearchDaoImpl搜索服务同理换下HttpSolrClient<br>访问<a href="http://localhost:8083/search/manager/importall" target="_blank" rel="external">http://localhost:8083/search/manager/importall</a> 导入数据，成功状态200，数据多可能比较慢<br><img src="http://img.blog.csdn.net/20170111091433612?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjgwOTA2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>query一下看看导进来那些东东，可以看到查到商品了<br><img src="http://img.blog.csdn.net/20170111091519159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjgwOTA2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>搜下“移动电源试试” <a href="http://localhost:8083/search/query?q=移动电源&amp;page=3&amp;rows=15" target="_blank" rel="external">http://localhost:8083/search/query?q=移动电源&amp;page=3&amp;rows=15</a><br><img src="http://img.blog.csdn.net/20170111091549666?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjgwOTA2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h5 id="六、发布搜索服务到taotao-portal"><a href="#六、发布搜索服务到taotao-portal" class="headerlink" title="六、发布搜索服务到taotao-portal"></a>六、发布搜索服务到taotao-portal</h5><ol>
<li><p>在taotao-portal资源文件resource.properties配置搜索服务连接</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SEARCH_BASE_URL=http://localhost:8083/search/query</div></pre></td></tr></table></figure>
</li>
<li><p>业务照搬，或根据自己的需要修改。感觉事实上非要建个search工程实在是…封装个类足以。测试搜索如下<br><img src="http://img.blog.csdn.net/20170111093524121?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjgwOTA2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt; 时间又过去了好久，最近在鼓捣微信开发停不来下…..在上一篇博文记录了使用redis为商城系统添加缓存服务，以提高网站的访问速度和性能。另外，我们很容易注意到搜索服务在商城网站中是必不可少的，事实上，在内容繁多的一般网站业也会有搜索功能，而这里很多人就想到Lucene或Solr。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;一、Lucene和Solr&quot;&gt;&lt;a href=&quot;#一、Lucene和Solr&quot; class=&quot;headerlink&quot; title=&quot;一、Lucene和Solr&quot;&gt;&lt;/a&gt;一、Lucene和Solr&lt;/h5&gt;&lt;p&gt;一说到全文检索总会提到Lucene和Solr，但这两者有什么区别，&lt;a href=&quot;http://lucene.apache.org/&quot; target=&quot;_blank&quot;&gt;官网&lt;/a&gt;上已经解释了很清楚：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Lucene Core, our flagship sub-project, provides Java-based indexing and search technology, as well as spellchecking, hit highlighting and advanced analysis/tokenization capabilities.&lt;/li&gt;
&lt;li&gt;Solr&lt;sup&gt;TM&lt;/sup&gt; is a high performance search server built using Lucene Core, with XML/HTTP and JSON/Python/Ruby APIs, hit highlighting, faceted search, caching, replication, and a web admin interface.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;说白了Lucene是个Java Library，而Solr是一个基于Lucene的全文搜索服务器。如果使用Lucene需要自行实现一堆东西，但更灵活；Solr作为企业级的搜索引擎系统，使用方便。商城这里用solr练手，实际的商城网站如京东或淘宝，当然，肯定是其他高大上的东西了。
    
    </summary>
    
    
      <category term="商城技术应用" scheme="http://javazgs.com/tags/%E5%95%86%E5%9F%8E%E6%8A%80%E6%9C%AF%E5%BA%94%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>淘淘商城的实践(4)——redis的使用</title>
    <link href="http://javazgs.com/2016/10/21/%E6%B7%98%E6%B7%98%E5%95%86%E5%9F%8E%E7%9A%84%E5%AE%9E%E8%B7%B5(4)%E2%80%94%E2%80%94redis%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://javazgs.com/2016/10/21/淘淘商城的实践(4)——redis的使用/</id>
    <published>2016-10-20T16:00:00.000Z</published>
    <updated>2017-05-06T14:59:12.926Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>一忙起来就不动博客了，这样不好，接着上个月的商城小项目。上次商城系统从后台发布商品到前台工程的展示都已经实现了，但实际上线系统由于用户数量增多，为了应付网站的大访问量，降低数据库及整个系统的压力，一般都会选择缓存功能。</p>
</blockquote>
<h4 id="一、缓存工具的选择——redis"><a href="#一、缓存工具的选择——redis" class="headerlink" title="一、缓存工具的选择——redis"></a>一、缓存工具的选择——redis</h4><blockquote>
<p>Redis是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。<br><a id="more"></a></p>
<h5 id="1、安装启动"><a href="#1、安装启动" class="headerlink" title="1、安装启动"></a>1、安装启动</h5><p>先到<a href="http://redis.io/download" target="_blank">官网</a>下载需要的对应版本的redis。redis是用C语言写的，下载有编译版和直接安装的。<br>我这里直接用win版，解压，cd到根目录，执行redis-server.exe就可以启动redis了，默认端口6379:<br><img src="http://img.blog.csdn.net/20161125005932896" width="98%"><br>再新开dos，cd到redis根目录，redis-cli打开客户端，输入ping测试，响应返回pong，表示客户服务两端连接正常：<br><img src="http://img.blog.csdn.net/20161125010853204" alt="这里写图片描述"><br>然后就可以愉快进行操作了。之前公司有简单用到redis，试着放在win下，然后，貌似不怎么稳定，这东西还是放Linux下吧。</p>
<h5 id="2、可视化工具"><a href="#2、可视化工具" class="headerlink" title="2、可视化工具"></a>2、可视化工具</h5><p>在Windows下redis提供了一个可视化工具，可以链接和查看redis的各种信息。<a href="http://download.csdn.net/detail/u012809062/9499207" target="_blank">[RedisDesktopManager]</a></p>
</blockquote>
<h4 id="二、redis和spring的整合"><a href="#二、redis和spring的整合" class="headerlink" title="二、redis和spring的整合"></a>二、redis和spring的整合</h4><p>这里只看单机版的。根据系统的架构，所有与redis的数据交互都在taotao-rest工程完成，在本工程的操作直接注入调用redis相应的实现类即可，对于其他工程则需提供另外接口服务以供调用。</p>
<h5 id="1、xml的配置"><a href="#1、xml的配置" class="headerlink" title="1、xml的配置"></a>1、xml的配置</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">&lt;!-- 连接池配置 --&gt;</div><div class="line">	&lt;bean id=&quot;jedisPoolConfig&quot; class=&quot;redis.clients.jedis.JedisPoolConfig&quot;&gt;</div><div class="line">		&lt;!-- 最大连接数 --&gt;</div><div class="line">		&lt;property name=&quot;maxTotal&quot; value=&quot;30&quot; /&gt;</div><div class="line">		&lt;!-- 最大空闲连接数 --&gt;</div><div class="line">		&lt;property name=&quot;maxIdle&quot; value=&quot;10&quot; /&gt;</div><div class="line">		&lt;!-- 每次释放连接的最大数目 --&gt;</div><div class="line">		&lt;property name=&quot;numTestsPerEvictionRun&quot; value=&quot;1024&quot; /&gt;</div><div class="line">		&lt;!-- 释放连接的扫描间隔（毫秒） --&gt;</div><div class="line">		&lt;property name=&quot;timeBetweenEvictionRunsMillis&quot; value=&quot;30000&quot; /&gt;</div><div class="line">		&lt;!-- 连接最小空闲时间 --&gt;</div><div class="line">		&lt;property name=&quot;minEvictableIdleTimeMillis&quot; value=&quot;1800000&quot; /&gt;</div><div class="line">		&lt;!-- 连接空闲多久后释放, 当空闲时间&gt;该值 且 空闲连接&gt;最大空闲连接数 时直接释放 --&gt;</div><div class="line">		&lt;property name=&quot;softMinEvictableIdleTimeMillis&quot; value=&quot;10000&quot; /&gt;</div><div class="line">		&lt;!-- 获取连接时的最大等待毫秒数,小于零:阻塞不确定的时间,默认-1 --&gt;</div><div class="line">		&lt;property name=&quot;maxWaitMillis&quot; value=&quot;1500&quot; /&gt;</div><div class="line">		&lt;!-- 在获取连接的时候检查有效性, 默认false --&gt;</div><div class="line">		&lt;property name=&quot;testOnBorrow&quot; value=&quot;true&quot; /&gt;</div><div class="line">		&lt;!-- 在空闲时检查有效性, 默认false --&gt;</div><div class="line">		&lt;property name=&quot;testWhileIdle&quot; value=&quot;true&quot; /&gt;</div><div class="line">		&lt;!-- 连接耗尽时是否阻塞, false报异常,ture阻塞直到超时, 默认true --&gt;</div><div class="line">		&lt;property name=&quot;blockWhenExhausted&quot; value=&quot;false&quot; /&gt;</div><div class="line">	&lt;/bean&gt;</div><div class="line">	</div><div class="line">	&lt;!-- redis连接池 --&gt;</div><div class="line">	&lt;bean id=&quot;redisClient&quot; class=&quot;redis.clients.jedis.JedisPool&quot;&gt;</div><div class="line">		&lt;constructor-arg name=&quot;host&quot; value=&quot;127.0.0.1&quot;&gt;&lt;/constructor-arg&gt;</div><div class="line">		&lt;constructor-arg name=&quot;port&quot; value=&quot;6379&quot;&gt;&lt;/constructor-arg&gt;</div><div class="line">		&lt;constructor-arg name=&quot;poolConfig&quot; ref=&quot;jedisPoolConfig&quot;&gt;&lt;/constructor-arg&gt;</div><div class="line">	&lt;/bean&gt;</div><div class="line">	&lt;bean id=&quot;jedisClient&quot; class=&quot;com.taotao.rest.dao.impl.JedisClientSingle&quot;&gt;&lt;/bean&gt;</div></pre></td></tr></table></figure>
<h5 id="2、接口及实现"><a href="#2、接口及实现" class="headerlink" title="2、接口及实现"></a>2、接口及实现</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">package com.taotao.rest.dao;</div><div class="line">public interface JedisClient &#123;</div><div class="line">	String get(String key);</div><div class="line">	String set(String key, String value);</div><div class="line">	String hget(String hkey, String key);</div><div class="line">	long hset(String hkey, String key, String value);//hash</div><div class="line">	long incr(String key);//自增</div><div class="line">	long expire(String key, int second);//设置过期时间,单位秒</div><div class="line">	long ttl(String key);//生存时间</div><div class="line">	long del(String key);//删除</div><div class="line">	long hdel(String hkey, String key);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>JedisClientSingle再实现JedisClient 接口，完成redis的基本功能。<br>系统的缓存逻辑是从redis获取数据，若redis对应数据不存在，就从mysql数据库取数据存储到redis中，返回。下次即能直接从redis获得数据，若数据发生变更，在变更操作后删除对应键值在redis中的数据，重复上述方法。</p>
<h5 id="3、为其他工程提供服务接口"><a href="#3、为其他工程提供服务接口" class="headerlink" title="3、为其他工程提供服务接口"></a>3、为其他工程提供服务接口</h5><p>以taotao-manager-service内容管理更新redis为例。dao接口仍然是JedisClient ,基础操作功能一样。<br>实现类为一个Service。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">@Service</div><div class="line">public class RedisServiceImpl implements RedisService </div><div class="line">	@Autowired</div><div class="line">	private JedisClient jedisClient;</div><div class="line">	@Value(&quot;$&#123;INDEX_CONTENT_REDIS_KEY&#125;&quot;)</div><div class="line">	private String INDEX_CONTENT_REDIS_KEY;</div><div class="line">	@Override</div><div class="line">	public TaotaoResult syncContent(long contentCid) &#123;</div><div class="line">		try &#123;</div><div class="line">			jedisClient.hdel(INDEX_CONTENT_REDIS_KEY, contentCid + &quot;&quot;);</div><div class="line">		&#125; catch (Exception e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">			return TaotaoResult.build(500, ExceptionUtil.getStackTrace(e));</div><div class="line">		&#125;</div><div class="line">		return TaotaoResult.ok();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>controller发布service,需要时直接根据http调此controller即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">@Controller</div><div class="line">@RequestMapping(&quot;/cache/sync&quot;)</div><div class="line">public class RedisController &#123;</div><div class="line">	@Autowired</div><div class="line">	private RedisService redisService;</div><div class="line">	@RequestMapping(&quot;/content/&#123;contentCid&#125;&quot;)</div><div class="line">	@ResponseBody</div><div class="line">	public TaotaoResult contentCacheSync(@PathVariable Long contentCid) &#123;</div><div class="line">		TaotaoResult result = redisService.syncContent(contentCid);</div><div class="line">		return result;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="redis看似上手简单，但真正要应用起来就不是这么回事了，需要用到redis应该都死初具规模或有特殊要求的系统，要用好不容易。作为一个广泛使用的nosql数据库，值得去学习了解。"><a href="#redis看似上手简单，但真正要应用起来就不是这么回事了，需要用到redis应该都死初具规模或有特殊要求的系统，要用好不容易。作为一个广泛使用的nosql数据库，值得去学习了解。" class="headerlink" title="redis看似上手简单，但真正要应用起来就不是这么回事了，需要用到redis应该都死初具规模或有特殊要求的系统，要用好不容易。作为一个广泛使用的nosql数据库，值得去学习了解。"></a>redis看似上手简单，但真正要应用起来就不是这么回事了，需要用到redis应该都死初具规模或有特殊要求的系统，要用好不容易。作为一个广泛使用的nosql数据库，值得去学习了解。</h4><h4 id="商城剩下比较主要的内容包括全文检索、单点登录、nginx及系统架构分析，只是作为一个培训练习的项目也没太多可以看了。"><a href="#商城剩下比较主要的内容包括全文检索、单点登录、nginx及系统架构分析，只是作为一个培训练习的项目也没太多可以看了。" class="headerlink" title="商城剩下比较主要的内容包括全文检索、单点登录、nginx及系统架构分析，只是作为一个培训练习的项目也没太多可以看了。"></a>商城剩下比较主要的内容包括全文检索、单点登录、nginx及系统架构分析，只是作为一个培训练习的项目也没太多可以看了。</h4>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;一忙起来就不动博客了，这样不好，接着上个月的商城小项目。上次商城系统从后台发布商品到前台工程的展示都已经实现了，但实际上线系统由于用户数量增多，为了应付网站的大访问量，降低数据库及整个系统的压力，一般都会选择缓存功能。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;一、缓存工具的选择——redis&quot;&gt;&lt;a href=&quot;#一、缓存工具的选择——redis&quot; class=&quot;headerlink&quot; title=&quot;一、缓存工具的选择——redis&quot;&gt;&lt;/a&gt;一、缓存工具的选择——redis&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;Redis是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。&lt;br&gt;
    
    </summary>
    
    
      <category term="商城技术应用" scheme="http://javazgs.com/tags/%E5%95%86%E5%9F%8E%E6%8A%80%E6%9C%AF%E5%BA%94%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>淘淘商城的实践(3)——图片服务器部署和前台工程</title>
    <link href="http://javazgs.com/2016/10/02/%E6%B7%98%E6%B7%98%E5%95%86%E5%9F%8E%E7%9A%84%E5%AE%9E%E8%B7%B5(3)%E2%80%94%E2%80%94%E5%9B%BE%E7%89%87%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2%E5%92%8C%E5%89%8D%E5%8F%B0%E5%B7%A5%E7%A8%8B/"/>
    <id>http://javazgs.com/2016/10/02/淘淘商城的实践(3)——图片服务器部署和前台工程/</id>
    <published>2016-10-01T16:00:00.000Z</published>
    <updated>2017-05-06T14:54:05.023Z</updated>
    
    <content type="html"><![CDATA[<p>前言：之前后台系统的框架基本搭建完毕，后台剩下的就是一些增删改查业务操作。文本操作一般没什么问题，比较重要的是后台新增发布信息时涉及的图片的上传、存储和读取。教程里使用了ftp服务器来上传图片，使用nginx作为访问静态资源服务器。后台搞定之后接下来搭建前台系统。<br>一、图片服务器相关<br>商城系统中，新增商品经常需要编辑介绍和上传图片，后台系统的编辑页面使用了kindedit富文本编辑器，图片的上传需要我们自己配置。<br>1、图片上传服务器<br>使用ftp服务器作为图片上传的服务器，教程中的ftp服务器是部署在Linux系统下，跟着操作就行，没必要说，所以自己尝试在Windows下搭建ftp服务器。<br>Windows下搭建ftp比较简单，参考链接：<a href="https://www.baidu.com/link?url=OlyREktg1bWh0TNWcRIDi_sIrx7e-EDHEZ3ENmm_n9ZzA_W4ymN7S5ZKXqtTD3PrB93tnwkG98f5l0humIxG9uMQG_cQGDNPn3nxZ9fYETa&wd=&eqid=a272a68300069f720000000657f1d0f2" target="_blank">win10搭建ftp服务器</a><br><a id="more"></a><br>设置服务器指向的物理地址，我这里设置的是C盘的images目录，并为服务器指定用户访问，在浏览器输入 ftp:// + 设置的ip访问，输入用户名密码<br><img src="http://img.blog.csdn.net/20161003114039186" alt="这里写图片描述"></p>
<p>对应物理路径的文件<br><img src="http://img.blog.csdn.net/20161003114117952" alt="这里写图片描述"></p>
<p>2、nginx静态资源访问服务器<br>同样教程里nginx是搭建在Linux系统下，这里在尝试Windows下搭建一个。先到官网下载for Windows版本的Stable version版本，链接：<a href="http://nginx.org/en/download.html" target="_blank">nginx下载</a></p>
<p>下载完解压，编辑conf文件夹下的nginx.conf配置文件。默认pid日志是注释的，删掉前面”#”号就行。pid日志实在nginx运行时才生成的文件，在关闭nginx之后会被自动删掉，在dos下的一些操作命令依赖于此文件，比如reload、quit和stop等命令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pid        logs/nginx.pid;</div></pre></td></tr></table></figure>
<p> 我自己的nginx部分配置，参考<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">server &#123;  </div><div class="line">        listen       8089;#端口号  </div><div class="line">        server_name  localhost;#本机  </div><div class="line">        charset utf-8;  </div><div class="line">        #access_log  logs/host.access.log  main;  </div><div class="line">  </div><div class="line">		location ~ .*\.(gif|jpg|jpeg|png)$ &#123;  </div><div class="line">			expires 24h;  </div><div class="line">            root C:/images/;#指定图片存放路径  </div><div class="line">            access_log D:/nginx-1.10.1/logs/images.log;#图片 日志路径  </div><div class="line">            proxy_store on;  </div><div class="line">            proxy_store_access user:rw group:rw all:rw;  </div><div class="line">            proxy_temp_path         C:/images/;#图片路径  </div><div class="line">            proxy_redirect          off;  </div><div class="line">  </div><div class="line">            proxy_set_header        Host 127.0.0.1;  </div><div class="line">            proxy_set_header        X-Real-IP $remote_addr;  </div><div class="line">            proxy_set_header        X-Forwarded-For $proxy_add_x_forwarded_for;  </div><div class="line">            client_max_body_size    10m;  </div><div class="line">            client_body_buffer_size 1280k;  </div><div class="line">            proxy_connect_timeout   900;  </div><div class="line">            proxy_send_timeout      900;  </div><div class="line">            proxy_read_timeout      900;  </div><div class="line">            proxy_buffer_size       40k;  </div><div class="line">            proxy_buffers           40 320k;  </div><div class="line">            proxy_busy_buffers_size 640k;  </div><div class="line">            proxy_temp_file_write_size 640k;  </div><div class="line">            if ( !-e $request_filename)  </div><div class="line">            &#123;  </div><div class="line">                 proxy_pass  http://127.0.0.1:8089;#代理访问地址  </div><div class="line">            &#125;  </div><div class="line">		&#125;</div><div class="line">		location / &#123;  </div><div class="line">            root   html;  </div><div class="line">            index  index.html index.htm;  </div><div class="line">  </div><div class="line">        &#125;  </div><div class="line">        error_page  404              /404.html;  </div><div class="line">        # redirect server error pages to the static page /50x.html  </div><div class="line">        #  </div><div class="line">        error_page   500 502 503 504  /50x.html;  </div><div class="line">        location = /50x.html &#123;  </div><div class="line">            root   html;  </div><div class="line">        &#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>在dos下cd到nginx的目录,启动</p>
<p><img src="http://img.blog.csdn.net/20161003120027534" alt="这里写图片描述"></p>
<p>测试访问 C:/images/temp下图片<br><img src="http://img.blog.csdn.net/20161003120336601" alt="这里写图片描述"><br>其他一些nginx 命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">nginx -s stop 强制关闭 </div><div class="line">nginx -s quit 安全关闭 </div><div class="line">nginx -s reload 改变配置文件的时候，重启nginx工作进程，来时配置文件生效</div></pre></td></tr></table></figure></p>
<p>3、上传和访问的服务器搭建完毕之后，在taotao-manager-web的resource.properties文件配置路径，上传的图片保存在 C:/images/ftp下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#搭建ftp配置的地址</div><div class="line">FTP_ADDRESS=192.168.1.108</div><div class="line">FTP_PORT=21</div><div class="line">FTP_USERNAME=shenImg</div><div class="line">FTP_PASSWORD=123456</div><div class="line">FTP_BASE_PATH=/ftp</div><div class="line">IMAGE_BASE_URL=http://127.0.0.1:8089/ftp</div></pre></td></tr></table></figure></p>
<p>打开新增商品页面，测试结果<br><img src="http://img.blog.csdn.net/20161003135637580" alt="这里写图片描述"><br>在图片服务器根据规则生成的文件路径和图片文件<br><img src="http://img.blog.csdn.net/20161003135754701" alt="这里写图片描述"><br>后台系统其他业务纯增删改构造数据的东西没什么好看的，根据视频教程和文档跑一遍就行。<br>二、前台工程的搭建<br>教程里采用的是前台系统和服务层分开，以降低系统的耦合度。<br><img src="http://img.blog.csdn.net/20161003165655264" alt="这里写图片描述"><br>1、首先搭建服务层taotao-rest，在webservice框架方面，还是直接使用springMvc，此工程依赖于taotao-manager-pojo和taotao-manager-mapper，根据依赖关系，先将taotao-manager安装到本地仓库方便依赖。<br>同样配置tomcat插件，使用不同端口模拟，与manager工程区别开来<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&lt;build&gt;</div><div class="line">	&lt;!-- 配置插件 --&gt;</div><div class="line">	&lt;plugins&gt;</div><div class="line">		&lt;plugin&gt;</div><div class="line">			&lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt;</div><div class="line">			&lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt;</div><div class="line">			&lt;configuration&gt;</div><div class="line">				&lt;port&gt;8081&lt;/port&gt;</div><div class="line">				&lt;path&gt;/&lt;/path&gt;</div><div class="line">			&lt;/configuration&gt;</div><div class="line">		&lt;/plugin&gt;</div><div class="line">	&lt;/plugins&gt;</div><div class="line">&lt;/build&gt;</div></pre></td></tr></table></figure></p>
<p>2、搭建taotao-portal前台门户工程，同样配置tomcat插件，端口设为8082。前台工程的所有数据都是从服务层工程taotao-rest获取的，既有ajax动态请求，又使用httpclient从服务层获取数据。<br>(1)教程中taotao-portal和taotao-rest工程端口不同，进行ajax请求存在跨域问题，使用$.getJSONP()可解决问题。如下测试方法，获取的数据是商品的分类，请求url是<span>htt p://localhost:8081/rest/itemcat/list?callback=getData </span><br>回调方法为getData，参数data则为获取到的数据对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$(function()&#123;</div><div class="line">	$.getJSONP(&quot;http://localhost:8081/rest/itemcat/list?callback=getData&quot;);</div><div class="line">&#125;);</div><div class="line">function getData(data)&#123;</div><div class="line">	alert(data);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在浏览器输入地址测试<br><img src="http://img.blog.csdn.net/20161005002553824" alt="这里写图片描述"></p>
<p>(2)若是需要在进入页面就获取到数据渲染，而不是通过ajax动态请求，则需要在进入页面就获取到需要的数据。这时可在portal工程controller层通过httpclient请求服务层数据。<br>httpclient以其易用性和灵活性，使得客户端发送Http请求变得容易，而且也方便了开发人员测试接口（基于Http协议的），即提高了开发的效率，也方便提高代码的健壮性。<br>测试请求可使用谷歌浏览器商店的postman，比较好用。<br>测试请求大广告的数据示例<br><img src="http://img.blog.csdn.net/20161005004026876" alt="这里写图片描述"></p>
<p>这部分主要是分析系统，如何将大的系统工程进行分割简化，各个工程之间如何进行通讯，使用接口的方式进行数据调用，让各个工程互不干扰，可同时进行开发。主要知识：搭建图片服务器，$.getJSONP()和httpclient两种数据请求方式。</p>
<p>centos虚拟机下安装Nginx <a href="http://blog.csdn.net/u012809062/article/details/70307130" target="_blank" rel="external">http://blog.csdn.net/u012809062/article/details/70307130</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前言：之前后台系统的框架基本搭建完毕，后台剩下的就是一些增删改查业务操作。文本操作一般没什么问题，比较重要的是后台新增发布信息时涉及的图片的上传、存储和读取。教程里使用了ftp服务器来上传图片，使用nginx作为访问静态资源服务器。后台搞定之后接下来搭建前台系统。&lt;br&gt;一、图片服务器相关&lt;br&gt;商城系统中，新增商品经常需要编辑介绍和上传图片，后台系统的编辑页面使用了kindedit富文本编辑器，图片的上传需要我们自己配置。&lt;br&gt;1、图片上传服务器&lt;br&gt;使用ftp服务器作为图片上传的服务器，教程中的ftp服务器是部署在Linux系统下，跟着操作就行，没必要说，所以自己尝试在Windows下搭建ftp服务器。&lt;br&gt;Windows下搭建ftp比较简单，参考链接：&lt;a href=&quot;https://www.baidu.com/link?url=OlyREktg1bWh0TNWcRIDi_sIrx7e-EDHEZ3ENmm_n9ZzA_W4ymN7S5ZKXqtTD3PrB93tnwkG98f5l0humIxG9uMQG_cQGDNPn3nxZ9fYETa&amp;wd=&amp;eqid=a272a68300069f720000000657f1d0f2&quot; target=&quot;_blank&quot;&gt;win10搭建ftp服务器&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="商城技术应用" scheme="http://javazgs.com/tags/%E5%95%86%E5%9F%8E%E6%8A%80%E6%9C%AF%E5%BA%94%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>淘淘商城的实践(2)——后台系统搭建</title>
    <link href="http://javazgs.com/2016/09/29/%E6%B7%98%E6%B7%98%E5%95%86%E5%9F%8E%E7%9A%84%E5%AE%9E%E8%B7%B5(2)%E2%80%94%E2%80%94%E5%90%8E%E5%8F%B0%E7%B3%BB%E7%BB%9F%E6%90%AD%E5%BB%BA/"/>
    <id>http://javazgs.com/2016/09/29/淘淘商城的实践(2)——后台系统搭建/</id>
    <published>2016-09-28T16:00:00.000Z</published>
    <updated>2017-05-06T14:55:46.422Z</updated>
    
    <content type="html"><![CDATA[<p>前言：在这里记录在项目开发中的要点，对原网上的源码进一步优化和修改一些错误，对于开发过程中的一些冗长讲解不进行详细的分析，比如接下来的工程创建等等。<br>一、工程创建<br>1、系统工程使用Maven构建工具创建，工程之间的依赖关系如下<br><a id="more"></a><br><img src="http://img.blog.csdn.net/20160929110316423" alt="这里写图片描述"></p>
<p>跟着视频教程和源码资料创建工程，视频已经讲得非常详细这里就不多说。<br>如上图taotao-parent是一个pom类型父工程，用来管理依赖的jar包的版本，全局级别。<br>原网上的源码pom.xml中有些jar包配置存在错误，如果在构建完工程报jar包相关错误请检查配置。<br>例如原先commons-io的groupId就错了，应该是commons-io，在运行打包时就会报错。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">错误</div><div class="line">&lt;dependency&gt;</div><div class="line">	&lt;groupId&gt;org.apache.commons&lt;/groupId&gt;</div><div class="line">	&lt;artifactId&gt;commons-io&lt;/artifactId&gt;</div><div class="line">	&lt;version&gt;$&#123;commons-io.version&#125;&lt;/version&gt;</div><div class="line">&lt;/dependency&gt;</div><div class="line">正确</div><div class="line">&lt;dependency&gt;</div><div class="line">	&lt;groupId&gt;commons-io&lt;/groupId&gt;</div><div class="line">	&lt;artifactId&gt;commons-io&lt;/artifactId&gt;</div><div class="line">	&lt;version&gt;$&#123;commons-io.version&#125;&lt;/version&gt;</div><div class="line">&lt;/dependency&gt;</div></pre></td></tr></table></figure></p>
<p>各种jar包的maven配置可以去<a href="http://mvnrepository.com/" target="_blank">maven repository</a> 网站查找，搜素需要的jar包，选择对应的版本就有相应的maven配置。例：<br><img src="http://img.blog.csdn.net/20160929113145796" alt="这里写图片描述"><br>自己重新排查了一遍，有些jar包因为本地仓库已经有了别的版本号文件，所以改了版本号不必重新下载。Spring用了4.3.0-release版，mybatis用了3.3.0版。</p>
<p> 2、taotao-common工程是用来存放各种自封装或其他来源的工具类，jar工程，最终打包成jar文件，给其他工程调用，需要调用的工程要依赖此工程。<br> 3、 创建聚合工程taotao-manager，pom类型，然后在工程下创建pojo实体类、mapper接口、service层， controller层对应的module模块工程。所有模块均依赖taotao-common工程，其中taotao-manager-mapper还依赖taotao-manager-pojo；taotao-manager-service还依赖taotao-manager-mapper和taotao-manager-pojo；taotao-manager-controller则manager其他模块都依赖。<br> 在Maven Dependencies目录下可以看到工程或模块依赖的jar包和工程。<br> <img src="http://img.blog.csdn.net/20160929115928354" alt="这里写图片描述"><br>  &nbsp;&nbsp;&nbsp;<img src="http://img.blog.csdn.net/20160929115946776" alt="taotao-manager-web依赖的jar包和工程模块"></p>
<p>3、在generatorSqlmapCustom工程配置数据库链接，使用mybatis逆向工程自动生成pojo类和mapper文件（逆向工程在度盘资源，第二天：框架整合，框架系统搭建文件夹中的参考资料压缩包中，包括数据库的sql，直接导入到本地数据库就行），生成的pojo类和mapper接口和xml复制到对应的工程下面。<br><img src="http://img.blog.csdn.net/20160929120908733" alt="这里写图片描述"></p>
<p>4、Spring、Mybatis和SpringMvc整合<br>框架整合配置xml文件和web.xml都在taotao-manager-web模块下进行配置，照着资料就行，不啰嗦<br><img src="http://img.blog.csdn.net/20160929164720171" alt="这里写图片描述"><br>事实Spring的三个applicationContext没必要分开，直接一个就行，当然，分开找起来比较容易，目的明确。</p>
<p>5、运行及简单测试工程。<br>(1)安装tomcat插件和依赖工程到maven仓库<br>    工程运行采用的是maven的tomcat插件，需要在taotao-parent工程的pom.xml进行配置，顺便指定jdk版本等其他配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">&lt;build&gt;</div><div class="line">	&lt;finalName&gt;$&#123;project.artifactId&#125;&lt;/finalName&gt;</div><div class="line">	&lt;plugins&gt;</div><div class="line">		&lt;!-- 资源文件拷贝插件 --&gt;</div><div class="line">		&lt;plugin&gt;</div><div class="line">			&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</div><div class="line">			&lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt;</div><div class="line">			&lt;version&gt;2.7&lt;/version&gt;</div><div class="line">			&lt;configuration&gt;</div><div class="line">				&lt;encoding&gt;UTF-8&lt;/encoding&gt;</div><div class="line">			&lt;/configuration&gt;</div><div class="line">		&lt;/plugin&gt;</div><div class="line">		&lt;!-- java编译插件 --&gt;</div><div class="line">		&lt;plugin&gt;</div><div class="line">			&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</div><div class="line">			&lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;</div><div class="line">			&lt;version&gt;3.1&lt;/version&gt;</div><div class="line">			&lt;configuration&gt;</div><div class="line">				&lt;source&gt;1.8&lt;/source&gt;</div><div class="line">				&lt;target&gt;1.8&lt;/target&gt;</div><div class="line">				&lt;encoding&gt;UTF-8&lt;/encoding&gt;</div><div class="line">			&lt;/configuration&gt;</div><div class="line">		&lt;/plugin&gt;</div><div class="line">	&lt;/plugins&gt;</div><div class="line">	&lt;pluginManagement&gt;</div><div class="line">		&lt;plugins&gt;</div><div class="line">			&lt;!-- 配置Tomcat插件 --&gt;</div><div class="line">			&lt;plugin&gt;</div><div class="line">				&lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt;</div><div class="line">				&lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt;</div><div class="line">				&lt;version&gt;2.2&lt;/version&gt;</div><div class="line">			&lt;/plugin&gt;</div><div class="line">		&lt;/plugins&gt;</div><div class="line">	&lt;/pluginManagement&gt;</div><div class="line">&lt;/build&gt;</div></pre></td></tr></table></figure></p>
<p>由于项目工程的jar版本都依赖taotao-parent工程，所以需要先将taotao-parent工程安装到本地maven仓库中，同样的，taotao-common也要安装到maven仓库中。安装方法：右键工程run as—maven install，执行完毕会在当前系统用户文件夹的.m2文件夹下面看到安装的taotao-parent和taotao-common<br><img src="http://img.blog.csdn.net/20160929152056555" alt="这里写图片描述"></p>
<p>(2)打包和运行<br>我们最终发布出去放到服务器上的是war包，即taotao-manager-web模块的war包，直接对聚合工程taotao-manager打包，会自动对工程下的模块的jar或war模块进行打包，最终发布的是taotao-manager-web下的war包。操作:右键run as -maven build ，选第二个（第一次选第一个也行），在 Goals一栏输入clean package，点击run即可。<br><img src="http://img.blog.csdn.net/20160929152724033" alt="执行成功的信息"></p>
<p>这里需要注意的地方是mapper模块是打成jar包的，默认不包含mybatis的映射xml文件，需要在taotao-manager-mapper的pom.xml文件加上以下配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&lt;!-- 如果不添加此节点mybatis的mapper.xml文件都会被漏掉。 --&gt;</div><div class="line">	&lt;build&gt;</div><div class="line">		&lt;resources&gt;</div><div class="line">			&lt;resource&gt;</div><div class="line">				&lt;directory&gt;src/main/java&lt;/directory&gt;</div><div class="line">				&lt;includes&gt;</div><div class="line">					&lt;include&gt;**/*.properties&lt;/include&gt;</div><div class="line">					&lt;include&gt;**/*.xml&lt;/include&gt;</div><div class="line">				&lt;/includes&gt;</div><div class="line">				&lt;filtering&gt;false&lt;/filtering&gt;</div><div class="line">			&lt;/resource&gt;</div><div class="line">		&lt;/resources&gt;</div><div class="line">	&lt;/build&gt;</div></pre></td></tr></table></figure></p>
<p>运行或调试命令:右键taotao-manager工程run as 选第二项，在在 Goals一栏输入clean tomcat7:run，然后点击run即可。<br>调试时若提示找不到源文件，手动添加即可，可以在提示界面直接选择添加，也可以入下图在debug或run按钮的debug/run Configurations里面的Source选项卡进行配置，将需要的工程添加进去<br><img src="http://img.blog.csdn.net/20160929163345262" alt="这里写图片描述"></p>
<p><img src="http://img.blog.csdn.net/20160929163359823" alt="这里写图片描述"></p>
<p>测试结果,浏览器访问index.jsp<br><img src="http://img.blog.csdn.net/20160929163617250" alt="这里写图片描述"></p>
<p>访问测试controller请求，查询数据库商品<br><img src="http://img.blog.csdn.net/20160929163800184" alt="这里写图片描述"></p>
<p>重新整理的工程源码<a href="http://download.csdn.net/detail/u012809062/9643235" target="_blank">点击下载</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前言：在这里记录在项目开发中的要点，对原网上的源码进一步优化和修改一些错误，对于开发过程中的一些冗长讲解不进行详细的分析，比如接下来的工程创建等等。&lt;br&gt;一、工程创建&lt;br&gt;1、系统工程使用Maven构建工具创建，工程之间的依赖关系如下&lt;br&gt;
    
    </summary>
    
    
      <category term="商城技术应用" scheme="http://javazgs.com/tags/%E5%95%86%E5%9F%8E%E6%8A%80%E6%9C%AF%E5%BA%94%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>淘淘商城的实践(1)——说明篇</title>
    <link href="http://javazgs.com/2016/09/29/%E6%B7%98%E6%B7%98%E5%95%86%E5%9F%8E%E7%9A%84%E5%AE%9E%E8%B7%B5(1)%E2%80%94%E2%80%94%E8%AF%B4%E6%98%8E%E7%AF%87/"/>
    <id>http://javazgs.com/2016/09/29/淘淘商城的实践(1)——说明篇/</id>
    <published>2016-09-28T16:00:00.000Z</published>
    <updated>2017-05-06T15:02:30.196Z</updated>
    
    <content type="html"><![CDATA[<p>   之前在贴吧看到有吧友分享这个淘淘商城的项目，简单看了下介绍原来是培训机构的一个培训项目，虽然是培训的教学项目，但从工程的基础架构创建到各种框架的整合，以及结合了许多常用的web技术，没有具体特别深入单一技术的研究，但整个项目可谓面面俱到，各种功能都有。正因为如此，这个项目用来简单了解各种技术在开发中的应用与结合，积累基础知识确实很有用处。<br>        本人今年刚毕业，在校一直学的是嵌入式方面的知识，在参加工作时才刚转的JavaWeb开发，对java开发的了解还停留在基础阶段，知识积累远远不够。因此，这段时间打算看看这个商城项目，希望有所受益。<br>        商城项目包括后台的CMS系统，到前台页面的商品展示页面，串通从发布商品到下单支付购买的整个流程（支付貌似没有，后面尝试加上），基本的商城功能都有了。手动实现一遍整个项目估计需要不少时间，介绍先到这里，开始搭框架。</p>
<p>吧友给的资料分享链接：<a href="http://pan.baidu.com/s/1jI36OGe" target="_blank">度盘链接</a>提取密码：7wfj</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;   之前在贴吧看到有吧友分享这个淘淘商城的项目，简单看了下介绍原来是培训机构的一个培训项目，虽然是培训的教学项目，但从工程的基础架构创建到各种框架的整合，以及结合了许多常用的web技术，没有具体特别深入单一技术的研究，但整个项目可谓面面俱到，各种功能都有。正因为如此，这个
    
    </summary>
    
    
      <category term="商城技术应用" scheme="http://javazgs.com/tags/%E5%95%86%E5%9F%8E%E6%8A%80%E6%9C%AF%E5%BA%94%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>继承、多态、封装、抽象类与接口</title>
    <link href="http://javazgs.com/2016/09/05/%E7%BB%A7%E6%89%BF%E3%80%81%E5%A4%9A%E6%80%81%E3%80%81%E5%B0%81%E8%A3%85%E3%80%81%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3/"/>
    <id>http://javazgs.com/2016/09/05/继承、多态、封装、抽象类与接口/</id>
    <published>2016-09-04T16:00:00.000Z</published>
    <updated>2017-05-06T15:00:57.204Z</updated>
    
    <content type="html"><![CDATA[<p>作为一门面向对象语言，继承和多态是Java重要的特性。继承封装了一些公共特性，实现代码复用，减少代码冗余；多态可以动态调整对象的调用，降低对象之间的依存关系；接口是一种规范，可以通过接口实现多继承的功能。<br>一、继承<br>     利用继承，人们可以基于已存在的类构造一个新类。继承已存在的类就是复用（继承）这些类的方法和域。在此基础上，还可以添加一些新的方法和域，以满足新的需求。这是Java程序设计中的一项核心技术。[java核心技术]<br>     新建一个人物父类<a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public class Person &#123;</div><div class="line"></div><div class="line">	private int age;</div><div class="line">	private String name;</div><div class="line">	</div><div class="line">	public Person(int age, String name)&#123;</div><div class="line">		this.age = age;</div><div class="line">		this.name = name;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public void info()&#123;</div><div class="line">		System.out.println(age);</div><div class="line">		System.out.println(name);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Teacher子类继承Person父类，关键字extends表示继承，extends表明正在构造的新类派生于一个已存在的类。已存在的类被称为超类（superclass）、基类（base class）或父类（parent class）；新类被称为子类（subclass）、派生类（derived class）或孩子类（child class）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public class Teacher extends Person &#123;</div><div class="line"></div><div class="line">	//默认实现无参构造并可以不写，如果父类存在带参构造，则需要显式实现此构造</div><div class="line">	public Teacher(int age, String name) &#123;</div><div class="line">		super(22, &quot;shen&quot;);</div><div class="line">		// TODO Auto-generated constructor stub</div><div class="line">		super.info();</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	//重写父类方法</div><div class="line">	@Override</div><div class="line">	public void info()&#123;</div><div class="line">		System.out.println(&quot;rewrite...&quot;);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		Teacher t = new Teacher(20, &quot;tutu&quot;);</div><div class="line">		t.info();//子类拥有所有父类的成员变量，但private的成员变量没有访问权限</div><div class="line">		//t.age//private变量不可访问</div><div class="line">		</div><div class="line">	&#125;	</div><div class="line">&#125;</div><div class="line">输出结果：</div><div class="line">22</div><div class="line">shen</div><div class="line">rewrite...</div></pre></td></tr></table></figure>
<p>二、多态<br>实现多态有三个条件：要有继承、要有重写、父类引用指向子类对象。<br>父类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public class Animal &#123;</div><div class="line">	public void eat()&#123;</div><div class="line">		System.out.println(&quot;eat food&quot;);</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public void walk()&#123;</div><div class="line">		System.out.println(&quot;walk alone&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>子类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">public class Dog extends Animal &#123;</div><div class="line">	//重写父类方法</div><div class="line">	@Override</div><div class="line">	public void eat()&#123;</div><div class="line">		System.out.println(&quot;eat bone&quot;);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public void walk(String dog1)&#123;</div><div class="line">		dog1 = &quot;tom&quot;;</div><div class="line">		System.out.println(&quot;walk with &quot; + dog1);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		</div><div class="line">		Animal dog = new Dog();//向上转型，父类引用指向子类对象</div><div class="line">		dog.eat();</div><div class="line">		dog.walk();</div><div class="line">		//dog.walk(&quot;jane&quot;);//只能调用父类存在的方法</div><div class="line">		</div><div class="line">		Dog dd = (Dog)dog;//向下转型</div><div class="line">		dd.walk();</div><div class="line">		dd.walk(&quot;jane&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">输出结果：</div><div class="line">eat bone</div><div class="line">walk alone</div><div class="line">walk alone</div><div class="line">walk with tom</div></pre></td></tr></table></figure>
<p>多态可以使程序有良好的扩展，并可以对所有类的对象进行通用处理。<br>三、封装<br>在面向对象程式设计方法中，封装指一种将抽象性函式接口的实作细节部份包装、隐藏起来的方法。通常都使用getter和setter方法来实现，其他类要访问本类的私有成员变量都需要通过getter和setter方法。<br>例<br>实体类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public class Person &#123;</div><div class="line"></div><div class="line">	private int age;</div><div class="line">	private String name;</div><div class="line">	public int getAge() &#123;</div><div class="line">		return age;</div><div class="line">	&#125;</div><div class="line">	public void setAge(int age) &#123;</div><div class="line">		this.age = age;</div><div class="line">	&#125;</div><div class="line">	public String getName() &#123;</div><div class="line">		return name;</div><div class="line">	&#125;</div><div class="line">	public void setName(String name) &#123;</div><div class="line">		this.name = name;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>测试类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public class Test &#123;</div><div class="line">	</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		</div><div class="line">		Person t = new Person();</div><div class="line">		t.setAge(20);</div><div class="line">		t.setName(&quot;shen&quot;);</div><div class="line">		</div><div class="line">		System.out.println(&quot;Age:&quot; + t.getAge() + &quot; name:&quot; + t.getName());</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div><div class="line">输出：</div><div class="line">Age:20 name:shen</div></pre></td></tr></table></figure>
<p>四、抽象与接口<br>1、我们知道，在面向对象世界中，所有的对象都是通过类来描述的，但是并不是所有的类都是来描述对象的。如果一个类没有足够的信息来描述一个具体的对象，而需要其他具体的类来支撑它，那么这样的类我们称它为抽象类。<br>例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public abstract class Animal &#123;</div><div class="line">	</div><div class="line">	private String name;</div><div class="line">	private float weight;</div><div class="line">	</div><div class="line">	public Animal(String name, float weight)&#123;</div><div class="line">		this.name = name;</div><div class="line">		this.weight = weight;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	abstract void run();//抽象类不一定有抽象方法，但包含抽象方法的类一定要被声明为抽象类</div><div class="line">	</div><div class="line">	public void eat()&#123;</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>继承：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public class Cat extends Animal&#123;</div><div class="line">	</div><div class="line">	public Cat(String name, float weight) &#123;</div><div class="line">		super(name, weight);</div><div class="line">		// TODO Auto-generated constructor stub</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	//覆盖抽象方法</div><div class="line">	@Override</div><div class="line">	void run() &#123;</div><div class="line">		// TODO Auto-generated method stub</div><div class="line">		System.out.println(&quot;run fast&quot;);</div><div class="line">	&#125;</div><div class="line">		</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		</div><div class="line">		//Animal cat = new Animal(&quot;tom&quot;, 20f);//错误,抽象类不能实例化</div><div class="line">		Cat cat = new Cat(&quot;tom&quot;, 20f);</div><div class="line">		cat.run();</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>另注：<br>如果一个类包含抽象方法，那么该类必须是抽象类。<br>任何子类必须重写父类的抽象方法，或者声明自身为抽象类。<br>2、接口<br>接口是抽象方法的集合。接口并不是类，一个类通过继承接口的方式，从而来继承接口的抽象方法。<br>实现接口必须覆盖全部抽象方法，跟抽象类相似。但是java中不能通过extends实现多继承，可以通过实现多个接口来达到多继承的目的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public interface Person &#123;</div><div class="line">	public void eat();</div><div class="line">	public void say();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class Student implements Person &#123;</div><div class="line">	@Override</div><div class="line">	public void eat() &#123;</div><div class="line">		// TODO Auto-generated method stub</div><div class="line"></div><div class="line">	&#125;</div><div class="line">	@Override</div><div class="line">	public void say() &#123;</div><div class="line">		// TODO Auto-generated method stub</div><div class="line"></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注：<br>接口是隐式抽象的，当声明一个接口的时候，不必使用abstract关键字。<br>接口中每一个方法也是隐式抽象的，声明时同样不需要abstract关键子。<br>接口中的方法都是公有的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作为一门面向对象语言，继承和多态是Java重要的特性。继承封装了一些公共特性，实现代码复用，减少代码冗余；多态可以动态调整对象的调用，降低对象之间的依存关系；接口是一种规范，可以通过接口实现多继承的功能。&lt;br&gt;一、继承&lt;br&gt;     利用继承，人们可以基于已存在的类构造一个新类。继承已存在的类就是复用（继承）这些类的方法和域。在此基础上，还可以添加一些新的方法和域，以满足新的需求。这是Java程序设计中的一项核心技术。[java核心技术]&lt;br&gt;     新建一个人物父类
    
    </summary>
    
    
      <category term="Java基础" scheme="http://javazgs.com/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>集合</title>
    <link href="http://javazgs.com/2016/08/13/%E9%9B%86%E5%90%88/"/>
    <id>http://javazgs.com/2016/08/13/集合/</id>
    <published>2016-08-12T16:00:00.000Z</published>
    <updated>2017-05-06T15:00:13.594Z</updated>
    
    <content type="html"><![CDATA[<p><strong>一、概述</strong><br>    集合框架是Java一块很重要的内容，对常用的数据结构做了规范和实现。对象封装了数据，许多对象则构成了所谓集合。Java集合类库构成了集合类的框架。它为集合的实现者定义了大量的接口和抽象类，并且对其中的某些机制给予了描述。<br>    集合框架的接口和实现类：<br>    <img src="http://img.blog.csdn.net/20160818005915689" alt="集合框架的接口和实现类"><br>    <a id="more"></a><br><strong>二、Iterator接口</strong><br>Iterator接口与Collection系列、Map系列的集合不一样：Collection系列集合、Map系列集合主要用于盛装其他对象，而Iterator则主要用于遍历（即迭代访问）Collection集合中的元素，Iterator对象也被称为迭代器。[<a href="http://www.cnblogs.com/lixiaolun/p/4320771.html" target="_blank">引</a>]<br>Iterator接口定义了四个方法<br>–boolean hasNext()：如果被迭代的集合还元素没有被遍历，则返回true。<br>–Object next()：返回集合里下一个元素。<br>–void remove() ：删除集合里上一次next方法返回的元素<br>–void forEachRemaining(Consumer action)：这是Java 8为Iterator新增的默认方法，该方法可使用Lambda表达式来遍历集合元素。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * @author shen</div><div class="line"> * @desc Iterator接口</div><div class="line"> * @date 2016年8月23日</div><div class="line"> */</div><div class="line">public class IteratorTest &#123;</div><div class="line">	</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		</div><div class="line">		//Iterator是Collection父接口，可如此创建集合</div><div class="line">		Collection&lt;Object&gt; animals = new HashSet&lt;&gt;();</div><div class="line">		</div><div class="line">		//添加元素</div><div class="line">		animals.add(&quot;cat&quot;);</div><div class="line">		animals.add(&quot;dog&quot;);</div><div class="line">		animals.add(&quot;pig&quot;);</div><div class="line">		</div><div class="line">		//使用Lambda表达式遍历集合(java1.8新特性)</div><div class="line">		animals.forEach(obj -&gt; System.out.println(&quot;Lambda迭代输出：&quot; + obj));</div><div class="line">		</div><div class="line">		//iterator()方法获取迭代器</div><div class="line">		Iterator&lt;Object&gt; data = animals.iterator();</div><div class="line">		while(data.hasNext())&#123;</div><div class="line">			Object subData = data.next();</div><div class="line">			if(&quot;cat&quot;.equals(subData))&#123;</div><div class="line">				data.remove();//移除元素</div><div class="line">			&#125;</div><div class="line">			System.out.println(&quot;迭代器输出：&quot; + subData);</div><div class="line">        &#125;</div><div class="line">		System.out.println(animals);</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出：<br><img src="http://img.blog.csdn.net/20160823143351810" alt="这里写图片描述"></p>
<p><strong>三、Collection接口</strong><br>        Collection不提供接口的任何直接实现，一个Collection代表一组Object，但它提供更加具体的子接口如List和Set，而继承自它们的 ArrayList, Vector, HashTable, HashMap等实现类才可被实例化。<br>1、List接口<br>List是一个有序集合（ordered collection）。元素可以添加到容器中某个特定的位置。将对象放置在某个位置上可以采用两种方式：使用整数索引或使用列表迭代器。[引 java核心技术]<br>List接口实现类主要有：ArrayList、Vector、LinkedList。<br>(1)ArrayList<br>ArrayList是List接口的可变数组的实现，其操作基本是对数组的操作，ArrayList是线程不安全的。<br>ArrayList包装了许多的方法，包括元素的增加移除、插入移动、转换数组等等：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * @author shen</div><div class="line"> * @desc</div><div class="line"> * @date 2016年8月23日</div><div class="line"> */</div><div class="line">public class ListTest &#123;</div><div class="line">	</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line"></div><div class="line">		List&lt;String&gt; list = new ArrayList&lt;String&gt;();</div><div class="line">		list.add(&quot;1&quot;);//使用list时默认长度置为10</div><div class="line">		list.add(&quot;2&quot;);</div><div class="line">		list.add(&quot;3&quot;);</div><div class="line">		list.add(&quot;4&quot;);</div><div class="line">		list.add(&quot;5&quot;);</div><div class="line">		</div><div class="line">		System.out.println(&quot;list输出：&quot;+list);</div><div class="line">		list.remove(4);//移除元素</div><div class="line">		System.out.println(&quot;移除元素之后的list：&quot;+list);</div><div class="line">		Object[] arr = list.toArray();//转换为数组</div><div class="line">		System.out.println(&quot;数组元素输出：&quot;+arr[0]);</div><div class="line">		</div><div class="line">		List&lt;String&gt; c = new ArrayList&lt;&gt;(4);//预计有4个元素而创建</div><div class="line">		c.add(&quot;6&quot;);</div><div class="line">		c.add(&quot;7&quot;);</div><div class="line">		c.add(&quot;8&quot;);</div><div class="line">		c.add(&quot;9&quot;);</div><div class="line">		</div><div class="line">		c.add(&quot;10&quot;);//超过5个元素list会增加原来长度一半个元素,目前即长度为6</div><div class="line">		list.addAll(c);//增加一组数据,数据类型应相同</div><div class="line">		System.out.println(list);</div><div class="line">		</div><div class="line">		Iterator&lt;String&gt; data = list.iterator();//获取迭代器</div><div class="line">		System.out.println(&quot;迭代输出：&quot;);</div><div class="line">		data.forEachRemaining(action -&gt; System.out.print(action+&quot; &quot;));</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出：<br><img src="http://img.blog.csdn.net/20160823143916449" alt="这里写图片描述"><br>ArrayList的各种操作虽然很方便，但是ArrayList的插入和删除，会导致内部数据大量移位，而扩容则需要新建一个ArrayList将原来的数据复制过去,会影响性能。如果我们已经知道需要的元素个数，我们可以初始化时指定ArrayList的容量，这样可以有效的避免数组多次扩充，从而提高效率。<br>(2)Vector<br>Vector类提供了实现可增长数组的功能，随着更多元素加入其中，数组变的更大。在删除一些元素之后，数组变小,而不像ArrayList的扩容方式，基本用法与ArrayList相同。Vector是同步类，是线程安全的。<br>(3)LinkedList<br>LinkedList是list的链表实现，列表中的每个节点都包含了对前一个和后一个元素的引用，除了大部分与ArrayList相同的方法，LinkedList还有一些其特有的方法，并且LinkedList在添加和删除元素时具有比ArrayList更好的性能，但在get数据时更慢。LinkedList适用于没有大规模的随机读取，大量的增加/删除操作。[<a href="http://blog.csdn.net/renfufei/article/details/17077425" target="_blank" rel="external">引</a>]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public class LinkTest &#123;</div><div class="line">	</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		</div><div class="line">		LinkedList&lt;String&gt; link = new LinkedList&lt;&gt;();</div><div class="line">		link.add(&quot;a&quot;);</div><div class="line">		link.add(&quot;b&quot;);</div><div class="line">		link.add(&quot;c&quot;);</div><div class="line">		link.add(&quot;d&quot;);</div><div class="line">		link.add(&quot;e&quot;);</div><div class="line">		System.out.println(&quot;第一个元素：&quot;+link.getFirst()+&quot;  最后一个元素：&quot;+link.getLast());</div><div class="line">		</div><div class="line">		link.remove(1);</div><div class="line">		System.out.println(link);</div><div class="line">		</div><div class="line">		link.add(3, &quot;zhiding&quot;);</div><div class="line">		System.out.println(link);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出：<br><img src="http://img.blog.csdn.net/20160823164333523" alt="这里写图片描述"></p>
<p>2、Set接口<br>由于Set接口提供的数据结构是数学意义上集合概念的抽象，因此它需要支持对象的添加、删除，而不需提供随机访问。Set具有与Collection完全一样的接口，因此没有任何额外的功能。实际上Set就是Collection，只是行为不同。Set不包含重复的元素。<br>Set的实现类主要有：HashSet，TreeSet，LinkedHashSet<br>(1)HashSet<br>不保证set的迭代顺序，不保证该顺序永恒不变，因此HashSet也没有get方法。此类允许使用null元素，底层是使用HashMap实现的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public static void main(String[] args) &#123;</div><div class="line">		</div><div class="line">		HashSet&lt;String&gt; set = new HashSet&lt;&gt;();</div><div class="line">		set.add(&quot;adf&quot;);</div><div class="line">		set.add(&quot;bhf&quot;);</div><div class="line">		set.add(&quot;c32&quot;);</div><div class="line">		set.add(&quot;c32&quot;);//有重复元素，添加不了</div><div class="line">		set.add(null);//null也只允许只有一个</div><div class="line">		System.out.println(set);</div><div class="line">		</div><div class="line">		for(String str : set)&#123;</div><div class="line">			System.out.print(str +&quot; &quot;);</div><div class="line">		&#125;</div><div class="line">		System.out.println();</div><div class="line">		Iterator&lt;String&gt; iterator = set.iterator();</div><div class="line">		while(iterator.hasNext())&#123;</div><div class="line">			String data = iterator.next();</div><div class="line">			System.out.print(data +&quot; &quot;);</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">	&#125;</div><div class="line"></div><div class="line">输出：</div><div class="line">[null, bhf, adf, c32]</div><div class="line">null bhf adf c32 </div><div class="line">null bhf adf c32</div></pre></td></tr></table></figure>
<p>(2)TreeSet<br>TreeSet元素自然排序，底层是使用TreeMap实现的，自定义要显示Comparable接口。TreeSet可以给集合中的元素进行指定方式的排序，保证元素唯一性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * @author shen</div><div class="line"> * @desc 测试类，实现Comparable&lt;T&gt;接口</div><div class="line"> * @date 2016年8月24日</div><div class="line"> */</div><div class="line">public class User implements Comparable&lt;User&gt;&#123;</div><div class="line">	</div><div class="line">	private String name;</div><div class="line">	private int age;</div><div class="line">	</div><div class="line">	//构造</div><div class="line">	public User(String name,int age)&#123;</div><div class="line">		this.name = name;</div><div class="line">		this.age = age;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	//实现类</div><div class="line">	@Override</div><div class="line">	public int compareTo(User user) &#123;  </div><div class="line">        if(user == null)  </div><div class="line">            throw new NullPointerException();  </div><div class="line">        if(this.age &gt; user.age)  </div><div class="line">            return 1;  </div><div class="line">        if(this.age &lt; user.age)  </div><div class="line">            return -1;  </div><div class="line">        return 0;  </div><div class="line">    &#125;</div><div class="line"></div><div class="line">	//重写toString</div><div class="line">	@Override</div><div class="line">	public String toString() &#123;</div><div class="line">		return &quot;User [name=&quot; + name + &quot;, age=&quot; + age + &quot;]&quot;;</div><div class="line">	&#125;  </div><div class="line">&#125;</div><div class="line"></div><div class="line">//测试</div><div class="line">public static void main(String[] args) &#123;</div><div class="line">		</div><div class="line">		Set&lt;User&gt; set = new TreeSet&lt;User&gt;();</div><div class="line">		</div><div class="line">		User user1 = new User(&quot;Tom&quot;, 20);</div><div class="line">		User user2 = new User(&quot;Jack&quot;, 21);</div><div class="line">		User user3 = new User(&quot;Dave&quot;, 22);</div><div class="line">		User user4 = new User(&quot;Jane&quot;, 12);</div><div class="line">		</div><div class="line">		set.add(user1);</div><div class="line">		set.add(user1);//重复，添加不了</div><div class="line">		set.add(user2);</div><div class="line">		set.add(user3);</div><div class="line">		set.add(user4);</div><div class="line">		</div><div class="line">		System.out.println(&quot;按年龄大小输出：&quot;);</div><div class="line">		System.out.println(set);</div><div class="line">		</div><div class="line">	&#125;</div><div class="line"></div><div class="line">输出</div><div class="line">按年龄大小输出：</div><div class="line">[User [name=Jane, age=12], User [name=Tom, age=20], User [name=Jack, age=21], User [name=Dave, age=22]]</div></pre></td></tr></table></figure>
<p>(3)LinkedHashSet<br>LinkedHashSet集合同样是根据元素的hashCode值来决定元素的存储位置，但是它同时使用链表维护元素的次序。这样使得元素看起 来像是以插入顺序保存的，也就是说，当遍历该集合时候，LinkedHashSet将会以元素的添加顺序访问集合的元素。<br>LinkedHashSet在迭代访问Set中的全部元素时，性能比HashSet好，但是插入时性能稍微逊色于HashSet。[<a href="http://www.cnblogs.com/Terry-greener/archive/2011/12/02/2271707.html" target="_blank">引</a>]</p>
<p><strong>四、Map接口</strong><br>在Collection实现中保存的直接是一个个对象，二在Map实现中保存的是一对对象，以键值对key-value的方式关联着。Map的常用实现类有HashMap，HashTabel和TreeMap。<br>1、HashMap<br>HashMap是基于哈希表的Map接口的非同步实现，其中元素表现无序，特别是它不保证该顺序恒久不变。HashMap会利用对象的hashCode来快速找到key。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">public static void main(String[] args) &#123;</div><div class="line">		</div><div class="line">		//使用实现类创建，键值指定对象类型</div><div class="line">		HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;();</div><div class="line">		map.put(&quot;name&quot;, &quot;shen&quot;);</div><div class="line">		map.put(&quot;age&quot;, &quot;20&quot;);</div><div class="line">		map.put(&quot;age&quot;, &quot;19&quot;);//相同键多次存入数据覆盖</div><div class="line">		map.put(&quot;weight&quot;, &quot;100&quot;);</div><div class="line">		map.put(null, &quot;空&quot;);//允许空键值</div><div class="line">		map.put(null, null);</div><div class="line">		System.out.println(map);</div><div class="line">		</div><div class="line">		//对map集合的遍历，可取出具体的键和对应值</div><div class="line">		for(Entry&lt;String, String&gt; element:map.entrySet())&#123;</div><div class="line">			String key = element.getKey();</div><div class="line">			String value = element.getValue();</div><div class="line">			Class&lt;? extends Entry&gt; classData = element.getClass();</div><div class="line">			System.out.println(key + &quot;---- &quot; + value + &quot;---- &quot; + classData.getName());</div><div class="line">		&#125;</div><div class="line">				</div><div class="line">		//使用接口创建，不关心具体实现，只有在使用才具体实现</div><div class="line">		//键值的值一般设为Object，不关心什么类型的数据，当然，获取需要具体数据类型或对象需要转化</div><div class="line">		Map&lt;String, Object&gt; mapData = null;//new HashMap&lt;&gt;();</div><div class="line">		mapData = new HashMap&lt;&gt;();</div><div class="line">		mapData.put(&quot;name&quot;, &quot;Jack&quot;);</div><div class="line">		mapData.put(&quot;age&quot;, 21);</div><div class="line">		mapData.put(&quot;weight&quot;, 110.5);</div><div class="line">		System.out.println(mapData);</div><div class="line">		System.out.println(&quot;获取name值:&quot; + mapData.get(&quot;name&quot;));</div><div class="line">		Set&lt;String&gt; keys = mapData.keySet();</div><div class="line">		System.out.println(&quot;获取所有key:&quot; + keys);</div><div class="line">		Collection&lt;Object&gt; values = mapData.values();</div><div class="line">		System.out.println(&quot;获取所有value:&quot; + values);</div><div class="line">		</div><div class="line">	&#125;</div><div class="line"></div><div class="line">输出：</div><div class="line">&#123;null=null, name=shen, weight=100, age=19&#125;</div><div class="line">null---- null---- java.util.HashMap$Node</div><div class="line">name---- shen---- java.util.HashMap$Node</div><div class="line">weight---- 100---- java.util.HashMap$Node</div><div class="line">age---- 19---- java.util.HashMap$Node</div><div class="line">&#123;name=Jack, weight=110.5, age=21&#125;</div><div class="line">获取name值:Jack</div><div class="line">获取所有key:[name, weight, age]</div><div class="line">获取所有value:[Jack, 110.5, 21]</div></pre></td></tr></table></figure></p>
<p>2、HashTabel<br>HashTable在很大程度事实上和HashMap的实现差不多，主要区别是HashMap采用异步处理方式，性能更高，而HashTabel采用同步处理方式，性能较低。HashTabel属于线程安全类而HashMap属于线程不安全类。[<a href="http://blog.csdn.net/hanshileiai/article/details/6754808" target="_blank">参考</a>]</p>
<p>3、TreeMap<br>TreeMap是可排序的Map集合按照集合中的key进行排序，key不允许重复。TreeMap是红黑树基于Map接口的实现。<a href="http://blog.csdn.net/chenssy/article/details/26668941" target="_blank">关于TreeMap红黑树参考</a>,初次接触不容易理解，多查资料。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;一、概述&lt;/strong&gt;&lt;br&gt;    集合框架是Java一块很重要的内容，对常用的数据结构做了规范和实现。对象封装了数据，许多对象则构成了所谓集合。Java集合类库构成了集合类的框架。它为集合的实现者定义了大量的接口和抽象类，并且对其中的某些机制给予了描述。&lt;br&gt;    集合框架的接口和实现类：&lt;br&gt;    &lt;img src=&quot;http://img.blog.csdn.net/20160818005915689&quot; alt=&quot;集合框架的接口和实现类&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="Java基础" scheme="http://javazgs.com/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>类与对象</title>
    <link href="http://javazgs.com/2016/07/09/%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/"/>
    <id>http://javazgs.com/2016/07/09/类与对象/</id>
    <published>2016-07-08T16:00:00.000Z</published>
    <updated>2017-05-06T15:00:44.399Z</updated>
    
    <content type="html"><![CDATA[<p>一、Java的对象和类<br>Java作为一种面向对象语言，有类、对象、实例、方法、继承、重载、抽象、多态、封装的基本概念。<br>1、类<br>(1)类是Java的核心和本质，封装、继承、多态和抽象几大特性都离不开类，可以把类看成是对象的模板。<br>(2)类中的变量。包括局部变量、全局变量和类变量。<br>    局部变量：定义在方法中的变量，作用域为本方法中。<br>    成员变量：定义在类中方法外的变量，作用域为本类。<br>    类变量(静态变量)：类变量也声明在类中，方法体之外，但必须声明为static类型(static表示全局的、静态的)。<br>    <a id="more"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * @author shen</div><div class="line"> * @desc test</div><div class="line"> * @date 2016年7月10日</div><div class="line"> */</div><div class="line">public class Book &#123;</div><div class="line">	</div><div class="line">	static int num = 0;//类变量</div><div class="line">	static final String type = &quot;children&quot;;//用final变量只能被初始化一次，之后不能再赋值</div><div class="line">	</div><div class="line">	String str=&quot;this is a book&quot;;//实例变量</div><div class="line">	public void borrow()&#123;</div><div class="line">		int i = 0;//局部变量</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public static void rend()&#123;</div><div class="line">		//静态方法，无需创建对象就能使用</div><div class="line">		System.out.println(&quot;this is a static method.&quot;);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		rend();//直接调用</div><div class="line">		System.out.println(&quot;this is a main function.&quot;);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	static &#123;</div><div class="line">		//静态代码块，类加载时调用</div><div class="line">		System.out.println(&quot;this is a static code block.&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结果：<br><img src="http://img.blog.csdn.net/20160710185420433" alt="这里写图片描述"><br>(3)构造方法<br>        每个类都有构造方法，如果没有显式定义构造方法，编译器会默认为类创建一个不带参的构造方法(若子类继承有带参构造方法的父类，需要显式调用父类构造方法)。<br>        构造方法名必须与类名相同，一个类中可以有多个构造方法(参数不同)，创建对象时至少一个构造方法。<br>2、对象<br>    对象的创建：声明，声明类的类型和名称；实例化，使用new创建一个对象；初始化，创建对象时会调用构造方法初始化对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * @author shen</div><div class="line"> * @desc test</div><div class="line"> * @date 2016年7月10日</div><div class="line"> */</div><div class="line">public class User &#123;</div><div class="line">	</div><div class="line">	private String type = &quot;student&quot;;</div><div class="line">	private String name;//私有属性只能在本类获取到</div><div class="line">	private int age;</div><div class="line">	public int height;//公有属性其他类也能获取到</div><div class="line">	</div><div class="line">	public int getHeight() &#123;</div><div class="line">		return height;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void setHeight(int height) &#123;</div><div class="line">		this.height = height;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	//Javabean的规范，通过getter和setter对数据进行封装</div><div class="line">	public String getType() &#123;</div><div class="line">		return type;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void setType(String type) &#123;</div><div class="line">		this.type = type;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public String getName() &#123;</div><div class="line">		return name;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void setName(String name) &#123;</div><div class="line">		this.name = name;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public int getAge() &#123;</div><div class="line">		return age;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void setAge(int age) &#123;</div><div class="line">		this.age = age;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public User()&#123;</div><div class="line">		//无参构造方法</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public User(String num)&#123;</div><div class="line">		//带参构造</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public User(String name,int age)&#123;</div><div class="line">		//参数个数不同的构造</div><div class="line">		this.name = name;</div><div class="line">		this.age = age;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	//普通方法</div><div class="line">	public void borrow(String bookName)&#123;</div><div class="line">		//bookName为方法体中的局部变量</div><div class="line">		System.out.println(this.name + &quot; borrow a book :&quot; + bookName );</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		</div><div class="line">		User jack = new User();//默认的无参构造创建对象</div><div class="line">		jack.age = 20;//私有属性，只能在本类使用这种方式</div><div class="line">		jack.name = &quot;jack&quot;;</div><div class="line">		</div><div class="line">		//公有属性其他类也能获取到，暴露了数据细节。将属性定义为private并使用getter和setter方法隐藏数据的细节(Java的封装特性)</div><div class="line">		jack.height = 170;</div><div class="line">		jack.borrow(&quot;Java code&quot;);</div><div class="line">		System.out.println(jack.type);</div><div class="line">		</div><div class="line">		User jane = new User();</div><div class="line">		jane.setAge(19);//Javabean规范，实现对数据细节的隐藏封装</div><div class="line">		jane.setName(&quot;jane&quot;);</div><div class="line">		jane.setType(&quot;teacher&quot;);</div><div class="line">		jane.borrow(&quot;C prime plus&quot;);</div><div class="line">		System.out.println(jane.type);</div><div class="line">		</div><div class="line">		User tom = new User(&quot;tom&quot;, 21);//使用带参构造创建对象</div><div class="line">		tom.borrow(&quot;C++ prime plus&quot;);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结果：<br><img src="http://img.blog.csdn.net/20160710185740775" alt="这里写图片描述"></p>
<p>二、基本规则<br>1、一个源文件中只能有一个public类，可以有多个非public类，并且public类名必须与源文件名称相同<br>2、包与import语句<br>(1)Java包主要是用来给类分类，创建包使用package语句实现。包也有基本的命名规则，根据公司或个人名、项目名、模块名等命名。<br>(2)import语句。import语句就是用来提供一个合理的路径，使得编译器可以找到某个类，有点类似与c的头文件和c++的命名空间。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一、Java的对象和类&lt;br&gt;Java作为一种面向对象语言，有类、对象、实例、方法、继承、重载、抽象、多态、封装的基本概念。&lt;br&gt;1、类&lt;br&gt;(1)类是Java的核心和本质，封装、继承、多态和抽象几大特性都离不开类，可以把类看成是对象的模板。&lt;br&gt;(2)类中的变量。包括局部变量、全局变量和类变量。&lt;br&gt;    局部变量：定义在方法中的变量，作用域为本方法中。&lt;br&gt;    成员变量：定义在类中方法外的变量，作用域为本类。&lt;br&gt;    类变量(静态变量)：类变量也声明在类中，方法体之外，但必须声明为static类型(static表示全局的、静态的)。&lt;br&gt;
    
    </summary>
    
    
      <category term="Java基础" scheme="http://javazgs.com/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>字符相关</title>
    <link href="http://javazgs.com/2016/07/09/%E5%AD%97%E7%AC%A6%E7%9B%B8%E5%85%B3/"/>
    <id>http://javazgs.com/2016/07/09/字符相关/</id>
    <published>2016-07-08T16:00:00.000Z</published>
    <updated>2017-05-06T14:59:39.643Z</updated>
    
    <content type="html"><![CDATA[<p>一、字符类型<br>char是Java的一种基本数据类型，也是Java中的保留字。char在Java中占两个字节，无符号类型，是16位二进制Unicode字符。<br>char是类型表示的是字符，不是字符串；<br>char类型变量值只能用单引号来表示，不可使用双引号；<br>即表示单引号内的单个字符。<a id="more"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * @author shen</div><div class="line"> * @desc char test</div><div class="line"> * @date 2016年7月15日</div><div class="line"> */</div><div class="line">public class CharTest &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		</div><div class="line">		//单引号内的单个字符</div><div class="line">		char test = &apos;C&apos;;</div><div class="line">		System.out.println(test);</div><div class="line">		</div><div class="line">		//数组</div><div class="line">		char cha[] = &#123;&apos;J&apos;,&apos;a&apos;,&apos;v&apos;,&apos;a&apos;&#125;;</div><div class="line">		System.out.println(cha);</div><div class="line">		</div><div class="line">		//Unicode编码，每一个字符用16位2进制数标识</div><div class="line">		char ucode = &apos;\u4F60&apos;;//20320</div><div class="line">		char hao = &apos;\u597d&apos;;//22909</div><div class="line">		</div><div class="line">		System.out.print(ucode);</div><div class="line">		System.out.println(hao);</div><div class="line">		</div><div class="line">		//转换成的对应值</div><div class="line">		System.out.println( ucode + hao);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">由于其编码方式，编码方式最多有65536种，远不足以使用，以及在数据库存储的一些问题，在一般情况下，char在java中的实际使用比较少，也并不推荐使用。</div></pre></td></tr></table></figure>
<p><img src="http://img.blog.csdn.net/20160720005324976" alt="这里写图片描述"></p>
<p>二、字符串类<br>1、String<br>(1)String类表示字符串，是字符串常量<a style="font-size:2px" href="http://baike.baidu.com/link?url=oXsjqHFvRV9jz1IVzi2ootperjJLDiv14Bi5m3f08Pg7qy4W0PTNOBMC422g_hEFMiU-rrpGjDAGHxHgLNKpdK" target="_blank">(另:常量池)</a>，其值在创建后不能改变，因此Stirng对象创建后是不可变的，直至到被GC回收。<br>(2)创建String对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public class StringTest &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		</div><div class="line">		String str1 = &quot;Java&quot;;//直接创建</div><div class="line">		</div><div class="line">		String str2 = new String();//面向对象基本创建方法,有时浪费内存</div><div class="line">		str2 = &quot;C++&quot;;</div><div class="line">		</div><div class="line">		String str3 = new String(&quot;C&quot;);//String类提供许多构造创建方法和其他方法,详JDK源码</div><div class="line">		</div><div class="line">		System.out.println(str1+&quot;--&quot;+str2+&quot;--&quot;+str3);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>(3)常见方法<br>I.获取字符串长度与某个字符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">String str = &quot;Java Code&quot;;</div><div class="line">str.charAt(0);//获取某个下标对应字符</div><div class="line">str.length();//字符串长度</div></pre></td></tr></table></figure>
<p>II.str.compareTo方法<br>    该方法的作用是比较两个字符串的大小，比较的原理是依次比较每个字符的字符编码。首先比较两个字符串的第一个字符，如果第一个字符串的字符编码大于第二个的字符串的字符编码，则返回大于0的值，如果小于则返回小于0的值，如果相等则比较后续的字符，如果两个字符串中的字符编码完全相同则返回0。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">String data1 = &quot;Javi&quot;;</div><div class="line">String data2  = &quot;Java&quot;;</div><div class="line">int value = data1.compareTo(data2);</div></pre></td></tr></table></figure>
<p>III.截取方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">String str = &quot;Java Code&quot;;</div><div class="line">String subStr = str.substring(7);//截取得到从某个下标之后的字符串</div><div class="line">String sub = str.substring(0, 5);//截取区间之内的字符串</div></pre></td></tr></table></figure>
<p>IV.连接方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">String st1 = &quot;Java&quot;;</div><div class="line">String st2 = &quot;Code&quot;;</div><div class="line">String st = st1.concat(st2);//连接组成一个新的字符串JavaCode</div><div class="line">String stt = st1+st2;//更直接的做法JavaCode</div><div class="line">String sst = st1+007;//参与连接中有字符串按字符串连接Java007</div></pre></td></tr></table></figure>
<p>V.查找方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">String str = &quot;Java Code&quot;;</div><div class="line">int i = str.indexOf(&apos;o&apos;);//某个在字符串第一次出现的下标,不存在则返回-1</div><div class="line">int j = str.indexOf(&apos;o&apos;, 7);//从第几个字符开始查,返回下标，不存在则返回-1</div></pre></td></tr></table></figure>
<p>VI.replace方法<br>    该方法的作用是替换字符串中所有指定的字符，然后生成一个新的字符串。经过该方法调用以后，原来的字符串不发生改变。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">String str = &quot;Java Code&quot;;</div><div class="line">String s = str.replace(&quot;Java&quot;, &quot;C++&quot;);//把Java代替成C++</div></pre></td></tr></table></figure></p>
<p>VII.split方法<br>    以特定的分隔符分隔字符串，生成一个 数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">String data = &quot;java,c++,c,c#&quot;;</div><div class="line">String arr[] = data.split(&quot;,&quot;);</div><div class="line">for(int k = 0;k&lt;arr.length;k++)&#123;</div><div class="line">	System.out.println(arr[k]);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>2、Stringbuffer<br>    同样是字符串类，Stringbuffer 是字符串变量，实现方式与String有所不同，在进行处理字符串时不生成新的对象。在存储和操作字符串操作比String更合适。<br>I.字符串拼接</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">StringBuffer data = new StringBuffer(&quot;The&quot;);//创建对象</div><div class="line">StringBuffer data1 = data.append(&quot; Great&quot;);//拼接方法</div><div class="line">String str = &quot; Wall&quot;;</div><div class="line">data1.append(str).append(&quot;!&quot;);</div></pre></td></tr></table></figure>
<p>II.deleteCharAt方法</p>
<p><img src="http://img.blog.csdn.net/20160724035037353" alt="这里写图片描述"><br>此外，字符串操作相关的方法还有insert插入、reverse反转倒序、setCharAt修改某个下标上的字符、trimToSize将StringBuffer对象的中存储空间缩小到和字符串长度一样的长度，减少空间的浪费。<br>3、Stringbuilder<br>    Stringbuilder和StringBuffer基本类似，相关方法也一样</p>
<p>4、String、StringBuffer和Stringbuilder的具体区别<br>[以下复制,来自其他博主总结]<br>String：字符串常量<br>StringBuffer：字符创变量，线程安全<br>StringBuilder：字符创变量，非线程安全</p>
<p>如果要操作少量的数据用String<br>单线程操作字符串缓冲区下操作大量数据StringBuilder<br>多线程操作字符串缓冲区下操作大量数据StringBuffer<br>5、其他<a href="http://blog.csdn.net/renfufei/article/details/14448147" target="_blank">[引用]</a><br>I.字符串比较”==”与equal()方法<br>“==” 判断两个引用的是不是同一个内存地址(同一个物理对象).<br>equals 判断两个字符串的值是否相等.<br>除非你想判断两个string引用是否同一个对象,否则应该总是使用 equals()方法.<br>II.密码及其他问题上char[]优先于String原因<br>    String是不可变对象, 意思是一旦创建,那么整个对象就不可改变. 即使新手觉得String引用变了,实际上只是(指针)引用指向了另一个(新的)对象.<br>    而程序员可以明确地对字符数组进行修改,因此敏感信息(如密码)不容易在其他地方暴露(只要你用完后对char[]置0).</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一、字符类型&lt;br&gt;char是Java的一种基本数据类型，也是Java中的保留字。char在Java中占两个字节，无符号类型，是16位二进制Unicode字符。&lt;br&gt;char是类型表示的是字符，不是字符串；&lt;br&gt;char类型变量值只能用单引号来表示，不可使用双引号；&lt;br&gt;即表示单引号内的单个字符。
    
    </summary>
    
    
      <category term="Java基础" scheme="http://javazgs.com/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
</feed>
