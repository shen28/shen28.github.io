[{"title":"eclipse neon版本打开某些javascript文件异常问题","date":"2017-05-01T16:00:00.000Z","path":"2017/05/02/eclipse neon版本打开某些javascript文件异常问题/","text":"eclipse neon版本的javascript编辑器无法处理某些异常信息，比如本人在用require js和vue js的时候碰过这种异常java.lang.NoSuchMethodError:jdk.nashorn.internal.runtime.ECMAException.getEcmaError()Ljava/lang/Object;然后js文件直接就打不开了，最终在stackoverflow找到相关问题，链接http://stackoverflow.com/questions/38089331/eclipse-neon-java-ee-ide-javascript-editor-broken 照回答者意思是javascript开发工具没法解析某些特殊语法的js代码；另一个回答是说新版本的jdk已经解决这个问题，尝试卸了jdk（一直用的1.8.0_05版），装上最新版本的（目前是1.8.0_131版），问题解决。（仅供参考）","tags":[{"name":"其他","slug":"其他","permalink":"http://javazgs.com/tags/其他/"}]},{"title":"多线程","date":"2017-04-30T16:00:00.000Z","path":"2017/05/01/多线程/","text":"在编程中，多线程的意思是某个程序同时多个任务，这样的每一个任务则称为一个线程。线程这部分涉及的知识非常多，在实际开发的应用也是非常重要，这里将介绍基本的部分。 概念线程：操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中实际运作单位。进程：计算机中已运行程序的实体。进程本身不会运行，是线程的容器。并行与并发： 并行：多个cpu实例或者多台机器同时执行一段处理逻辑，是真正的同时。 并发：通过cpu调度算法，让用户看上去同时执行，实际上从cpu操作层面不是真正的同时。[1] 实现多线程的几种基本方式1、继承Thread类 12345678910111213141516171819202122public class Test02 extends Thread&#123; private String name; public Test02(String name) &#123; this.name = name; &#125; @Override public void run() &#123; for(int i=0; i&lt;100; i++)&#123; System.out.println(name + i); &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; Test02 test1 = new Test02(\"one--&gt;\"); Test02 test2 = new Test02(\"two--&gt;\"); test1.start(); test2.start(); &#125;&#125; 2、实现Runnable接口 12345678910111213141516171819202122232425public class Test01 implements Runnable&#123; private String name; public Test01(String name)&#123; this.name = name; &#125; @Override public void run() &#123; for(int i=0; i&lt;100; i++)&#123; System.out.println(name+\"---&gt;\"+i); &#125; &#125; public static void main(String[] args) &#123; Test01 test1 = new Test01(\"one\"); Test01 test2 = new Test01(\"two\"); Thread thread1 = new Thread(test1);//使用thread类执行start方法 Thread thread2 = new Thread(test2); thread1.start(); thread2.start(); &#125;&#125; 3、使用Callable和Future接口创建线程 线程状态使用getState()方法可获取当前线程的状态(枚举类型)，各种状态如下： New（新生)当new一个新的线程时，线程还没开始运行时，状态是new123456public class Test &#123; public static void main(String[] args) &#123; Thread thread = new Thread(); System.out.println(thread.getState()); &#125;&#125; 输出NEW Runnable（可运行）线程调用start执行时12345678910111213public class Test &#123; public static void main(String[] args) &#123; Thread thread = new Thread(new Runnable() &#123; public void run() &#123; for(int i=0; i&lt;100; i++)&#123; System.out.println(\"i is \"+i); &#125; &#125; &#125;); thread.start(); System.out.println(thread.getState()); &#125;&#125; 输出RUNNABLEi is 0i is 1…i is 99 Blocked（被阻塞）当一个线程试图获取一个内部的对象锁（而不是java.util.concurrent库中的锁），而该锁被其他线程持有，则该线程进入阻塞状态。1234567891011121314151617181920212223242526272829public class Test &#123; final Object lock = new Object(); class Example implements Runnable&#123; private String name; public Example(String name) &#123; this.name = name; &#125; @Override public void run() &#123; //同步代码块 synchronized (lock) &#123; for(int i=0; i&lt;100; i++)&#123; System.out.println(name+\": i is \"+i); &#125; &#125; &#125; &#125; public static void main(String[] args) &#123; Example example1 = new Test().new Example(\"test1\"); Example example2 = new Test().new Example(\"test2\"); Thread thread1 = new Thread(example1); Thread thread2 = new Thread(example2); thread1.start(); thread2.start(); System.out.println(thread1.getState()); System.out.println(thread2.getState()); &#125;&#125; 输出RUNNABLEtest1: i is 0test2: i is 0test1: i is 1BLOCKEDtest1: i is 2… Waiting（等待）等待状态，释放自身的锁进入Waiting状态并加入线程等待队列12345678910111213141516171819202122public class Test &#123; public synchronized void testMethod()&#123; try &#123; this.wait(); System.out.println(\"waiting closed.\"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; Thread thread1 = new Thread(new Runnable() &#123; public void run() &#123; new Test().testMethod(); &#125; &#125;); thread1.start(); Thread.sleep(10);//主线程休眠，转而去执行子进程 System.out.println(thread1.getState()); &#125;&#125; 输出WAITINGwaiting closed并不会输出 Timed waiting（计时等待）在this.wait();加上等待时间就会进入计时等待状态，例如this.wait(3000);等待三秒输出内容TIMED_WAITINGwaiting closed. Terminated（被终止）run方法执行结束线程终止 123456789101112public class Test &#123; public static void main(String[] args) throws InterruptedException &#123; Thread thread = new Thread(new Runnable() &#123; public void run() &#123; System.out.println(\"run success\"); &#125; &#125;); thread.start(); Thread.sleep(100); System.out.println(thread.getState()); &#125;&#125; 线程管理 sleep方法static void sleep(long millis)让当前正在运行的线程休眠一段时间sleep是一个静态方法，不要用实例化的线程对象调用，其作用的是当前正在运行的线程。Thread.sleep(2000);表示让当前线程休眠2秒，这里的2秒并不是准确的时间段，因为线程是由系统控制，实际时间可能大于2秒。 yield方法static void yield()暂停当前正在执行的线程，重新进入就绪状态，这也是和sleep方法的区别的地方。如果有其他的可运行线程具有至少与此线程同样高的优先级，那么这些线程接下来会被调度。 join方法合并线程。等待终止指定的线程，让主线程等待子线程结束之后再执行 12345678910111213141516171819202122232425public class Test &#123; public static void main(String[] args) throws InterruptedException &#123; Thread thread1 = new Thread(new Runnable() &#123; public void run() &#123; for(int i=0; i&lt;100; i++)&#123; System.out.println(\"one--\"+i); &#125; &#125; &#125;); Thread thread2 = new Thread(new Runnable() &#123; public void run() &#123; thread1.start(); try &#123; thread1.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; for(int i=0; i&lt;100; i++)&#123; System.out.println(\"two--\"+i); &#125; &#125; &#125;); thread2.start(); &#125;&#125; thread1在thread2中启动，为thread2子线程，调用join，等待thread1执行结束再执行thread2，相当于把两线程合并了。void join(long millis)join重载方法带参数，在指定时间段子线程未执行完将重新进入就绪状态，等待cpu调度。 notify和notifyAll方法notify方法只唤醒一个等待（对象的）线程并使该线程开始执行。所以如果有多个线程等待一个对象，这个方法只会唤醒其中一个线程，选择哪个线程取决于操作系统对多线程管理的实现。notifyAll 会唤醒所有等待(对象的)线程。1234567891011121314151617181920212223242526272829303132333435public class Test &#123; public synchronized void testMethod()&#123; try &#123; System.out.println(\"thread start.\"); this.wait(); System.out.println(\"waiting closed.\"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; public synchronized void notifyMethod()&#123; this.notifyAll(); &#125; public static void main(String[] args) throws InterruptedException &#123; Test test = new Test(); Thread thread1 = new Thread(new Runnable() &#123; public void run() &#123; test.testMethod(); &#125; &#125;); Thread thread2 = new Thread(new Runnable() &#123; public void run() &#123; test.notifyMethod(); System.out.println(\"唤醒线程.....\"); &#125; &#125;); thread1.start(); Thread.sleep(1000); System.out.println(thread1.getState()); thread2.start(); &#125;&#125; 输出thread start.WAITING唤醒线程.....waiting closed. interrupted和isInterruptedInterrupted方法是一个静态方法，它检测当前的线程是否被中断。而且，调用interrupted方法会清除该线程的中断状态。另一方面，isInterrupted方法是一个实例方法，可用来检验是否有线程被中断。调用这个方法不会改变中断状态。 setPriority和getPriorityvoid setPriority(int newPriority)设置线程的优先级。优先级必须在Thread.MIN_PRIORITY 与Thread.MAX_PRIORITY之间。一般使用Thread.NORM_PRIORITY 优先级。final int getPriority()获取线程的优先级 结束线程Tread中有stop方法，但改方法已经过时，不推荐使用。要结束线程，可设置标志来实现。 12345678910111213141516171819202122public class Test &#123; class TestTread implements Runnable&#123; private boolean flag; private void stopThread() &#123; this.flag=true; &#125; @Override public void run() &#123; for(int i=0; i&lt;1000 &amp;&amp; !flag; i++)&#123; System.out.println(\"i is \"+i); &#125; &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; TestTread test = new Test().new TestTread(); Thread thread1 = new Thread(test); thread1.start(); Thread.sleep(3);//休眠延时 test.stopThread(); &#125;&#125; 输出一段i的值之后当执行stopThread方法线程就结束了。","tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://javazgs.com/tags/Java基础/"}]},{"title":"Linux下安装Nginx并配置一个图片服务器","date":"2017-04-20T16:00:00.000Z","path":"2017/04/21/Linux下安装Nginx并配置一个图片服务器/","text":"首先到Nginx官网下载tar.gz格式的安装包，这里下载的是nginx-1.10.3版本，环境使用centos的虚拟机 1、将安装包上传，解压，命令tar -xvf nginx-1.10.3.tar.gz； 2、自定义创建一个文件夹作为Nginx安装目录，这里在home下创建nginx文件夹； 3、在解压的文件夹（nginx-1.10.3）下执行./configure –prefix=/home/nginx 命令。意思即配置安装环境，将会把Nginx安装到/home/nginx下； 若出现缺少依赖包则先安装依赖包，以下纯净centos mini版碰到的两个依赖包问题出现上面这个执行 yum -y install pcre-devel 安装依赖， 出现这个yum install -y zlib-devel 安装依赖， 若还有其他依赖问题，根据缺少的文件提示安装相应的东西； 4、编译：在解压的文件夹下先后执行make 和 make install 命令 5、Nginx默认使用端口是80，这里直接先把Nginx端口改为8088，vi /home/nginx/conf/nginx.conf，修改server的端口，并配置一个图片服务器 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144#user nobody;worker_processes 1;#error_log logs/error.log;#error_log logs/error.log notice;#error_log logs/error.log info;#pid logs/nginx.pid;events &#123; worker_connections 1024;&#125;http &#123; include mime.types; default_type application/octet-stream; #log_format main '$remote_addr - $remote_user [$time_local] \"$request\" ' # '$status $body_bytes_sent \"$http_referer\" ' # '\"$http_user_agent\" \"$http_x_forwarded_for\"'; #access_log logs/access.log main; sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; #gzip on; server &#123; listen 8088; server_name localhost; #charset koi8-r; #access_log logs/host.access.log main; location ~ .*\\.(gif|jpg|jpeg|png)$ &#123; expires 24h; root /home/images/;#指定图片存放路径 access_log /home/nginx/logs/images.log;#图片 日志路径 proxy_store on; proxy_store_access user:rw group:rw all:rw; proxy_temp_path /home/images/;#代理临时路径 proxy_redirect off; proxy_set_header Host 127.0.0.1; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; client_max_body_size 10m; client_body_buffer_size 1280k; proxy_connect_timeout 900; proxy_send_timeout 900; proxy_read_timeout 900; proxy_buffer_size 40k; proxy_buffers 40 320k; proxy_busy_buffers_size 640k; proxy_temp_file_write_size 640k; if ( !-e $request_filename) &#123; proxy_pass http://127.0.0.1:8088;#代理访问地址 &#125; &#125; location / &#123; root html; index index.html index.htm; &#125; #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \\.php$ &#123; # proxy_pass http://127.0.0.1; #&#125; # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \\.php$ &#123; # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; # include fastcgi_params; #&#125; # deny access to .htaccess files, if Apache's document root # concurs with nginx's one # #location ~ /\\.ht &#123; # deny all; #&#125; &#125; # another virtual host using mix of IP-, name-, and port-based configuration # #server &#123; # listen 8000; # listen somename:8080; # server_name somename alias another.alias; # location / &#123; # root html; # index index.html index.htm; # &#125; #&#125; # HTTPS server # #server &#123; # listen 443 ssl; # server_name localhost; # ssl_certificate cert.pem; # ssl_certificate_key cert.key; # ssl_session_cache shared:SSL:1m; # ssl_session_timeout 5m; # ssl_ciphers HIGH:!aNULL:!MD5; # ssl_prefer_server_ciphers on; # location / &#123; # root html; # index index.html index.htm; # &#125; #&#125;&#125; server下listen的端口改为8088，并增加一个location配置，用于访问图片文件，这一串配置有#号在前面的注释掉的都可以删掉，免得看起来又长又乱。 6、启动命令： /home/nginx/sbin/nginx -c /home/nginx/conf/nginx.conf。打开防火墙对应端口供访问，8088，当然也可以直接关了防火墙。若修改了nginx.conf配置，则需要重启才生效，命令：/home/nginx/sbin/nginx -s reload 7、访问。输入ifconfig命令查看虚拟机ip，测试： 在/home/images下放张图片，测试访问：","tags":[{"name":"Linux","slug":"Linux","permalink":"http://javazgs.com/tags/Linux/"}]},{"title":"eclipse neon git 提交窗口太小问题","date":"2017-04-15T16:00:00.000Z","path":"2017/04/16/eclipse neon git 提交窗口太小问题/","text":"eclipse neon版本的javascript编辑器无法处理某些异常信息，比如本人在用require js和vue js的时候碰过这种异常java.lang.NoSuchMethodError:jdk.nashorn.internal.runtime.ECMAException.getEcmaError()Ljava/lang/Object;然后js文件直接就打不开了，最终在stackoverflow找到相关问题，链接http://stackoverflow.com/questions/38089331/eclipse-neon-java-ee-ide-javascript-editor-broken 照回答者意思是javascript开发工具没法解析某些特殊语法的js代码；另一个回答是说新版本的jdk已经解决这个问题，尝试卸了jdk（一直用的1.8.0_05版），装上最新版本的（目前是1.8.0_131版），问题解决。（仅供参考）","tags":[{"name":"其他","slug":"其他","permalink":"http://javazgs.com/tags/其他/"}]},{"title":"反射","date":"2017-04-03T16:00:00.000Z","path":"2017/04/04/反射/","text":"相信大家经常听说某些框架设计用到了反射机制啥啥，但自己对此概念却了解甚少，虽然一般开发不会用到，但还是有必要知道反射的基本原理和操作。 使用反射，可以做到： 在运行中分析类的能力。 在运行中查看对象，例如，编写一个toString方法供所有类使用。 实现数组的操作代码。 利用Method对象，这个对象很像C++中的函数指针。 反射操作主要用到的类有Class（类）、Field（属性）、Method（成员函数）、Constructor（构造）和Modifier（修饰符）一、反射获取类 新建一个Student类123456789101112131415161718192021222324252627282930313233343536public class Student &#123; private int age; private String name; //无参构造 public Student() &#123; &#125; //有参构造 public Student(int age, String name)&#123; this.age = age; this.name = name; System.out.println(\"My name is \"+name+\",I'm \"+age+\" years old.\"); &#125; public void setAge(int age) &#123; this.age = age; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public String getName() &#123; return name; &#125; public void learning() &#123; System.out.println(\"learning...\"); &#125; &#125; 测试类1234567891011121314151617181920212223public class ReflexTest &#123; public static void main(String[] args) throws ClassNotFoundException &#123; Student student = new Student(20, &quot;shen&quot;);//一般创建对象 Class stu = Class.forName(&quot;com.test.reflex.Student&quot;);//通过Class获取指定类的完整结构 System.out.println(&quot;getName---&gt;&quot;+stu.getName()); Student s = null; Student s1 = null; try &#123; s = (Student)stu.newInstance();//默认构造的是无参构造，若存在有参构造，这里将报错 Constructor constructor = stu.getConstructor(int.class, String.class);//获取有参构造,已知确定参数 s1 = (Student)constructor.newInstance(23, &quot;shen&quot;);//有参构造 Constructor[] constructors = stu.getConstructors();//所有构造 s1 = (Student)constructors[0].newInstance();//第一个构造(无参那个) &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 输出：Class类forName方法通过完整包路径类型来实例化Class对象，再通过Class对象获取Student类实例；再使用newInstance()创建对象，这里要注意Student的构造方法，默认使用的试试无参构造，可使用Constructor类操作构造方法。 二、获取类的基本结构 1、使用反射操作对象属性12345678910111213141516171819202122232425262728public class Test01 &#123; public static void main(String[] args) throws Exception, Exception &#123; try &#123; Class stu = Class.forName(&quot;com.test.reflex.Student&quot;); Constructor constructor = stu.getConstructor(int.class, String.class);//获取有参构造,已知确定参数 Student s = (Student)constructor.newInstance(23, &quot;shen&quot;);//有参构造 //Field[] fields = stu.getFields();//获取public的属性 Field[] fields = stu.getDeclaredFields();//获取所有属性 for(Field field : fields)&#123; System.out.println(&quot;属性--&gt;&quot;+field); &#125; Field fieldName = stu.getDeclaredField(&quot;name&quot;);//获取私有变量name fieldName.setAccessible(true); System.out.println(fieldName.getName());//私有属性名称 System.out.println(fieldName.get(s));//私有属性值 fieldName.set(s, &quot;a-shen&quot;); System.out.println(fieldName.get(s));//改变私有属性值 &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 结果输出 其中对于fieldName.setAccessible(true);使用java反射获取类的属性值时，如果该属性被声明为private 的，需要将setAccessible设置为true. 默认的值为false 2、使用反射访问成员函数通过反射调用方法，使用invoke方法 12345678910111213141516171819202122232425262728public class Test02 &#123; public static void main(String[] args) throws Exception, Exception &#123; try &#123; Class stu = Class.forName(&quot;com.test.reflex.Student&quot;); Constructor constructor = stu.getConstructor(int.class, String.class);//获取有参构造,已知确定参数 Constructor[] constructors = stu.getConstructors(); Student s = (Student)constructors[0].newInstance();//无参构造对象 //Method[] methods = stu.getMethods();//获取类所有方法，包括继承自父类和实现接口的方法 Method[] methods = stu.getDeclaredMethods();//获取类本身各类方法和实现接口的方法及重写的方法，不包括继承的方法 for(Method method : methods)&#123; System.out.println(&quot;成员函数---&gt;&quot;+method); &#125; Method m1 = s.getClass().getMethod(&quot;setName&quot;, String.class); m1.invoke(s, &quot;ashen&quot;);//设置name值为&quot;ashen&quot; Method m2 = s.getClass().getMethod(&quot;getName&quot;); String name = (String) m2.invoke(s); System.out.println(&quot;getName---&gt;&quot;+name);//输出name值 &#125;catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 结果输出","tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://javazgs.com/tags/Java基础/"}]},{"title":"Mysql存储过程","date":"2017-02-25T16:00:00.000Z","path":"2017/02/26/Mysql存储过程/","text":"当需要实现复杂的逻辑，需要写多条sql语句或写的sql比较复杂时，可以考虑使用存储过程来处理，最终返回需要的结果集。存储过程即一组SQL语句集。 存储过程的基本语法也不算复杂，以下为创建一个存储过程的模板123456789101112131415161718192021222324DROP PROCEDURE IF EXISTS TEST_FUNCTION;/*定义存储过程名称，设置入参，指定类型和大小*/CREATE PROCEDURE TEST_FUNCTION(in DATA_A INT(20),in DATA_B INT(20),in B_TYPE varchar(20))BEGIN /*DECLARE 关键字用于定义变量*/ DECLARE SUM int default 0; DECLARE t_error INTEGER DEFAULT 0; DECLARE CONTINUE HANDLER FOR SQLEXCEPTION SET t_error=1;/*异常标志*/ START TRANSACTION;/*启动事务*/ /*字符串的判断，STRCMP用法类似于C++*/ if STRCMP(B_TYPE,'SUM')=0 then begin SELECT DATA_A+DATA_B INTO SUM;/*INTO 把值放到变量中*/ SELECT SUM; end;/*一个begin对应一个end*/ end if;/*一个if对应一个end if*/ IF t_error = 1 THEN ROLLBACK;/*异常回滚*/ ELSE COMMIT;/*正常提交*/ END IF;END; 创建生成的样子 DEFINER的信息是’用户名’@’host’ 输入参数值测试 调用存储使用call命令","tags":[{"name":"数据库","slug":"数据库","permalink":"http://javazgs.com/tags/数据库/"}]},{"title":"内部类相关——定义、匿名内部类、回调实现及静态内部类","date":"2017-02-22T16:00:00.000Z","path":"2017/02/23/内部类相关——定义、匿名内部类、回调实现及静态内部类/","text":"内部类，顾名思义就是在一个类中的类。内部类可以访问所在类的数据，包括私有数据，而又可以对其他类隐藏，在快速实现回调函数时可以使用匿名内部类，比较便捷。 1、以下为一个简单的内部类例子，内部类可以定义为私有以对其他类隐藏起来；可以用内部类来达到实现多继承的效果。需要注意的是，通过成员函数传入内部类的变量必须定义为final类型，以保证数据的一致性。123456789101112131415161718192021222324public class Cat extends Walk&#123; //private私有类，继承Walk和Eat private class LittleCat extends Eat &#123; public void doSomething() &#123; System.out.println(\"Walking....Eating....\"); &#125; &#125; public static void main(String[] args) &#123; LittleCat lCat = new Cat().new LittleCat();//创建内部类对象方式，通过先创建所在外围类对象再创建内部类对象 lCat.doSomething(); &#125; public void event(final String name) &#123; class EatFish&#123; public void eat() &#123; //name = \"Tom\";//在这里修改会报错，name 必须为final类型，保证数据一致 System.out.println(name); &#125; &#125; EatFish test = new EatFish(); test.eat(); &#125;&#125; 两个父类：12public class Walk &#123;&#125; 12public class Eat &#123;&#125; 2、匿名内部类从名称可以知道匿名就是没有类名的类，匿名内部类用于快速调用接口或抽象类等等中的方法，不需要多写一个实现类来实现调用。 抽象类123public abstract class Dog &#123; abstract void eat();&#125; 接口123public interface Animal &#123; void eat();&#125; 测试类123456789101112131415161718192021222324252627public class AnonymousDemo &#123; public static void main(String[] args) &#123; /** * 通过创建的一个接口或抽象类分引用，快速便捷重写需要实现的方法，不需要先写一个实现类再实例化以调用方法 */ //实现接口方式 Animal dog = new Animal() &#123; @Override public void eat() &#123; System.out.println(&quot;like bone.&quot;); &#125; &#125;; dog.eat();//向上转型的实例，直接调用重写的eat方法 //继承抽象类的方式 Dog littleDog = new Dog() &#123; @Override void eat() &#123; System.out.println(&quot;I like bone.&quot;); &#125; &#125;; littleDog.eat(); &#125;&#125; 此外，Java的回调函数式可以通过匿名内部类来实现，比如以下例子 (1)封装的类和提供的接口封装给别人调用的类1234567891011121314151617181920212223242526public class Person &#123; private EatFood eatFood; /** * 普通方式，构造传递引用 */ public Person(EatFood eatSomething)&#123; this.eatFood = eatSomething;//构造时传入引用 &#125; /** * 普通方式，成员函数传递引用 */ public Person()&#123; &#125; public void setCallBack(EatFood eatSomething) &#123; this.eatFood = eatSomething;//用成员函数传入引用 &#125; //需要调用的方法 public void eatFood() &#123; eatFood.eat(); &#125;&#125; 调用类需要的接口定义123public interface EatFood &#123; void eat();&#125; (2)实际调用一般做法都会写一个类实现接口 1234567public class EatRice implements EatFood &#123; @Override public void eat() &#123; // TODO Auto-generated method stub System.out.println(&quot;It&apos;s time to eat rice.&quot;); &#125;&#125; 然后是实际使用的类123456789101112public class PeronEatTest &#123; public static void main(String[] args) &#123; //普通方式，构造传递引用 Person personOne = new Person(new EatRice());//EatRice实现类方式。多写一个方法传入也可 personOne.eatFood(); //普通方式，成员函数传递引用 Person personOne = new Person(); EatRice eatRice = new EatRice(); personOne.setCallBack(eatRice); personOne.eatFood();&#125; 如果使用匿名内部类就便捷了许多123456789101112public class PeronEatTest &#123; public static void main(String[] args) &#123; Person personTwo = new Person(new EatFood() &#123; @Override public void eat() &#123; // TODO Auto-generated method stub System.out.println(&quot;It&apos;s time to eat rice.&quot;); &#125; &#125;); personTwo.eatFood(); &#125;&#125; 3、静态内部类创建是不需要依赖于外围类，但也不能使用任何外围类的非static成员变量和方法 1234567891011121314151617181920212223242526272829public class Cat&#123; private String str = &quot;cat&quot;; private static String str_static = &quot;cat&quot;; private class LittleCat&#123; //public static String str_test = &quot;test&quot;;//错误，非静态内部类变量不能为静态 public static final String str_test = &quot;test&quot;;//但加上final就可以 public void doSomething() &#123; str = &quot;little cat&quot;; System.out.println(&quot;Walking....Eating....&quot;); &#125; &#125; static class BigCat&#123; public void doSomething() &#123; //str = &quot;little cat&quot;;//错误，静态内部类反问外围非静态变量和方法 str_static = &quot;big cat&quot;; System.out.println(&quot;I am a big cat.&quot;); &#125; &#125; public static void main(String[] args) &#123; LittleCat lCat = new Cat().new LittleCat();//依赖外围类 lCat.doSomething(); BigCat bigCat = new BigCat();//不依赖外围类 bigCat.doSomething(); &#125;","tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://javazgs.com/tags/Java基础/"}]},{"title":"无题","date":"2017-02-13T16:00:00.000Z","path":"2017/02/14/0214广州/","text":"本命年暂且不用去想太多破事，认真过好今年 E时光上的广州","tags":[{"name":"其他","slug":"其他","permalink":"http://javazgs.com/tags/其他/"}]},{"title":"鸡年大吉","date":"2017-01-26T16:00:00.000Z","path":"2017/01/27/除夕/","text":"2017除夕辞旧迎新新年快乐","tags":[{"name":"其他","slug":"其他","permalink":"http://javazgs.com/tags/其他/"}]},{"title":"给博客换个主题","date":"2016-12-28T16:00:00.000Z","path":"2016/12/29/给博客换个主题/","text":"搭好了博客之后，想把博客换了个hexo主题，挑来挑去最后选了Litten的Yilia主题。事实好多主题都做得很棒，现在不管是网站和移动端的应用，都很注重页面展示和交互体验，由此前端的技术也是日新月异，作为一个后端，看得真是眼花缭乱。 转眼间2016也即将过去了，这年毕业了，开始工作，真正地靠自己生活着，做了许多事情，也学会很多东西。整体上马马虎虎，但事实还有许多事情没有做好，找个时间再写个年终总结吧。 加首歌试试 markdown真是好用啊。顺便加上多说评论。 以下测试 12345public class HelloWorld &#123; public static void main(String[] args) &#123; System.out.println(\"欢迎来到啊深的博客。\"); &#125;&#125; 故人西辞黄鹤楼，烟花三月下扬州。孤帆远影碧空尽，惟见长江天际流。 16/12/29","tags":[{"name":"博客","slug":"博客","permalink":"http://javazgs.com/tags/博客/"}]},{"title":"欢迎来到我的博客","date":"2016-12-19T16:00:00.000Z","path":"2016/12/20/hello-world/","text":"之前鼓捣服务器的时候买了个域名耍耍，空间到期之后域名一直放着，不久前才想起github上能搭个博客能用自定义域名，而且刚好又不需要备案，就鼓捣了这个博客。","tags":[{"name":"其他","slug":"其他","permalink":"http://javazgs.com/tags/其他/"}]},{"title":"淘淘商城的实践(6)——单点登录、集群及总结","date":"2016-11-28T16:00:00.000Z","path":"2016/11/29/淘淘商城的实践(6)——单点登录、集群及总结/","text":"最后一篇，简单记录下剩下主要的内容和写个总结。整个项目基于各类技术的入门使用，展现开发中对于不同业务需要用到的技术和技术的整合，实际意义虽不大，但至少对当下流行的技术的初步了解还是有用的。 一、单点登录 SSO(Single Sign On)单点登录是在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统。它包括可以将这次主要的登录映射到其他应用中用于同一个用户的登录的机制。它是目前比较流行的企业业务整合的解决方案之一。 1、tomcat的session复制方式tomcat实现单点登录是采用全局session复制方式，集群内每个tomcat的session完全同步。2、redis验证登录之后将session存放在redis服务器中，token作为键值，设置过期时间(比如半个小时)，客户端存放token，每当访问页面时先验证token是否过期。若token不存在或者过期则跳转到登录页面，若存在且有效则通过。创建taotao-sso工程，配置跟之前普通war工程一样。所有工程的登录都跳转到本工程进行登录，并获取验证token凭证。 二、集群及其他1、订单和购物车这些纯业务的东西没什么好讲的，看看就好；2、集群功能方面，redis和solr还有tomcat等等大部分内容都是配置文件配置，模拟集群环境需要多个虚拟机，电脑跑不起来的也看看就好；3、域名规划、项目部署和nginx的配置使用涉及内容琐碎繁多，在实际开发中整理学习比较实际。 三、总结实际中一个项目从确定需求到选择框架，再到实际开发，解决各类各样的技术问题，最后项目上线，部署工程和服务器的配置等等，涉及许许多多的东西，不是一个培训班小项目就能看到多少东西。最后的单点登录和集群等功能扩展开来写的东西太多，干脆一笔带过，等学到时再做记录。到此，商城就酱紫。 最后整理的工程文件下载(仅参考)","tags":[{"name":"商城技术应用","slug":"商城技术应用","permalink":"http://javazgs.com/tags/商城技术应用/"}]},{"title":"淘淘商城的实践(5)——Solr全文检索","date":"2016-11-27T16:00:00.000Z","path":"2016/11/28/solr全文检索/","text":"时间又过去了好久，最近在鼓捣微信开发停不来下…..在上一篇博文记录了使用redis为商城系统添加缓存服务，以提高网站的访问速度和性能。另外，我们很容易注意到搜索服务在商城网站中是必不可少的，事实上，在内容繁多的一般网站业也会有搜索功能，而这里很多人就想到Lucene或Solr。 一、Lucene和Solr一说到全文检索总会提到Lucene和Solr，但这两者有什么区别，官网上已经解释了很清楚： Lucene Core, our flagship sub-project, provides Java-based indexing and search technology, as well as spellchecking, hit highlighting and advanced analysis/tokenization capabilities. SolrTM is a high performance search server built using Lucene Core, with XML/HTTP and JSON/Python/Ruby APIs, hit highlighting, faceted search, caching, replication, and a web admin interface. 说白了Lucene是个Java Library，而Solr是一个基于Lucene的全文搜索服务器。如果使用Lucene需要自行实现一堆东西，但更灵活；Solr作为企业级的搜索引擎系统，使用方便。商城这里用solr练手，实际的商城网站如京东或淘宝，当然，肯定是其他高大上的东西了。 二、安装Solr 先到Solr官网下载,Solr的版本基本是和Lucene一起更新的，不就前看到的时候5.5.0版，现在都到6.3.0版了。商城教程使用的tomcat和solr版本都比较老，这里直接用tomcat8和solr6.3.0。在高版本solr中原商城教程有些方法已经过时，不推荐使用，这里会重新实现一遍。 解压solr压缩包，可以看到几个文件夹，有常规的docs文档、licenses版本信息和example例子。bin目录下是命令操作区，dos下在本目录执行 solr start 快速启动solr，在浏览器输入 localhost:8983 可看到solr的基本操作页面，这里我们不直接启动，而是将solr发布到tomcat。contrib文件包含了一些扩展工具包，dist是solr编译之后的目标文件夹，包含各类jar包，server文件夹即应用文件夹。 将solr-6.3.0\\server\\solr-webapp下的webapp文件复制到tomcat的webapps下并重命名为solr，即当成一个发布的工程。 将solr-6.3.0\\server\\lib\\ext下的文件复制到刚重命名的solr工程中 WEB-INF\\lib 目录下，在WEB-INF创建classes文件夹，将solr-6.3.0\\server\\resources下的log4j.properties复制到classes文件夹中，这些都是一些日志相关的东西。 接着需要创建一个solr home，随意在某个目录下创建一个文件夹并命名为solr_home，例如D盘下D:\\solr_home，然后将solr-6.3.0\\server\\solr文件夹复制过来。编辑solr工程web.xml文件，指定solr home的路径为D:\\solr_home。索引库默认存放在这个文件夹，并包含刚复制过来分配置文件。 12345&lt;env-entry&gt; &lt;env-entry-name&gt;solr/home&lt;/env-entry-name&gt; &lt;env-entry-value&gt;D:/solr_home/solr&lt;/env-entry-value&gt; &lt;env-entry-type&gt;java.lang.String&lt;/env-entry-type&gt;&lt;/env-entry&gt; 尝试访问http://localhost:8080/solr/index.html报错403，资源拒绝访问，回到solr工程的web.xml文件，可以看到有这么一段配置 12345678910111213141516&lt;!-- Get rid of error message --&gt; &lt;security-constraint&gt; &lt;web-resource-collection&gt; &lt;web-resource-name&gt;Disable TRACE&lt;/web-resource-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;http-method&gt;TRACE&lt;/http-method&gt; &lt;/web-resource-collection&gt; &lt;auth-constraint/&gt; &lt;/security-constraint&gt; &lt;security-constraint&gt; &lt;web-resource-collection&gt; &lt;web-resource-name&gt;Enable everything but TRACE&lt;/web-resource-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;http-method-omission&gt;TRACE&lt;/http-method-omission&gt; &lt;/web-resource-collection&gt; &lt;/security-constraint&gt; 注释掉本段配置，开放访问权限就能正常访问。 三、创建core 将solr-6.3.0/dist中的solr-dataimporthandler、solr-dataimporthandler-extras的jar包复制到tomcat\\webapps\\solr\\WEB-INF\\lib目录下； 在D:\\solr_home\\solr下创建taotao_core文件夹，并在taotao_core下创建data和conf文件夹。将solr-6.3.0\\example\\example-DIH\\solr\\solr\\conf所有文件和文件夹复制到D:\\solr_home\\solr\\taotao_core\\conf目录下； 访问solr工程，创建core，instanceDir和name填core文件夹的名字，即taotao_core。 四、配置IK中文分词器 下载跟solr对应版本的IK分词器IK-analyze-solr6.3，解压后将jar包复制到solr工程WEB-INF\\lib目录下，将IKAnalyzer.cfg.xml配置文件和mydict.dic、stopword.dic两个词典复制到到solr工程WEB-INF\\classes目录下。 配置业务字段：修改D:\\solr_home\\solr\\taotao_core\\conf下的managed-schema文件在底部&lt; /schema&gt;线加上 12345678910111213141516&lt;fieldType name=\"text_ik\" class=\"solr.TextField\"&gt; &lt;analyzer class=\"org.wltea.analyzer.lucene.IKAnalyzer\"/&gt;&lt;/fieldType&gt;&lt;field name=\"item_title\" type=\"text_ik\" indexed=\"true\" stored=\"true\"/&gt;&lt;field name=\"item_sell_point\" type=\"text_ik\" indexed=\"true\" stored=\"true\"/&gt;&lt;field name=\"item_price\" type=\"long\" indexed=\"true\" stored=\"true\"/&gt;&lt;field name=\"item_image\" type=\"string\" indexed=\"false\" stored=\"true\" /&gt;&lt;field name=\"item_category_name\" type=\"string\" indexed=\"true\" stored=\"true\" /&gt;&lt;field name=\"item_desc\" type=\"text_ik\" indexed=\"true\" stored=\"false\" /&gt;&lt;field name=\"item_keywords\" type=\"text_ik\" indexed=\"true\" stored=\"false\" multiValued=\"true\"/&gt;&lt;copyField source=\"item_title\" dest=\"item_keywords\"/&gt;&lt;copyField source=\"item_sell_point\" dest=\"item_keywords\"/&gt;&lt;copyField source=\"item_category_name\" dest=\"item_keywords\"/&gt;&lt;copyField source=\"item_desc\" dest=\"item_keywords\"/&gt; 重启服务器，选择taotao_core点击分词器 analysis，FieldType选择item_desc,贴上一段文本分析测试 五、在taotao-search整合并使用solr 创建taotao-search工程，同样数据库、SpringMvc照着配置，没什么好说的，applicationContext-solr.xml需要修改一下，因为httpSolrServer在6.3版本已经过时了，换成HttpSolrClient连接solr服务。从原来的HttpSolrServer可以看到,类已经deprecated了，改为使用HttpSolrClient123456789101112131415161718/** * @deprecated Use &#123;@link org.apache.solr.client.solrj.impl.HttpSolrClient&#125; */@Deprecatedpublic class HttpSolrServer extends HttpSolrClient &#123; public HttpSolrServer(String baseURL) &#123; super(baseURL); &#125; public HttpSolrServer(String baseURL, HttpClient client) &#123; super(baseURL, client); &#125; public HttpSolrServer(String baseURL, HttpClient client, ResponseParser parser) &#123; super(baseURL, client, parser); &#125;&#125; 再看下HttpSolrClient类中一个地方，baseURL参数依旧，注释给了个例子，如果是标准的solr玩意，照着这个规则配，当我们的solr是发布到tomcat的，一会配的url不行就改下123456789/** * @param baseURL * The URL of the Solr server. For example, \" * &lt;code&gt;http://localhost:8983/solr/&lt;/code&gt;\" if you are using the * standard distribution Solr webapp on your local machine. */ public HttpSolrClient(String baseURL) &#123; this(baseURL, null, new BinaryResponseParser()); &#125; applicationContext-solr.xml中bean的配置1234567891011&lt;!-- 配置SolrServer对象 --&gt; &lt;!-- 单机版 --&gt; &lt;!-- &lt;bean id=\"HttpSolrClient\" class=\"org.apache.solr.client.solrj.impl.HttpSolrServer\"&gt; --&gt; &lt;bean id=\"HttpSolrClient\" class=\"org.apache.solr.client.solrj.impl.HttpSolrClient\"&gt; &lt;constructor-arg name=\"baseURL\" value=\"$&#123;SOLR.SERVER.URL&#125;\"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;!-- 集群版 --&gt; &lt;!-- &lt;bean id=\"cloudSolrServer\" class=\"org.apache.solr.client.solrj.impl.CloudSolrServer\"&gt; &lt;constructor-arg name=\"zkHost\" value=\"192.168.25.154:2181,192.168.25.154:2182,192.168.25.154:2183\"&gt;&lt;/constructor-arg&gt; &lt;property name=\"defaultCollection\" value=\"collection2\"&gt;&lt;/property&gt; &lt;/bean&gt; --&gt; 其中SOLR.SERVER.URL变量的配置在resource.properties中配置,指向solr下的core就是了，正常连接http://localhost:8080/solr/index.html#/taotao_core 的index.html#去掉，如果在tomcat的server xml配了根路径，没有index.html，中间的#/同样需要去掉1SOLR.SERVER.URL=http://localhost:8080/solr/taotao_core ItemServiceImpl改为注入HttpSolrClient123//private SolrServer solrServer;//过时方法，废弃不用@Autowiredprivate HttpSolrClient solrServer;//使用HttpSolrClient，实例化名称solrServer懒得改，注意 SearchDaoImpl搜索服务同理换下HttpSolrClient访问http://localhost:8083/search/manager/importall 导入数据，成功状态200，数据多可能比较慢query一下看看导进来那些东东，可以看到查到商品了搜下“移动电源试试” http://localhost:8083/search/query?q=移动电源&amp;page=3&amp;rows=15 六、发布搜索服务到taotao-portal 在taotao-portal资源文件resource.properties配置搜索服务连接 1SEARCH_BASE_URL=http://localhost:8083/search/query 业务照搬，或根据自己的需要修改。感觉事实上非要建个search工程实在是…封装个类足以。测试搜索如下","tags":[{"name":"商城技术应用","slug":"商城技术应用","permalink":"http://javazgs.com/tags/商城技术应用/"}]},{"title":"淘淘商城的实践(4)——redis的使用","date":"2016-10-20T16:00:00.000Z","path":"2016/10/21/淘淘商城的实践(4)——redis的使用/","text":"一忙起来就不动博客了，这样不好，接着上个月的商城小项目。上次商城系统从后台发布商品到前台工程的展示都已经实现了，但实际上线系统由于用户数量增多，为了应付网站的大访问量，降低数据库及整个系统的压力，一般都会选择缓存功能。 一、缓存工具的选择——redis Redis是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。 1、安装启动先到官网下载需要的对应版本的redis。redis是用C语言写的，下载有编译版和直接安装的。我这里直接用win版，解压，cd到根目录，执行redis-server.exe就可以启动redis了，默认端口6379:再新开dos，cd到redis根目录，redis-cli打开客户端，输入ping测试，响应返回pong，表示客户服务两端连接正常：然后就可以愉快进行操作了。之前公司有简单用到redis，试着放在win下，然后，貌似不怎么稳定，这东西还是放Linux下吧。 2、可视化工具在Windows下redis提供了一个可视化工具，可以链接和查看redis的各种信息。[RedisDesktopManager] 二、redis和spring的整合这里只看单机版的。根据系统的架构，所有与redis的数据交互都在taotao-rest工程完成，在本工程的操作直接注入调用redis相应的实现类即可，对于其他工程则需提供另外接口服务以供调用。 1、xml的配置12345678910111213141516171819202122232425262728293031&lt;!-- 连接池配置 --&gt; &lt;bean id=&quot;jedisPoolConfig&quot; class=&quot;redis.clients.jedis.JedisPoolConfig&quot;&gt; &lt;!-- 最大连接数 --&gt; &lt;property name=&quot;maxTotal&quot; value=&quot;30&quot; /&gt; &lt;!-- 最大空闲连接数 --&gt; &lt;property name=&quot;maxIdle&quot; value=&quot;10&quot; /&gt; &lt;!-- 每次释放连接的最大数目 --&gt; &lt;property name=&quot;numTestsPerEvictionRun&quot; value=&quot;1024&quot; /&gt; &lt;!-- 释放连接的扫描间隔（毫秒） --&gt; &lt;property name=&quot;timeBetweenEvictionRunsMillis&quot; value=&quot;30000&quot; /&gt; &lt;!-- 连接最小空闲时间 --&gt; &lt;property name=&quot;minEvictableIdleTimeMillis&quot; value=&quot;1800000&quot; /&gt; &lt;!-- 连接空闲多久后释放, 当空闲时间&gt;该值 且 空闲连接&gt;最大空闲连接数 时直接释放 --&gt; &lt;property name=&quot;softMinEvictableIdleTimeMillis&quot; value=&quot;10000&quot; /&gt; &lt;!-- 获取连接时的最大等待毫秒数,小于零:阻塞不确定的时间,默认-1 --&gt; &lt;property name=&quot;maxWaitMillis&quot; value=&quot;1500&quot; /&gt; &lt;!-- 在获取连接的时候检查有效性, 默认false --&gt; &lt;property name=&quot;testOnBorrow&quot; value=&quot;true&quot; /&gt; &lt;!-- 在空闲时检查有效性, 默认false --&gt; &lt;property name=&quot;testWhileIdle&quot; value=&quot;true&quot; /&gt; &lt;!-- 连接耗尽时是否阻塞, false报异常,ture阻塞直到超时, 默认true --&gt; &lt;property name=&quot;blockWhenExhausted&quot; value=&quot;false&quot; /&gt; &lt;/bean&gt; &lt;!-- redis连接池 --&gt; &lt;bean id=&quot;redisClient&quot; class=&quot;redis.clients.jedis.JedisPool&quot;&gt; &lt;constructor-arg name=&quot;host&quot; value=&quot;127.0.0.1&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name=&quot;port&quot; value=&quot;6379&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name=&quot;poolConfig&quot; ref=&quot;jedisPoolConfig&quot;&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;bean id=&quot;jedisClient&quot; class=&quot;com.taotao.rest.dao.impl.JedisClientSingle&quot;&gt;&lt;/bean&gt; 2、接口及实现123456789101112package com.taotao.rest.dao;public interface JedisClient &#123; String get(String key); String set(String key, String value); String hget(String hkey, String key); long hset(String hkey, String key, String value);//hash long incr(String key);//自增 long expire(String key, int second);//设置过期时间,单位秒 long ttl(String key);//生存时间 long del(String key);//删除 long hdel(String hkey, String key);&#125; JedisClientSingle再实现JedisClient 接口，完成redis的基本功能。系统的缓存逻辑是从redis获取数据，若redis对应数据不存在，就从mysql数据库取数据存储到redis中，返回。下次即能直接从redis获得数据，若数据发生变更，在变更操作后删除对应键值在redis中的数据，重复上述方法。 3、为其他工程提供服务接口以taotao-manager-service内容管理更新redis为例。dao接口仍然是JedisClient ,基础操作功能一样。实现类为一个Service。1234567891011121314151617@Servicepublic class RedisServiceImpl implements RedisService @Autowired private JedisClient jedisClient; @Value(&quot;$&#123;INDEX_CONTENT_REDIS_KEY&#125;&quot;) private String INDEX_CONTENT_REDIS_KEY; @Override public TaotaoResult syncContent(long contentCid) &#123; try &#123; jedisClient.hdel(INDEX_CONTENT_REDIS_KEY, contentCid + &quot;&quot;); &#125; catch (Exception e) &#123; e.printStackTrace(); return TaotaoResult.build(500, ExceptionUtil.getStackTrace(e)); &#125; return TaotaoResult.ok(); &#125;&#125; controller发布service,需要时直接根据http调此controller即可。123456789101112@Controller@RequestMapping(&quot;/cache/sync&quot;)public class RedisController &#123; @Autowired private RedisService redisService; @RequestMapping(&quot;/content/&#123;contentCid&#125;&quot;) @ResponseBody public TaotaoResult contentCacheSync(@PathVariable Long contentCid) &#123; TaotaoResult result = redisService.syncContent(contentCid); return result; &#125;&#125; redis看似上手简单，但真正要应用起来就不是这么回事了，需要用到redis应该都死初具规模或有特殊要求的系统，要用好不容易。作为一个广泛使用的nosql数据库，值得去学习了解。商城剩下比较主要的内容包括全文检索、单点登录、nginx及系统架构分析，只是作为一个培训练习的项目也没太多可以看了。","tags":[{"name":"商城技术应用","slug":"商城技术应用","permalink":"http://javazgs.com/tags/商城技术应用/"}]},{"title":"淘淘商城的实践(3)——图片服务器部署和前台工程","date":"2016-10-01T16:00:00.000Z","path":"2016/10/02/淘淘商城的实践(3)——图片服务器部署和前台工程/","text":"前言：之前后台系统的框架基本搭建完毕，后台剩下的就是一些增删改查业务操作。文本操作一般没什么问题，比较重要的是后台新增发布信息时涉及的图片的上传、存储和读取。教程里使用了ftp服务器来上传图片，使用nginx作为访问静态资源服务器。后台搞定之后接下来搭建前台系统。一、图片服务器相关商城系统中，新增商品经常需要编辑介绍和上传图片，后台系统的编辑页面使用了kindedit富文本编辑器，图片的上传需要我们自己配置。1、图片上传服务器使用ftp服务器作为图片上传的服务器，教程中的ftp服务器是部署在Linux系统下，跟着操作就行，没必要说，所以自己尝试在Windows下搭建ftp服务器。Windows下搭建ftp比较简单，参考链接：win10搭建ftp服务器设置服务器指向的物理地址，我这里设置的是C盘的images目录，并为服务器指定用户访问，在浏览器输入 ftp:// + 设置的ip访问，输入用户名密码 对应物理路径的文件 2、nginx静态资源访问服务器同样教程里nginx是搭建在Linux系统下，这里在尝试Windows下搭建一个。先到官网下载for Windows版本的Stable version版本，链接：nginx下载 下载完解压，编辑conf文件夹下的nginx.conf配置文件。默认pid日志是注释的，删掉前面”#”号就行。pid日志实在nginx运行时才生成的文件，在关闭nginx之后会被自动删掉，在dos下的一些操作命令依赖于此文件，比如reload、quit和stop等命令。 1pid logs/nginx.pid; 我自己的nginx部分配置，参考123456789101112131415161718192021222324252627282930313233343536373839404142434445server &#123; listen 8089;#端口号 server_name localhost;#本机 charset utf-8; #access_log logs/host.access.log main; location ~ .*\\.(gif|jpg|jpeg|png)$ &#123; expires 24h; root C:/images/;#指定图片存放路径 access_log D:/nginx-1.10.1/logs/images.log;#图片 日志路径 proxy_store on; proxy_store_access user:rw group:rw all:rw; proxy_temp_path C:/images/;#图片路径 proxy_redirect off; proxy_set_header Host 127.0.0.1; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; client_max_body_size 10m; client_body_buffer_size 1280k; proxy_connect_timeout 900; proxy_send_timeout 900; proxy_read_timeout 900; proxy_buffer_size 40k; proxy_buffers 40 320k; proxy_busy_buffers_size 640k; proxy_temp_file_write_size 640k; if ( !-e $request_filename) &#123; proxy_pass http://127.0.0.1:8089;#代理访问地址 &#125; &#125; location / &#123; root html; index index.html index.htm; &#125; error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; &#125; 在dos下cd到nginx的目录,启动 测试访问 C:/images/temp下图片其他一些nginx 命令123nginx -s stop 强制关闭 nginx -s quit 安全关闭 nginx -s reload 改变配置文件的时候，重启nginx工作进程，来时配置文件生效 3、上传和访问的服务器搭建完毕之后，在taotao-manager-web的resource.properties文件配置路径，上传的图片保存在 C:/images/ftp下1234567#搭建ftp配置的地址FTP_ADDRESS=192.168.1.108FTP_PORT=21FTP_USERNAME=shenImgFTP_PASSWORD=123456FTP_BASE_PATH=/ftpIMAGE_BASE_URL=http://127.0.0.1:8089/ftp 打开新增商品页面，测试结果在图片服务器根据规则生成的文件路径和图片文件后台系统其他业务纯增删改构造数据的东西没什么好看的，根据视频教程和文档跑一遍就行。二、前台工程的搭建教程里采用的是前台系统和服务层分开，以降低系统的耦合度。1、首先搭建服务层taotao-rest，在webservice框架方面，还是直接使用springMvc，此工程依赖于taotao-manager-pojo和taotao-manager-mapper，根据依赖关系，先将taotao-manager安装到本地仓库方便依赖。同样配置tomcat插件，使用不同端口模拟，与manager工程区别开来12345678910111213&lt;build&gt; &lt;!-- 配置插件 --&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;port&gt;8081&lt;/port&gt; &lt;path&gt;/&lt;/path&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 2、搭建taotao-portal前台门户工程，同样配置tomcat插件，端口设为8082。前台工程的所有数据都是从服务层工程taotao-rest获取的，既有ajax动态请求，又使用httpclient从服务层获取数据。(1)教程中taotao-portal和taotao-rest工程端口不同，进行ajax请求存在跨域问题，使用$.getJSONP()可解决问题。如下测试方法，获取的数据是商品的分类，请求url是htt p://localhost:8081/rest/itemcat/list?callback=getData 回调方法为getData，参数data则为获取到的数据对象。123456$(function()&#123; $.getJSONP(&quot;http://localhost:8081/rest/itemcat/list?callback=getData&quot;);&#125;);function getData(data)&#123; alert(data);&#125; 在浏览器输入地址测试 (2)若是需要在进入页面就获取到数据渲染，而不是通过ajax动态请求，则需要在进入页面就获取到需要的数据。这时可在portal工程controller层通过httpclient请求服务层数据。httpclient以其易用性和灵活性，使得客户端发送Http请求变得容易，而且也方便了开发人员测试接口（基于Http协议的），即提高了开发的效率，也方便提高代码的健壮性。测试请求可使用谷歌浏览器商店的postman，比较好用。测试请求大广告的数据示例 这部分主要是分析系统，如何将大的系统工程进行分割简化，各个工程之间如何进行通讯，使用接口的方式进行数据调用，让各个工程互不干扰，可同时进行开发。主要知识：搭建图片服务器，$.getJSONP()和httpclient两种数据请求方式。 centos虚拟机下安装Nginx http://blog.csdn.net/u012809062/article/details/70307130","tags":[{"name":"商城技术应用","slug":"商城技术应用","permalink":"http://javazgs.com/tags/商城技术应用/"}]},{"title":"淘淘商城的实践(1)——说明篇","date":"2016-09-28T16:00:00.000Z","path":"2016/09/29/淘淘商城的实践(1)——说明篇/","text":"之前在贴吧看到有吧友分享这个淘淘商城的项目，简单看了下介绍原来是培训机构的一个培训项目，虽然是培训的教学项目，但从工程的基础架构创建到各种框架的整合，以及结合了许多常用的web技术，没有具体特别深入单一技术的研究，但整个项目可谓面面俱到，各种功能都有。正因为如此，这个项目用来简单了解各种技术在开发中的应用与结合，积累基础知识确实很有用处。 本人今年刚毕业，在校一直学的是嵌入式方面的知识，在参加工作时才刚转的JavaWeb开发，对java开发的了解还停留在基础阶段，知识积累远远不够。因此，这段时间打算看看这个商城项目，希望有所受益。 商城项目包括后台的CMS系统，到前台页面的商品展示页面，串通从发布商品到下单支付购买的整个流程（支付貌似没有，后面尝试加上），基本的商城功能都有了。手动实现一遍整个项目估计需要不少时间，介绍先到这里，开始搭框架。 吧友给的资料分享链接：度盘链接提取密码：7wfj","tags":[{"name":"商城技术应用","slug":"商城技术应用","permalink":"http://javazgs.com/tags/商城技术应用/"}]},{"title":"淘淘商城的实践(2)——后台系统搭建","date":"2016-09-28T16:00:00.000Z","path":"2016/09/29/淘淘商城的实践(2)——后台系统搭建/","text":"前言：在这里记录在项目开发中的要点，对原网上的源码进一步优化和修改一些错误，对于开发过程中的一些冗长讲解不进行详细的分析，比如接下来的工程创建等等。一、工程创建1、系统工程使用Maven构建工具创建，工程之间的依赖关系如下 跟着视频教程和源码资料创建工程，视频已经讲得非常详细这里就不多说。如上图taotao-parent是一个pom类型父工程，用来管理依赖的jar包的版本，全局级别。原网上的源码pom.xml中有些jar包配置存在错误，如果在构建完工程报jar包相关错误请检查配置。例如原先commons-io的groupId就错了，应该是commons-io，在运行打包时就会报错。123456789101112错误&lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;$&#123;commons-io.version&#125;&lt;/version&gt;&lt;/dependency&gt;正确&lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;$&#123;commons-io.version&#125;&lt;/version&gt;&lt;/dependency&gt; 各种jar包的maven配置可以去maven repository 网站查找，搜素需要的jar包，选择对应的版本就有相应的maven配置。例：自己重新排查了一遍，有些jar包因为本地仓库已经有了别的版本号文件，所以改了版本号不必重新下载。Spring用了4.3.0-release版，mybatis用了3.3.0版。 2、taotao-common工程是用来存放各种自封装或其他来源的工具类，jar工程，最终打包成jar文件，给其他工程调用，需要调用的工程要依赖此工程。 3、 创建聚合工程taotao-manager，pom类型，然后在工程下创建pojo实体类、mapper接口、service层， controller层对应的module模块工程。所有模块均依赖taotao-common工程，其中taotao-manager-mapper还依赖taotao-manager-pojo；taotao-manager-service还依赖taotao-manager-mapper和taotao-manager-pojo；taotao-manager-controller则manager其他模块都依赖。 在Maven Dependencies目录下可以看到工程或模块依赖的jar包和工程。 &nbsp;&nbsp;&nbsp; 3、在generatorSqlmapCustom工程配置数据库链接，使用mybatis逆向工程自动生成pojo类和mapper文件（逆向工程在度盘资源，第二天：框架整合，框架系统搭建文件夹中的参考资料压缩包中，包括数据库的sql，直接导入到本地数据库就行），生成的pojo类和mapper接口和xml复制到对应的工程下面。 4、Spring、Mybatis和SpringMvc整合框架整合配置xml文件和web.xml都在taotao-manager-web模块下进行配置，照着资料就行，不啰嗦事实Spring的三个applicationContext没必要分开，直接一个就行，当然，分开找起来比较容易，目的明确。 5、运行及简单测试工程。(1)安装tomcat插件和依赖工程到maven仓库 工程运行采用的是maven的tomcat插件，需要在taotao-parent工程的pom.xml进行配置，顺便指定jdk版本等其他配置：1234567891011121314151617181920212223242526272829303132333435&lt;build&gt; &lt;finalName&gt;$&#123;project.artifactId&#125;&lt;/finalName&gt; &lt;plugins&gt; &lt;!-- 资源文件拷贝插件 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;version&gt;2.7&lt;/version&gt; &lt;configuration&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;!-- java编译插件 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.1&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;pluginManagement&gt; &lt;plugins&gt; &lt;!-- 配置Tomcat插件 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt;&lt;/build&gt; 由于项目工程的jar版本都依赖taotao-parent工程，所以需要先将taotao-parent工程安装到本地maven仓库中，同样的，taotao-common也要安装到maven仓库中。安装方法：右键工程run as—maven install，执行完毕会在当前系统用户文件夹的.m2文件夹下面看到安装的taotao-parent和taotao-common (2)打包和运行我们最终发布出去放到服务器上的是war包，即taotao-manager-web模块的war包，直接对聚合工程taotao-manager打包，会自动对工程下的模块的jar或war模块进行打包，最终发布的是taotao-manager-web下的war包。操作:右键run as -maven build ，选第二个（第一次选第一个也行），在 Goals一栏输入clean package，点击run即可。 这里需要注意的地方是mapper模块是打成jar包的，默认不包含mybatis的映射xml文件，需要在taotao-manager-mapper的pom.xml文件加上以下配置12345678910111213&lt;!-- 如果不添加此节点mybatis的mapper.xml文件都会被漏掉。 --&gt; &lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/build&gt; 运行或调试命令:右键taotao-manager工程run as 选第二项，在在 Goals一栏输入clean tomcat7:run，然后点击run即可。调试时若提示找不到源文件，手动添加即可，可以在提示界面直接选择添加，也可以入下图在debug或run按钮的debug/run Configurations里面的Source选项卡进行配置，将需要的工程添加进去 测试结果,浏览器访问index.jsp 访问测试controller请求，查询数据库商品 重新整理的工程源码点击下载","tags":[{"name":"商城技术应用","slug":"商城技术应用","permalink":"http://javazgs.com/tags/商城技术应用/"}]},{"title":"继承、多态、封装、抽象类与接口","date":"2016-09-04T16:00:00.000Z","path":"2016/09/05/继承、多态、封装、抽象类与接口/","text":"作为一门面向对象语言，继承和多态是Java重要的特性。继承封装了一些公共特性，实现代码复用，减少代码冗余；多态可以动态调整对象的调用，降低对象之间的依存关系；接口是一种规范，可以通过接口实现多继承的功能。一、继承 利用继承，人们可以基于已存在的类构造一个新类。继承已存在的类就是复用（继承）这些类的方法和域。在此基础上，还可以添加一些新的方法和域，以满足新的需求。这是Java程序设计中的一项核心技术。[java核心技术] 新建一个人物父类12345678910111213141516public class Person &#123; private int age; private String name; public Person(int age, String name)&#123; this.age = age; this.name = name; &#125; public void info()&#123; System.out.println(age); System.out.println(name); &#125; &#125; Teacher子类继承Person父类，关键字extends表示继承，extends表明正在构造的新类派生于一个已存在的类。已存在的类被称为超类（superclass）、基类（base class）或父类（parent class）；新类被称为子类（subclass）、派生类（derived class）或孩子类（child class）。 1234567891011121314151617181920212223242526public class Teacher extends Person &#123; //默认实现无参构造并可以不写，如果父类存在带参构造，则需要显式实现此构造 public Teacher(int age, String name) &#123; super(22, &quot;shen&quot;); // TODO Auto-generated constructor stub super.info(); &#125; //重写父类方法 @Override public void info()&#123; System.out.println(&quot;rewrite...&quot;); &#125; public static void main(String[] args) &#123; Teacher t = new Teacher(20, &quot;tutu&quot;); t.info();//子类拥有所有父类的成员变量，但private的成员变量没有访问权限 //t.age//private变量不可访问 &#125; &#125;输出结果：22shenrewrite... 二、多态实现多态有三个条件：要有继承、要有重写、父类引用指向子类对象。父类：12345678910public class Animal &#123; public void eat()&#123; System.out.println(&quot;eat food&quot;); &#125; public void walk()&#123; System.out.println(&quot;walk alone&quot;); &#125;&#125; 子类： 123456789101112131415161718192021222324252627282930public class Dog extends Animal &#123; //重写父类方法 @Override public void eat()&#123; System.out.println(&quot;eat bone&quot;); &#125; public void walk(String dog1)&#123; dog1 = &quot;tom&quot;; System.out.println(&quot;walk with &quot; + dog1); &#125; public static void main(String[] args) &#123; Animal dog = new Dog();//向上转型，父类引用指向子类对象 dog.eat(); dog.walk(); //dog.walk(&quot;jane&quot;);//只能调用父类存在的方法 Dog dd = (Dog)dog;//向下转型 dd.walk(); dd.walk(&quot;jane&quot;); &#125;&#125;输出结果：eat bonewalk alonewalk alonewalk with tom 多态可以使程序有良好的扩展，并可以对所有类的对象进行通用处理。三、封装在面向对象程式设计方法中，封装指一种将抽象性函式接口的实作细节部份包装、隐藏起来的方法。通常都使用getter和setter方法来实现，其他类要访问本类的私有成员变量都需要通过getter和setter方法。例实体类：1234567891011121314151617public class Person &#123; private int age; private String name; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; 测试类： 1234567891011121314public class Test &#123; public static void main(String[] args) &#123; Person t = new Person(); t.setAge(20); t.setName(&quot;shen&quot;); System.out.println(&quot;Age:&quot; + t.getAge() + &quot; name:&quot; + t.getName()); &#125; &#125;输出：Age:20 name:shen 四、抽象与接口1、我们知道，在面向对象世界中，所有的对象都是通过类来描述的，但是并不是所有的类都是来描述对象的。如果一个类没有足够的信息来描述一个具体的对象，而需要其他具体的类来支撑它，那么这样的类我们称它为抽象类。例： 12345678910111213141516public abstract class Animal &#123; private String name; private float weight; public Animal(String name, float weight)&#123; this.name = name; this.weight = weight; &#125; abstract void run();//抽象类不一定有抽象方法，但包含抽象方法的类一定要被声明为抽象类 public void eat()&#123; &#125;&#125; 继承： 12345678910111213141516171819202122public class Cat extends Animal&#123; public Cat(String name, float weight) &#123; super(name, weight); // TODO Auto-generated constructor stub &#125; //覆盖抽象方法 @Override void run() &#123; // TODO Auto-generated method stub System.out.println(&quot;run fast&quot;); &#125; public static void main(String[] args) &#123; //Animal cat = new Animal(&quot;tom&quot;, 20f);//错误,抽象类不能实例化 Cat cat = new Cat(&quot;tom&quot;, 20f); cat.run(); &#125; &#125; 另注：如果一个类包含抽象方法，那么该类必须是抽象类。任何子类必须重写父类的抽象方法，或者声明自身为抽象类。2、接口接口是抽象方法的集合。接口并不是类，一个类通过继承接口的方式，从而来继承接口的抽象方法。实现接口必须覆盖全部抽象方法，跟抽象类相似。但是java中不能通过extends实现多继承，可以通过实现多个接口来达到多继承的目的。1234public interface Person &#123; public void eat(); public void say();&#125; 实现：123456789101112public class Student implements Person &#123; @Override public void eat() &#123; // TODO Auto-generated method stub &#125; @Override public void say() &#123; // TODO Auto-generated method stub &#125;&#125; 注：接口是隐式抽象的，当声明一个接口的时候，不必使用abstract关键字。接口中每一个方法也是隐式抽象的，声明时同样不需要abstract关键子。接口中的方法都是公有的。","tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://javazgs.com/tags/Java基础/"}]},{"title":"集合","date":"2016-08-12T16:00:00.000Z","path":"2016/08/13/集合/","text":"一、概述 集合框架是Java一块很重要的内容，对常用的数据结构做了规范和实现。对象封装了数据，许多对象则构成了所谓集合。Java集合类库构成了集合类的框架。它为集合的实现者定义了大量的接口和抽象类，并且对其中的某些机制给予了描述。 集合框架的接口和实现类： 二、Iterator接口Iterator接口与Collection系列、Map系列的集合不一样：Collection系列集合、Map系列集合主要用于盛装其他对象，而Iterator则主要用于遍历（即迭代访问）Collection集合中的元素，Iterator对象也被称为迭代器。[引]Iterator接口定义了四个方法–boolean hasNext()：如果被迭代的集合还元素没有被遍历，则返回true。–Object next()：返回集合里下一个元素。–void remove() ：删除集合里上一次next方法返回的元素–void forEachRemaining(Consumer action)：这是Java 8为Iterator新增的默认方法，该方法可使用Lambda表达式来遍历集合元素。 123456789101112131415161718192021222324252627282930313233/** * @author shen * @desc Iterator接口 * @date 2016年8月23日 */public class IteratorTest &#123; public static void main(String[] args) &#123; //Iterator是Collection父接口，可如此创建集合 Collection&lt;Object&gt; animals = new HashSet&lt;&gt;(); //添加元素 animals.add(&quot;cat&quot;); animals.add(&quot;dog&quot;); animals.add(&quot;pig&quot;); //使用Lambda表达式遍历集合(java1.8新特性) animals.forEach(obj -&gt; System.out.println(&quot;Lambda迭代输出：&quot; + obj)); //iterator()方法获取迭代器 Iterator&lt;Object&gt; data = animals.iterator(); while(data.hasNext())&#123; Object subData = data.next(); if(&quot;cat&quot;.equals(subData))&#123; data.remove();//移除元素 &#125; System.out.println(&quot;迭代器输出：&quot; + subData); &#125; System.out.println(animals); &#125;&#125; 输出： 三、Collection接口 Collection不提供接口的任何直接实现，一个Collection代表一组Object，但它提供更加具体的子接口如List和Set，而继承自它们的 ArrayList, Vector, HashTable, HashMap等实现类才可被实例化。1、List接口List是一个有序集合（ordered collection）。元素可以添加到容器中某个特定的位置。将对象放置在某个位置上可以采用两种方式：使用整数索引或使用列表迭代器。[引 java核心技术]List接口实现类主要有：ArrayList、Vector、LinkedList。(1)ArrayListArrayList是List接口的可变数组的实现，其操作基本是对数组的操作，ArrayList是线程不安全的。ArrayList包装了许多的方法，包括元素的增加移除、插入移动、转换数组等等： 12345678910111213141516171819202122232425262728293031323334353637/** * @author shen * @desc * @date 2016年8月23日 */public class ListTest &#123; public static void main(String[] args) &#123; List&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add(&quot;1&quot;);//使用list时默认长度置为10 list.add(&quot;2&quot;); list.add(&quot;3&quot;); list.add(&quot;4&quot;); list.add(&quot;5&quot;); System.out.println(&quot;list输出：&quot;+list); list.remove(4);//移除元素 System.out.println(&quot;移除元素之后的list：&quot;+list); Object[] arr = list.toArray();//转换为数组 System.out.println(&quot;数组元素输出：&quot;+arr[0]); List&lt;String&gt; c = new ArrayList&lt;&gt;(4);//预计有4个元素而创建 c.add(&quot;6&quot;); c.add(&quot;7&quot;); c.add(&quot;8&quot;); c.add(&quot;9&quot;); c.add(&quot;10&quot;);//超过5个元素list会增加原来长度一半个元素,目前即长度为6 list.addAll(c);//增加一组数据,数据类型应相同 System.out.println(list); Iterator&lt;String&gt; data = list.iterator();//获取迭代器 System.out.println(&quot;迭代输出：&quot;); data.forEachRemaining(action -&gt; System.out.print(action+&quot; &quot;)); &#125;&#125; 输出：ArrayList的各种操作虽然很方便，但是ArrayList的插入和删除，会导致内部数据大量移位，而扩容则需要新建一个ArrayList将原来的数据复制过去,会影响性能。如果我们已经知道需要的元素个数，我们可以初始化时指定ArrayList的容量，这样可以有效的避免数组多次扩充，从而提高效率。(2)VectorVector类提供了实现可增长数组的功能，随着更多元素加入其中，数组变的更大。在删除一些元素之后，数组变小,而不像ArrayList的扩容方式，基本用法与ArrayList相同。Vector是同步类，是线程安全的。(3)LinkedListLinkedList是list的链表实现，列表中的每个节点都包含了对前一个和后一个元素的引用，除了大部分与ArrayList相同的方法，LinkedList还有一些其特有的方法，并且LinkedList在添加和删除元素时具有比ArrayList更好的性能，但在get数据时更慢。LinkedList适用于没有大规模的随机读取，大量的增加/删除操作。[引] 12345678910111213141516171819public class LinkTest &#123; public static void main(String[] args) &#123; LinkedList&lt;String&gt; link = new LinkedList&lt;&gt;(); link.add(&quot;a&quot;); link.add(&quot;b&quot;); link.add(&quot;c&quot;); link.add(&quot;d&quot;); link.add(&quot;e&quot;); System.out.println(&quot;第一个元素：&quot;+link.getFirst()+&quot; 最后一个元素：&quot;+link.getLast()); link.remove(1); System.out.println(link); link.add(3, &quot;zhiding&quot;); System.out.println(link); &#125;&#125; 输出： 2、Set接口由于Set接口提供的数据结构是数学意义上集合概念的抽象，因此它需要支持对象的添加、删除，而不需提供随机访问。Set具有与Collection完全一样的接口，因此没有任何额外的功能。实际上Set就是Collection，只是行为不同。Set不包含重复的元素。Set的实现类主要有：HashSet，TreeSet，LinkedHashSet(1)HashSet不保证set的迭代顺序，不保证该顺序永恒不变，因此HashSet也没有get方法。此类允许使用null元素，底层是使用HashMap实现的。 1234567891011121314151617181920212223242526public static void main(String[] args) &#123; HashSet&lt;String&gt; set = new HashSet&lt;&gt;(); set.add(&quot;adf&quot;); set.add(&quot;bhf&quot;); set.add(&quot;c32&quot;); set.add(&quot;c32&quot;);//有重复元素，添加不了 set.add(null);//null也只允许只有一个 System.out.println(set); for(String str : set)&#123; System.out.print(str +&quot; &quot;); &#125; System.out.println(); Iterator&lt;String&gt; iterator = set.iterator(); while(iterator.hasNext())&#123; String data = iterator.next(); System.out.print(data +&quot; &quot;); &#125; &#125;输出：[null, bhf, adf, c32]null bhf adf c32 null bhf adf c32 (2)TreeSetTreeSet元素自然排序，底层是使用TreeMap实现的，自定义要显示Comparable接口。TreeSet可以给集合中的元素进行指定方式的排序，保证元素唯一性。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/** * @author shen * @desc 测试类，实现Comparable&lt;T&gt;接口 * @date 2016年8月24日 */public class User implements Comparable&lt;User&gt;&#123; private String name; private int age; //构造 public User(String name,int age)&#123; this.name = name; this.age = age; &#125; //实现类 @Override public int compareTo(User user) &#123; if(user == null) throw new NullPointerException(); if(this.age &gt; user.age) return 1; if(this.age &lt; user.age) return -1; return 0; &#125; //重写toString @Override public String toString() &#123; return &quot;User [name=&quot; + name + &quot;, age=&quot; + age + &quot;]&quot;; &#125; &#125;//测试public static void main(String[] args) &#123; Set&lt;User&gt; set = new TreeSet&lt;User&gt;(); User user1 = new User(&quot;Tom&quot;, 20); User user2 = new User(&quot;Jack&quot;, 21); User user3 = new User(&quot;Dave&quot;, 22); User user4 = new User(&quot;Jane&quot;, 12); set.add(user1); set.add(user1);//重复，添加不了 set.add(user2); set.add(user3); set.add(user4); System.out.println(&quot;按年龄大小输出：&quot;); System.out.println(set); &#125;输出按年龄大小输出：[User [name=Jane, age=12], User [name=Tom, age=20], User [name=Jack, age=21], User [name=Dave, age=22]] (3)LinkedHashSetLinkedHashSet集合同样是根据元素的hashCode值来决定元素的存储位置，但是它同时使用链表维护元素的次序。这样使得元素看起 来像是以插入顺序保存的，也就是说，当遍历该集合时候，LinkedHashSet将会以元素的添加顺序访问集合的元素。LinkedHashSet在迭代访问Set中的全部元素时，性能比HashSet好，但是插入时性能稍微逊色于HashSet。[引] 四、Map接口在Collection实现中保存的直接是一个个对象，二在Map实现中保存的是一对对象，以键值对key-value的方式关联着。Map的常用实现类有HashMap，HashTabel和TreeMap。1、HashMapHashMap是基于哈希表的Map接口的非同步实现，其中元素表现无序，特别是它不保证该顺序恒久不变。HashMap会利用对象的hashCode来快速找到key。12345678910111213141516171819202122232425262728293031323334353637383940414243444546public static void main(String[] args) &#123; //使用实现类创建，键值指定对象类型 HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;(); map.put(&quot;name&quot;, &quot;shen&quot;); map.put(&quot;age&quot;, &quot;20&quot;); map.put(&quot;age&quot;, &quot;19&quot;);//相同键多次存入数据覆盖 map.put(&quot;weight&quot;, &quot;100&quot;); map.put(null, &quot;空&quot;);//允许空键值 map.put(null, null); System.out.println(map); //对map集合的遍历，可取出具体的键和对应值 for(Entry&lt;String, String&gt; element:map.entrySet())&#123; String key = element.getKey(); String value = element.getValue(); Class&lt;? extends Entry&gt; classData = element.getClass(); System.out.println(key + &quot;---- &quot; + value + &quot;---- &quot; + classData.getName()); &#125; //使用接口创建，不关心具体实现，只有在使用才具体实现 //键值的值一般设为Object，不关心什么类型的数据，当然，获取需要具体数据类型或对象需要转化 Map&lt;String, Object&gt; mapData = null;//new HashMap&lt;&gt;(); mapData = new HashMap&lt;&gt;(); mapData.put(&quot;name&quot;, &quot;Jack&quot;); mapData.put(&quot;age&quot;, 21); mapData.put(&quot;weight&quot;, 110.5); System.out.println(mapData); System.out.println(&quot;获取name值:&quot; + mapData.get(&quot;name&quot;)); Set&lt;String&gt; keys = mapData.keySet(); System.out.println(&quot;获取所有key:&quot; + keys); Collection&lt;Object&gt; values = mapData.values(); System.out.println(&quot;获取所有value:&quot; + values); &#125;输出：&#123;null=null, name=shen, weight=100, age=19&#125;null---- null---- java.util.HashMap$Nodename---- shen---- java.util.HashMap$Nodeweight---- 100---- java.util.HashMap$Nodeage---- 19---- java.util.HashMap$Node&#123;name=Jack, weight=110.5, age=21&#125;获取name值:Jack获取所有key:[name, weight, age]获取所有value:[Jack, 110.5, 21] 2、HashTabelHashTable在很大程度事实上和HashMap的实现差不多，主要区别是HashMap采用异步处理方式，性能更高，而HashTabel采用同步处理方式，性能较低。HashTabel属于线程安全类而HashMap属于线程不安全类。[参考] 3、TreeMapTreeMap是可排序的Map集合按照集合中的key进行排序，key不允许重复。TreeMap是红黑树基于Map接口的实现。关于TreeMap红黑树参考,初次接触不容易理解，多查资料。","tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://javazgs.com/tags/Java基础/"}]},{"title":"字符相关","date":"2016-07-08T16:00:00.000Z","path":"2016/07/09/字符相关/","text":"一、字符类型char是Java的一种基本数据类型，也是Java中的保留字。char在Java中占两个字节，无符号类型，是16位二进制Unicode字符。char是类型表示的是字符，不是字符串；char类型变量值只能用单引号来表示，不可使用双引号；即表示单引号内的单个字符。 12345678910111213141516171819202122232425262728/** * @author shen * @desc char test * @date 2016年7月15日 */public class CharTest &#123; public static void main(String[] args) &#123; //单引号内的单个字符 char test = &apos;C&apos;; System.out.println(test); //数组 char cha[] = &#123;&apos;J&apos;,&apos;a&apos;,&apos;v&apos;,&apos;a&apos;&#125;; System.out.println(cha); //Unicode编码，每一个字符用16位2进制数标识 char ucode = &apos;\\u4F60&apos;;//20320 char hao = &apos;\\u597d&apos;;//22909 System.out.print(ucode); System.out.println(hao); //转换成的对应值 System.out.println( ucode + hao); &#125;&#125;由于其编码方式，编码方式最多有65536种，远不足以使用，以及在数据库存储的一些问题，在一般情况下，char在java中的实际使用比较少，也并不推荐使用。 二、字符串类1、String(1)String类表示字符串，是字符串常量(另:常量池)，其值在创建后不能改变，因此Stirng对象创建后是不可变的，直至到被GC回收。(2)创建String对象 1234567891011121314public class StringTest &#123; public static void main(String[] args) &#123; String str1 = &quot;Java&quot;;//直接创建 String str2 = new String();//面向对象基本创建方法,有时浪费内存 str2 = &quot;C++&quot;; String str3 = new String(&quot;C&quot;);//String类提供许多构造创建方法和其他方法,详JDK源码 System.out.println(str1+&quot;--&quot;+str2+&quot;--&quot;+str3); &#125; &#125; (3)常见方法I.获取字符串长度与某个字符 123String str = &quot;Java Code&quot;;str.charAt(0);//获取某个下标对应字符str.length();//字符串长度 II.str.compareTo方法 该方法的作用是比较两个字符串的大小，比较的原理是依次比较每个字符的字符编码。首先比较两个字符串的第一个字符，如果第一个字符串的字符编码大于第二个的字符串的字符编码，则返回大于0的值，如果小于则返回小于0的值，如果相等则比较后续的字符，如果两个字符串中的字符编码完全相同则返回0。 123String data1 = &quot;Javi&quot;;String data2 = &quot;Java&quot;;int value = data1.compareTo(data2); III.截取方法 123String str = &quot;Java Code&quot;;String subStr = str.substring(7);//截取得到从某个下标之后的字符串String sub = str.substring(0, 5);//截取区间之内的字符串 IV.连接方法 12345String st1 = &quot;Java&quot;;String st2 = &quot;Code&quot;;String st = st1.concat(st2);//连接组成一个新的字符串JavaCodeString stt = st1+st2;//更直接的做法JavaCodeString sst = st1+007;//参与连接中有字符串按字符串连接Java007 V.查找方法 123String str = &quot;Java Code&quot;;int i = str.indexOf(&apos;o&apos;);//某个在字符串第一次出现的下标,不存在则返回-1int j = str.indexOf(&apos;o&apos;, 7);//从第几个字符开始查,返回下标，不存在则返回-1 VI.replace方法 该方法的作用是替换字符串中所有指定的字符，然后生成一个新的字符串。经过该方法调用以后，原来的字符串不发生改变。12String str = &quot;Java Code&quot;;String s = str.replace(&quot;Java&quot;, &quot;C++&quot;);//把Java代替成C++ VII.split方法 以特定的分隔符分隔字符串，生成一个 数组。 12345String data = &quot;java,c++,c,c#&quot;;String arr[] = data.split(&quot;,&quot;);for(int k = 0;k&lt;arr.length;k++)&#123; System.out.println(arr[k]);&#125; 2、Stringbuffer 同样是字符串类，Stringbuffer 是字符串变量，实现方式与String有所不同，在进行处理字符串时不生成新的对象。在存储和操作字符串操作比String更合适。I.字符串拼接 1234StringBuffer data = new StringBuffer(&quot;The&quot;);//创建对象StringBuffer data1 = data.append(&quot; Great&quot;);//拼接方法String str = &quot; Wall&quot;;data1.append(str).append(&quot;!&quot;); II.deleteCharAt方法 此外，字符串操作相关的方法还有insert插入、reverse反转倒序、setCharAt修改某个下标上的字符、trimToSize将StringBuffer对象的中存储空间缩小到和字符串长度一样的长度，减少空间的浪费。3、Stringbuilder Stringbuilder和StringBuffer基本类似，相关方法也一样 4、String、StringBuffer和Stringbuilder的具体区别[以下复制,来自其他博主总结]String：字符串常量StringBuffer：字符创变量，线程安全StringBuilder：字符创变量，非线程安全 如果要操作少量的数据用String单线程操作字符串缓冲区下操作大量数据StringBuilder多线程操作字符串缓冲区下操作大量数据StringBuffer5、其他[引用]I.字符串比较”==”与equal()方法“==” 判断两个引用的是不是同一个内存地址(同一个物理对象).equals 判断两个字符串的值是否相等.除非你想判断两个string引用是否同一个对象,否则应该总是使用 equals()方法.II.密码及其他问题上char[]优先于String原因 String是不可变对象, 意思是一旦创建,那么整个对象就不可改变. 即使新手觉得String引用变了,实际上只是(指针)引用指向了另一个(新的)对象. 而程序员可以明确地对字符数组进行修改,因此敏感信息(如密码)不容易在其他地方暴露(只要你用完后对char[]置0).","tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://javazgs.com/tags/Java基础/"}]},{"title":"类与对象","date":"2016-07-08T16:00:00.000Z","path":"2016/07/09/类与对象/","text":"一、Java的对象和类Java作为一种面向对象语言，有类、对象、实例、方法、继承、重载、抽象、多态、封装的基本概念。1、类(1)类是Java的核心和本质，封装、继承、多态和抽象几大特性都离不开类，可以把类看成是对象的模板。(2)类中的变量。包括局部变量、全局变量和类变量。 局部变量：定义在方法中的变量，作用域为本方法中。 成员变量：定义在类中方法外的变量，作用域为本类。 类变量(静态变量)：类变量也声明在类中，方法体之外，但必须声明为static类型(static表示全局的、静态的)。 123456789101112131415161718192021222324252627282930/** * @author shen * @desc test * @date 2016年7月10日 */public class Book &#123; static int num = 0;//类变量 static final String type = &quot;children&quot;;//用final变量只能被初始化一次，之后不能再赋值 String str=&quot;this is a book&quot;;//实例变量 public void borrow()&#123; int i = 0;//局部变量 &#125; public static void rend()&#123; //静态方法，无需创建对象就能使用 System.out.println(&quot;this is a static method.&quot;); &#125; public static void main(String[] args) &#123; rend();//直接调用 System.out.println(&quot;this is a main function.&quot;); &#125; static &#123; //静态代码块，类加载时调用 System.out.println(&quot;this is a static code block.&quot;); &#125;&#125; 结果：(3)构造方法 每个类都有构造方法，如果没有显式定义构造方法，编译器会默认为类创建一个不带参的构造方法(若子类继承有带参构造方法的父类，需要显式调用父类构造方法)。 构造方法名必须与类名相同，一个类中可以有多个构造方法(参数不同)，创建对象时至少一个构造方法。2、对象 对象的创建：声明，声明类的类型和名称；实例化，使用new创建一个对象；初始化，创建对象时会调用构造方法初始化对象 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889/** * @author shen * @desc test * @date 2016年7月10日 */public class User &#123; private String type = &quot;student&quot;; private String name;//私有属性只能在本类获取到 private int age; public int height;//公有属性其他类也能获取到 public int getHeight() &#123; return height; &#125; public void setHeight(int height) &#123; this.height = height; &#125; //Javabean的规范，通过getter和setter对数据进行封装 public String getType() &#123; return type; &#125; public void setType(String type) &#123; this.type = type; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public User()&#123; //无参构造方法 &#125; public User(String num)&#123; //带参构造 &#125; public User(String name,int age)&#123; //参数个数不同的构造 this.name = name; this.age = age; &#125; //普通方法 public void borrow(String bookName)&#123; //bookName为方法体中的局部变量 System.out.println(this.name + &quot; borrow a book :&quot; + bookName ); &#125; public static void main(String[] args) &#123; User jack = new User();//默认的无参构造创建对象 jack.age = 20;//私有属性，只能在本类使用这种方式 jack.name = &quot;jack&quot;; //公有属性其他类也能获取到，暴露了数据细节。将属性定义为private并使用getter和setter方法隐藏数据的细节(Java的封装特性) jack.height = 170; jack.borrow(&quot;Java code&quot;); System.out.println(jack.type); User jane = new User(); jane.setAge(19);//Javabean规范，实现对数据细节的隐藏封装 jane.setName(&quot;jane&quot;); jane.setType(&quot;teacher&quot;); jane.borrow(&quot;C prime plus&quot;); System.out.println(jane.type); User tom = new User(&quot;tom&quot;, 21);//使用带参构造创建对象 tom.borrow(&quot;C++ prime plus&quot;); &#125; &#125; 结果： 二、基本规则1、一个源文件中只能有一个public类，可以有多个非public类，并且public类名必须与源文件名称相同2、包与import语句(1)Java包主要是用来给类分类，创建包使用package语句实现。包也有基本的命名规则，根据公司或个人名、项目名、模块名等命名。(2)import语句。import语句就是用来提供一个合理的路径，使得编译器可以找到某个类，有点类似与c的头文件和c++的命名空间。","tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://javazgs.com/tags/Java基础/"}]},{"title":"Java 简介和开发环境","date":"2016-06-30T16:00:00.000Z","path":"2016/07/01/Java 简介和开发环境/","text":"一、定义与特点定义：Java是一门面向对象编程语言，不仅吸收了C++语言的各种优点，还摒弃了C++里难以理解的多继承、指针等概念，因此Java语言具有功能强大和简单易用两个特征。Java语言作为静态面向对象编程语言的代表，极好地实现了面向对象理论，允许程序员以优雅的思维方式进行复杂的编程。[Java疯狂讲义]特点：主要特点是面向对象和可移植等等，广泛应用于web应用程序(JavaEE相关)、嵌入式(安卓相关)，桌面程序、分布式系统等等。二、开发工具和开发环境JDK：Java开发包或Java开发工具，编写Java程序必须，已包含JRE。JRE：Java运行环境，运行编写完毕的Java程序。JDK的安装(Windows系统,Java8)1、首先到oracle官网下载与计算机系统对应的Java SE的JDK即可。2、安装、配置环境变量配置JAVA_HOME的环境变量：新建JAVA_HOME一个变量，路径为JDK的安装路径，指定到jdk文件夹jdk的版本是1.8，在1.6版本之后的jdk都不必配置classpath环境变量了。3、基本命令win+r运行cmd，输入java命令，可以看到各种选项命令 输入java -version可以看到当前安装的jdk版本信息 javac命令，各种编译选项三、基本数据类型1、Java有八种基本数据类型，包括byte字节类型、int整形、short短整形、long长整形、char字符型、float浮点型(单精度)、double双精度类型、boolean布尔型。2、基本知识一个字节等于8位，一个字节等于256个数，就是-128到127一共256。kB就是kBytesBytes就是“字节”的意思！K就是千的意思，因为计算机是通过二进制来计算，10个1正好是10241111111111（二进制）=1024（十进制）1Bytes（字节）=8bit（比特）一个英文字母或一个阿拉伯数字就是一个字符，占用一个字节一个汉字就是两个字符，占用两个字节。3、数据类型转换byte-&gt;shortchar-&gt;int-&gt;longfloat-&gt;doubleint-&gt;floatlong-&gt;double范围小的转到范围大的范围大的转换到范围小的会失去精度","tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://javazgs.com/tags/Java基础/"}]},{"title":"spring springmvc mybatis 整合","date":"2016-04-09T16:00:00.000Z","path":"2016/04/10/spring springmvc mybatis 整合/","text":"最近鼓捣ssm框架的东西，写篇博文记录。环境 apache-tomcat-8.0.33、jdk1.8.0_05 maven Dynamic Web Module 2.51、各个xml配置文件的配置(1)pom.xml 配置清单文件连接池用的阿里巴巴Druid，数据库mysql，指定jdk编译版本1.8 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;cn.shen&lt;/groupId&gt; &lt;artifactId&gt;ssmdemo&lt;/artifactId&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;ssmdemo Maven Webapp&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;dependencies&gt; &lt;!-- 添加spring依赖，对应版本号jar包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;4.1.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 添加tomcat下servlet-api依赖,对应版本 --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 添加jtl支持 --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 添加Spring支持 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;4.1.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;4.1.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;4.1.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;4.1.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;4.1.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;4.1.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;4.1.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;4.1.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;4.1.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;4.1.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 添加日志支持 --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.7.12&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 添加mybatis支持 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- jdbc驱动包 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.37&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 添加连接池druid支持 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.0.16&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;ssmdemo&lt;/finalName&gt; &lt;!-- 指定jdk编译器版本 --&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.1&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; (2)web.xml配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance http://www.springmodules.org/schema/cache/springmodules-cache.xsd http://www.springmodules.org/schema/cache/springmodules-ehcache.xsd &quot; xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot; xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot; id=&quot;WebApp_ID&quot; version=&quot;2.5&quot;&gt; &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt; &lt;!-- Spring配置文件 --&gt; &lt;!-- --&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;!-- 解决工程编码过滤器 --&gt; &lt;filter&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- Spring监听器 --&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- 添加对springmvc的支持 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-mvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;async-supported&gt;true&lt;/async-supported&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt; &lt;url-pattern&gt;*.html&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; (3)mybatis配置 12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;!-- 别名 --&gt; &lt;typeAliases&gt; &lt;package name=&quot;cn.web.open.model&quot;/&gt; &lt;/typeAliases&gt;&lt;/configuration&gt; (4)springmvc配置 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:jee=&quot;http://www.springframework.org/schema/jee&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd http://www.springframework.org/schema/jee http://www.springframework.org/schema/jee/spring-jee-4.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd&quot;&gt; &lt;!-- 使用注解的包，包括子集 --&gt; &lt;context:component-scan base-package=&quot;cn.web.open.controller&quot; /&gt; &lt;!-- 开启注解 --&gt; &lt;mvc:annotation-driven/&gt; &lt;mvc:resources mapping=&quot;/static/**&quot; location=&quot;/static/&quot;/&gt; &lt;!-- 视图解析器 --&gt; &lt;bean id=&quot;viewResolver&quot; class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;prefix&quot; value=&quot;/&quot; /&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 文件上传解析器 id 必须为multipartResolver --&gt; &lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt; &lt;property name=&quot;defaultEncoding&quot; value=&quot;UTF-8&quot;/&gt; &lt;property name=&quot;maxUploadSize&quot; value=&quot;10000000&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; (5)数据源及整合配置applicationContext.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:jee=&quot;http://www.springframework.org/schema/jee&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd http://www.springframework.org/schema/jee http://www.springframework.org/schema/jee/spring-jee-4.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd&quot;&gt; &lt;!-- 配置数据源 ,连接池用的阿里druid--&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;!-- &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://IP+数据库&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;用户名&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;密码&quot;/&gt; --&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://121.42.57.186:3306/blog&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;shen200800&quot;/&gt; &lt;/bean&gt; &lt;!-- 配置mybatis的sqlSessionFactory --&gt; &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt; &lt;!-- 自动扫描mappers.xml文件 --&gt; &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:mappers/*.xml&quot;&gt;&lt;/property&gt; &lt;!-- mybatis配置文件 --&gt; &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- DAO接口所在包名，Spring会自动查找其下的类 --&gt; &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; &lt;property name=&quot;basePackage&quot; value=&quot;cn.web.open.dao&quot; /&gt; &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- (事务管理)transaction manager, use JtaTransactionManager for global tx --&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt; &lt;/bean&gt; &lt;!-- 5. 使用声明式事务 transaction-manager：引用上面定义的事务管理器--&gt; &lt;tx:annotation-driven transaction-manager=&quot;txManager&quot; /&gt; &lt;!-- 配置事务通知属性 --&gt; &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt; &lt;!-- 定义事务传播属性 --&gt; &lt;tx:attributes&gt; &lt;tx:method name=&quot;insert*&quot; propagation=&quot;REQUIRED&quot; /&gt; &lt;tx:method name=&quot;update*&quot; propagation=&quot;REQUIRED&quot; /&gt; &lt;tx:method name=&quot;edit*&quot; propagation=&quot;REQUIRED&quot; /&gt; &lt;tx:method name=&quot;save*&quot; propagation=&quot;REQUIRED&quot; /&gt; &lt;tx:method name=&quot;add*&quot; propagation=&quot;REQUIRED&quot; /&gt; &lt;tx:method name=&quot;new*&quot; propagation=&quot;REQUIRED&quot; /&gt; &lt;tx:method name=&quot;set*&quot; propagation=&quot;REQUIRED&quot; /&gt; &lt;tx:method name=&quot;remove*&quot; propagation=&quot;REQUIRED&quot; /&gt; &lt;tx:method name=&quot;delete*&quot; propagation=&quot;REQUIRED&quot; /&gt; &lt;tx:method name=&quot;change*&quot; propagation=&quot;REQUIRED&quot; /&gt; &lt;tx:method name=&quot;check*&quot; propagation=&quot;REQUIRED&quot; /&gt; &lt;tx:method name=&quot;get*&quot; propagation=&quot;REQUIRED&quot; read-only=&quot;true&quot; /&gt; &lt;tx:method name=&quot;find*&quot; propagation=&quot;REQUIRED&quot; read-only=&quot;true&quot; /&gt; &lt;tx:method name=&quot;load*&quot; propagation=&quot;REQUIRED&quot; read-only=&quot;true&quot; /&gt; &lt;tx:method name=&quot;*&quot; propagation=&quot;REQUIRED&quot; read-only=&quot;true&quot; /&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!-- 配置事务切面 --&gt; &lt;aop:config&gt; &lt;aop:pointcut id=&quot;serviceOperation&quot; expression=&quot;execution(* cn.web.open.service.*.*(..))&quot; /&gt; &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;serviceOperation&quot; /&gt; &lt;/aop:config&gt; &lt;!-- 自动扫描 --&gt; &lt;context:component-scan base-package=&quot;cn.web.open.service&quot; /&gt;&lt;/beans&gt; 2、工程结构(1)分层结构 (2)实体类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package cn.web.open.model;import java.util.Date;public class User &#123; private String userCode; private String userName; private String userPwd; private String email; private String address; private Date userBorn; public String getUserCode() &#123; return userCode; &#125; public void setUserCode(String userCode) &#123; this.userCode = userCode; &#125; public String getUserName() &#123; return userName; &#125; public void setUserName(String userName) &#123; this.userName = userName; &#125; public String getUserPwd() &#123; return userPwd; &#125; public void setUserPwd(String userPwd) &#123; this.userPwd = userPwd; &#125; public String getEmail() &#123; return email; &#125; public void setEmail(String email) &#123; this.email = email; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125; public Date getUserBorn() &#123; return userBorn; &#125; public void setUserBorn(Date userBorn) &#123; this.userBorn = userBorn; &#125; &#125; dao接口 123456package cn.web.open.dao;import cn.web.open.model.User;public interface UserDao &#123; User findById(String code,String pwd);&#125; service接口 1234567package cn.web.open.service;import cn.web.open.model.User;public interface UserService &#123; User findById(String code,String pwd);&#125; service实现类,@Resource注入dao 12345678910111213141516171819package cn.web.open.service.impl;import javax.annotation.Resource;import org.springframework.stereotype.Service;import cn.web.open.dao.UserDao;import cn.web.open.model.User;import cn.web.open.service.UserService;@Service(&quot;userService&quot;)public class UserServiceImpl implements UserService&#123; @Resource private UserDao userDao; public User findById(String code,String pwd) &#123; User user = userDao.findById(code,pwd); return user; &#125;&#125; 控制器controller 12345678910111213141516171819202122232425262728293031323334package cn.web.open.controller;import javax.annotation.Resource;import javax.servlet.http.HttpServletRequest;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;import cn.web.open.model.User;import cn.web.open.service.UserService;@Controller//@RequestMapping(&quot;/user&quot;)public class UserController &#123; @Resource private UserService userService; @RequestMapping(&quot;/login&quot;) public String login(HttpServletRequest request, Model model) &#123; String code = request.getParameter(&quot;usercode&quot;); String pwd = request.getParameter(&quot;password&quot;); User user_login = userService.findById(code,pwd); System.out.println(&quot;---&gt;&quot;+user_login); if (null == user_login) &#123; System.out.println(&quot;Error login!&quot;); return &quot;redirect:index.jsp?oper=error&quot;; &#125; else &#123; model.addAttribute(&quot;user&quot;, user_login); return &quot;pages/success&quot;; &#125; &#125;&#125; sql语句文件mappers/userMapper.xml 1234567891011121314151617181920&lt;pre name=&quot;code&quot; class=&quot;html&quot;&gt;&lt;pre name=&quot;code&quot; class=&quot;html&quot;&gt;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;cn.web.open.dao.UserDao&quot;&gt; &lt;resultMap type=&quot;User&quot; id=&quot;UserResult&quot;&gt; &lt;result column=&quot;USER_CODE&quot; property=&quot;userCode&quot; /&gt; &lt;result column=&quot;USER_NAME&quot; property=&quot;userName&quot; /&gt; &lt;result column=&quot;USER_PWD&quot; property=&quot;userPwd&quot; /&gt; &lt;/resultMap&gt; &lt;!-- 查询条件:账号密码用户类型. 0第一个参数,1第二个参数,对应dao接口参数 --&gt; &lt;select id=&quot;findById&quot; parameterType=&quot;String&quot; resultMap=&quot;UserResult&quot;&gt; SELECT USER_CODE,USER_NAME,USER_PWD FROM BLOG_USER WHERE USER_CODE=#&#123;0&#125; AND USER_PWD=#&#123;1&#125; AND USER_TYPE=2 &lt;/select&gt; &lt;!-- &lt;select id=&quot;getAllUsers&quot; resultMap=&quot;userResult&quot;&gt; SELECT USER_CODE,USER_NAME,USER_PWD,CREATE_DATE FROM BLOG_USER &lt;/select&gt; --&gt;&lt;/mapper&gt; (3)前台的一些测试页面WEB_INF下文件不能通过URL直接访问,登录页面网上拿了别人做了一个页面，挺有趣的，访问工程地址,端口你自己配的,输入管理员类型的账号测试刚开始对于各种注解的使用不甚了解鼓捣了许久,用maven管理项目构建时也碰到许多小问题，着实查了许多资料,下过别人的demo参考，总算是把ssm这一套搭起来了，如果发现有问题，请留言指教。demo下载http://download.csdn.net/detail/u012809062/9486330","tags":[{"name":"spring","slug":"spring","permalink":"http://javazgs.com/tags/spring/"}]},{"title":"MySQL入门接触记录--从安装到Java通过JDBC连接MySQL数据库","date":"2015-12-11T16:00:00.000Z","path":"2015/12/12/MySQL入门接触记录--从安装到Java通过JDBC连接MySQL数据库/","text":"一、安装MySQL1.本人用的版本是mysql-5.6.24-winx64解压免装版，链接：http://xiazai.zol.com.cn/detail/4/33431.shtml解压后找到my-default.ini文件，复制改名为my.ini，修改添加以下语句：[client]port=3306default-character-set=utf8 [mysqld]port=3306character_set_server=utf8 #以下路径为你解压到的文件夹basedir = D:\\Program Files\\mysql-5.6.24-winx64datadir = D:\\Program Files\\mysql-5.6.24-winx64\\datasql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES2.配置环境变量：计算机-属性-高级系统设置-高级-环境变量，在Path中添加D:\\Program Files\\mysql-5.6.24-winx64\\bin路径依然根据自己所解压到的路径决定，注意添加时前面用；分号隔开。3.win+r进dos，cd到解压文件目录的bin文件下安装服务：mysqld -install启动服务:net start mysql如果要删除服务，命令为：mysqld -remove安装结束———- 二、创建数据库和表以一个简单例子为例，步骤如下:win+r进dos并cd到解压路径的bin文件下，执行mysql -uroot -p因为初始密码为空，直接回车，如图 show databases; 显示目前所有的数据库create database 库名; 因为之前person已经创建过，所有提示存在创建完我们使用它，use person; 接着创建一个表名student的表,有两个简单的属性, 命令:create table &lt;表名&gt; (&lt;字段名 1&gt; &lt;类型 1&gt; [,..&lt;字段名 n&gt; &lt;类型 n&gt;]); 具体如下: 查看表结构命令: show columns from 表名;插入数据命令:insert into &lt;表名&gt; [( &lt;字段名 1&gt;[,..&lt;字段名 n &gt; ])] values ( 值 1 )[, ( 值 n )]以下随便插入两个select * from 表名; 显示表所有内容 三、在eclipse上通过JDBC连接MySQl数据库1.下载对应MySQL的驱动包 http://dev.mysql.com/downloads/connector/j/解压驱动包，eclipse新建一个java工程MysqlDemo，复制驱动包的.jar文件，在java工程右键paste，接着在.jar包右键Build Path - Configure Build Path,这样驱动就加载进来了 测试程序参考自http://qq163230530.blog.163.com/blog/static/4289250620081186262719/12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import java.sql.*;public class MysqlDemo &#123; public static void main(String[] args) &#123; //声明Connection对象 Connection con; //驱动程序名 String driver = \"com.mysql.jdbc.Driver\"; //URL指向要访问的数据库名mydata String url = \"jdbc:mysql://localhost:3306/person\"; //MySQL配置时的用户名 String user = \"root\"; //MySQL配置时的密码 String password = \"\"; //遍历查询结果集 try &#123; //加载驱动程序 Class.forName(driver); //1.getConnection()方法，连接MySQL数据库！！ con = DriverManager.getConnection(url,user,password); if(!con.isClosed()) System.out.println(\"Succeeded connecting to the Database!\"); //2.创建statement类对象，用来执行SQL语句！！ Statement statement = con.createStatement(); //要执行的SQL语句 String sql = \"select * from student\"; //3.ResultSet类，用来存放获取的结果集！！ ResultSet rs = statement.executeQuery(sql); System.out.println(\"-----------------\"); System.out.println(\"执行结果如下所示:\"); System.out.println(\"-----------------\"); System.out.println(\" 学号\" + \"\\t\" + \" 姓名\"); System.out.println(\"-----------------\"); String name = null; String id = null; while(rs.next())&#123; //获取stuname这列数据 name = rs.getString(\"name\"); //获取stuid这列数据 id = rs.getString(\"id\"); //首先使用ISO-8859-1字符集将name解码为字节序列并将结果存储新的字节数组中。 //然后使用GB2312字符集解码指定的字节数组。 name = new String(name.getBytes(\"ISO-8859-1\"),\"gb2312\"); //输出结果 System.out.println(id + \"\\t\" + name); &#125; rs.close(); con.close(); &#125; catch(ClassNotFoundException e) &#123; //数据库驱动类异常处理 System.out.println(\"Sorry,can`t find the Driver!\"); e.printStackTrace(); &#125; catch(SQLException e) &#123; //数据库连接失败异常处理 e.printStackTrace(); &#125;catch (Exception e) &#123; // TODO: handle exception e.printStackTrace(); &#125;finally&#123; System.out.println(\"数据库数据成功获取！！\"); &#125; &#125;&#125; run结果 印象流程大概这样，水平有限，记录。","tags":[{"name":"数据库","slug":"数据库","permalink":"http://javazgs.com/tags/数据库/"}]},{"title":"opencv简单的彩色图像灰度化和二值化（学习笔记）","date":"2015-05-03T16:00:00.000Z","path":"2015/05/04/opencv简单的彩色图像灰度化和二值化（学习笔记）/","text":"图像的灰度化即是将彩色图像转化成为灰度图像的过程成为图像的灰度化处理。彩色图像中的每个像素的颜色有R、G、B三个分量决定，而每个分量有255中值可取，这样一个像素点可以有1600多万（255255255）的颜色的变化范围。而灰度图像是R、G、B三个分量相同的一种特殊的彩色图像，其一个像素点的变化范围为255种，所以在数字图像处理种一般先将各种格式的图像转变成灰度图像以使后续的图像的计算量变得少一些。灰度图像的描述与彩色图像一样仍然反映了整幅图像的整体和局部的色度和亮度等级的分布和特征。图像的灰度化处理可用两种方法来实现。 图像的二值化是将图像上的像素点的灰度值设置为0或255，也就是将整个图像呈现出明显的黑白效果。要对RGB彩色图像进行二值化一般首先要对图像进行灰度化处理。例子12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061 #include \"cv.h\" #include \"highgui.h\" #include &lt;cvaux.h&gt; int main(int argc, char *argv[]) &#123; IplImage* img; IplImage* img0; IplImage* img1; img = cvLoadImage(\"test.jpg\");//默认初始图像放在工程文件下 //IplImage* img1 = img; if (NULL == img) return 0;//灰度化操作 img0 = cvCreateImage(cvGetSize(img),IPL_DEPTH_8U,1);//申请一段内存 cvCvtColor(img,img0,CV_BGR2GRAY);//图像数据复制 img1 = cvCreateImage(cvGetSize(img),IPL_DEPTH_8U,1);//申请一段内存 cvCopy(img0, img1, NULL);//数据复制，若直接赋值相当指针指向同一地址会对原本img0操作//二值化操作 int height = img1-&gt;height; int width = img1-&gt;width; int step = img1-&gt;widthStep; int channels = img1-&gt;nChannels; uchar *data = (uchar*)img1-&gt;imageData; for(int i=0;i != height; ++ i) &#123; for(int j=0;j != width; ++ j) &#123; for(int k=0;k != channels; ++ k) &#123; if(data[i*step+j*channels+k]&lt;128) data[i*step+j*channels+k]=0;//255-data[i*step+j*channels+k]; else data[i*step+j*channels+k]=255;//255-data[i*step+j*channels+k]; &#125; &#125; &#125;//创建窗口、显示图像、销毁图像、释放图像 cvNamedWindow( \"test1\", 0 ); cvShowImage(\"test1\", img0); cvNamedWindow( \"test\", 0 ); cvShowImage(\"test\", img1); cvWaitKey(0); cvDestroyWindow( \"test1\" ); cvDestroyWindow( \"test\" ); cvReleaseImage( &amp;img0 ); cvReleaseImage( &amp;img1 ); return 0; &#125;","tags":[{"name":"其他","slug":"其他","permalink":"http://javazgs.com/tags/其他/"}]},{"title":"avr单片机三种时钟模式","date":"2015-05-03T16:00:00.000Z","path":"2015/05/04/avr单片机三种时钟模式/","text":"AVR单片机时钟有三种模式：1、内部时钟源，可分为内部晶振和外部晶振，用的是单片机内部的振荡电路。内部晶振可以设置1M、2M、4M、8MHz晶振频率，外部可支持到16MHz（MEGA16或者MEGA16A）MEGA16L可支持最高8MHz的外部晶振（通过熔丝设置）。2、外部时钟源，靠外部振荡电路提供时钟，可以用外部同步时钟信号（如用其他单片机提供时钟）或者外部振荡器（如有源晶振）将此信号接到单片机XTAL1端口，熔丝设置为外部时钟即可（不是外部晶振）。3、设置晶振熔丝错误会导致芯片锁死，如果设置为外部晶振，直接加晶振即可解除，设置为外部时钟源，那只好提供外部时钟才能解除（有源晶振）。","tags":[{"name":"其他","slug":"其他","permalink":"http://javazgs.com/tags/其他/"}]}]