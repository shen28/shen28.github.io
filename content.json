{"meta":{"title":"zgshen's notes","subtitle":null,"description":null,"author":"zgshen","url":"https://zgshen.me"},"pages":[{"title":"关于","date":"2019-03-03T14:15:49.599Z","updated":"2019-03-03T14:15:49.599Z","comments":false,"path":"about/index.html","permalink":"https://zgshen.me/about/index.html","excerpt":"","text":"Java后端开发者2016年7月毕业于广大本站只用于记录个人各类琐碎的想法，做做笔记联系我 zguishen@foxmail.com"},{"title":"历史","date":"2019-03-03T14:33:12.216Z","updated":"2019-03-03T14:33:12.216Z","comments":false,"path":"history/index.html","permalink":"https://zgshen.me/history/index.html","excerpt":"","text":""}],"posts":[{"title":"省博物馆","slug":"广东博物馆","date":"2020-07-15T16:00:00.000Z","updated":"2020-07-20T02:41:39.368Z","comments":true,"path":"2020/07/16/广东博物馆/","link":"","permalink":"https://zgshen.me/2020/07/16/广东博物馆/","excerpt":"之前去广东省博物馆古生物馆没开放，没看着恐龙，这次总算看到了。","text":"之前去广东省博物馆古生物馆没开放，没看着恐龙，这次总算看到了。","categories":[{"name":"生活","slug":"生活","permalink":"https://zgshen.me/categories/生活/"}],"tags":[{"name":"其他","slug":"其他","permalink":"https://zgshen.me/tags/其他/"}]},{"title":"2020年3月","slug":"2020年3月","date":"2020-03-26T16:00:00.000Z","updated":"2020-07-20T07:57:45.342Z","comments":true,"path":"2020/03/27/2020年3月/","link":"","permalink":"https://zgshen.me/2020/03/27/2020年3月/","excerpt":"现在已经是20年的三月份了，又大半年没有写什么东西了，三月本来按计划是准备跳槽重新找机会。但这半年发生太多的事情，新冠疫情依然严重，相信很多人的计划都被打乱了。","text":"现在已经是20年的三月份了，又大半年没有写什么东西了，三月本来按计划是准备跳槽重新找机会。但这半年发生太多的事情，新冠疫情依然严重，相信很多人的计划都被打乱了。 去年9月初婆婆去世，得知消息居然没有那么多悲伤，更多的是麻木了，人说没就没了，而我们什么也做不了。每次想起家人的离去还是难受，奶奶是最疼我最关心我的人，每逢节日都会问我回不回家，而我平常却很少打电话问好，现在想起来甚是后悔。 9月份公司部门旅游我没心情参加，这段时间以来每天浑浑噩噩,上班都要应对处理各类乱七八糟的需求，下班也需要应对线上随时可能出现的问题，甲方越来越离谱，上班不开心，很不开心，不该在外包项目待这么长时间。想忍到新年过后离职重新找工作，结果新冠疫情爆发，各地封锁甚至封城，各行业有的停产有的关门，大量线下门店因此破产倒闭。进而导致许多人都降薪或者被裁了。相反的某些互联网线上业务却因此火爆起来，这段时间在家办公，加班加点赶项目反而比在公司上班更累，007工作时间，24小时 on call ，还好目前疫情总算稳定，可以到公司上班了。新年就如此艰难，2020注定给人们留下深刻的记忆。","categories":[{"name":"生活","slug":"生活","permalink":"https://zgshen.me/categories/生活/"}],"tags":[{"name":"其他","slug":"其他","permalink":"https://zgshen.me/tags/其他/"}]},{"title":"Mysql清除错误临时表","slug":"mysql清除错误临时表","date":"2019-09-25T16:00:00.000Z","updated":"2019-09-29T14:25:51.612Z","comments":true,"path":"2019/09/26/mysql清除错误临时表/","link":"","permalink":"https://zgshen.me/2019/09/26/mysql清除错误临时表/","excerpt":"去年对数据库一个大表做了 optimize 操作，由于不了解具体操作就草草执行了。此操作会拷贝原表数据到临时表，如果此时硬盘空间不够，就会报错，或者表太大，执行时间将及其漫长，反正哪种都是不可接受的。","text":"去年对数据库一个大表做了 optimize 操作，由于不了解具体操作就草草执行了。此操作会拷贝原表数据到临时表，如果此时硬盘空间不够，就会报错，或者表太大，执行时间将及其漫长，反正哪种都是不可接受的。这是当时的日志 当时就把进程 kill 掉了，但是留下了一个 75G 没有用的临时表，后来因为服务器加了硬盘空间，就没有去管它。最近硬盘又快占满，这个 75G 废弃文件实在碍眼，就着手看看怎么安全删除。 首先暴力 rm 必定不可取，参考互联网资料，这个应该是官方的一个解决方案https://mariadb.com/resources/blog/get-rid-of-orphaned-innodb-temporary-tables-the-right-way/ 试着按参考链接执行建同名表，正常建表命令肯定不会影响数据库，找到原来的表结构建表CREATE TABLE #sql-5df6_36c ( id bigint(32) NOT NULL AUTO_INCREMENT, card varchar(50) DEFAULT NULL COMMENT ‘卡券号’, createTime datetime DEFAULT NULL COMMENT ‘创建时间’, status varchar(1) DEFAULT NULL COMMENT ‘状态’, posData text COMMENT ‘POS请求的数据’, ffData text COMMENT ‘飞凡返回的data’, reason varchar(500) DEFAULT NULL, PRIMARY KEY (id), KEY card_index (card)) ENGINE=InnoDB AUTO_INCREMENT=152943355 DEFAULT CHARSET=utf8; 结果残缺的 #sql-5df6_36c.frm 被自动删掉 接下来剩下缺失表结构的大文件cp cc_card_log.frm /app/mysql/data/watsons_coupon/#sql-ib2460-3936078760.frm复制表结构命名与临时表相同 再 drop 表，提示表不存在 先再建表 可以看到与临时表同名多会生成这两个文件，原来的两个文件也还在的 再试试 drop 表 发现不行，四个文件都还在再尝试 @0023sql@002dib2460@002d3936078760 两个文件倒是删掉了 #sql-ib2460-3936078760 两个还好好的仔细一看 #sql-ib2460-3936078760.frm 用户组用户都是 root ，cp 的时候用了 sudo 执行，需要授权用户 chown mysql:mysql #sql-ib2460-3936078760.frm 再 drop 表 75G文件5s多drop掉，总算删掉了","categories":[{"name":"技术","slug":"技术","permalink":"https://zgshen.me/categories/技术/"}],"tags":[{"name":"技术","slug":"技术","permalink":"https://zgshen.me/tags/技术/"}]},{"title":"20190812-20190819","slug":"20190812-20190819周报","date":"2019-08-18T16:00:00.000Z","updated":"2020-07-19T14:18:25.312Z","comments":true,"path":"2019/08/19/20190812-20190819周报/","link":"","permalink":"https://zgshen.me/2019/08/19/20190812-20190819周报/","excerpt":"","text":"《漫威蜘蛛侠》白金纪念。能力越大，责任越大。","categories":[{"name":"生活","slug":"生活","permalink":"https://zgshen.me/categories/生活/"}],"tags":[{"name":"其他","slug":"其他","permalink":"https://zgshen.me/tags/其他/"}]},{"title":"20190805-20190811周报","slug":"20190805-20190811周报","date":"2019-08-11T16:00:00.000Z","updated":"2019-08-14T09:34:45.255Z","comments":true,"path":"2019/08/12/20190805-20190811周报/","link":"","permalink":"https://zgshen.me/2019/08/12/20190805-20190811周报/","excerpt":"","text":"最近公司的版本管理工具从 svn 迁移到 git ，总算告别了五六个需求混在一起，只上线部分的麻烦问题。不够 git 毕竟不熟悉，经常切着分支就搞错了，什么变基操作，fetch、merge 和 pull 的用法区别等等其他东西的还是很生疏。 离职真需要下很大的决心，几个月之前就一直想要离职了，想着准备好出去面试一波。但是准备准备着就懈怠了，一天工作下来晚上根本就不想动了。叫我再去学习敲代码刷 LeetCode 太累了，刷番剧看沙雕视频喝快乐水实在太快乐了233，但是一想到工资就快乐不起来了。 最近流行玩蚂蚁森林养小鸡，同事纷纷加我好友，嗯，好吧，小鸡天天被揍，能量天天被头。他们玩得也太疯了吧，还买摇步器刷步数攒能量，还抓那啥妖怪来的。 电视剧《长安十二时辰》已经播到尾声了，这部剧大家都夸道具化妆太好了，力求还原唐时代元素。随着剧情的发展，人物的刻画也逐渐鲜明，可以看到大家对龙波（萧规）和张小敬的态度反转，从一开始认为龙波是个来破环长安的坏人，慢慢地理解他的行为，而张小敬的行为反而慢慢不被理解，许多人都认为长安已经腐朽，不值得去守护了。但是，如果冷静下来看看两人的行为，龙波用现代的词语来说就是一个彻头彻尾的恐怖分子，不应该为他叫好。","categories":[{"name":"生活","slug":"生活","permalink":"https://zgshen.me/categories/生活/"}],"tags":[{"name":"其他","slug":"其他","permalink":"https://zgshen.me/tags/其他/"}]},{"title":"Nginx升级","slug":"Nginx升级","date":"2019-08-05T16:00:00.000Z","updated":"2019-08-26T15:53:13.806Z","comments":true,"path":"2019/08/06/Nginx升级/","link":"","permalink":"https://zgshen.me/2019/08/06/Nginx升级/","excerpt":"内网的nginx扫出几个漏洞，要求隐藏版本号，解决整型溢出问题，建议升级修补一下。","text":"内网的nginx扫出几个漏洞，要求隐藏版本号，解决整型溢出问题，建议升级修补一下。先 sudo su 用root权限，查看当前版本，再备份1234[root@CNINUATOTSWEB nginx-1.16.0]# /usr/local/nginx/sbin/nginx -Vnginx version: nginx/1.10.1built by gcc 4.4.7 20120313 (Red Hat 4.4.7-16) (GCC)configure arguments: 解压新版本 tar -zxvf nginx-1.16.0.tar.gz 配置参数（configure arguments后面的参数，没有不填） ./configure make 编译（完成之后切记别 make install） 备份旧版本（最重要的 conf文件 记得备份到本地） mv /usr/local/nginx/sbin/nginx /usr/local/nginx/sbin/nginx.old 复制 objs 下新版到 sbin 目录 cp objs/nginx /usr/local/nginx/sbin/ 最后执行 make upgrade 替换老的nginx进程 再执行 nginx -V 查看是否成功 隐藏版本号，编辑 nginx.conf, http 下加上server_tokens off;123456789101112http &#123; include mime.types; default_type application/octet-stream; server_tokens off; #log_format main &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos; # &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos; # &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;;...#以下略","categories":[{"name":"技术","slug":"技术","permalink":"https://zgshen.me/categories/技术/"}],"tags":[{"name":"nginx","slug":"nginx","permalink":"https://zgshen.me/tags/nginx/"}]},{"title":"20190729-20190804周报","slug":"20190729-20190804周报","date":"2019-08-03T16:00:00.000Z","updated":"2019-08-12T01:50:36.533Z","comments":true,"path":"2019/08/04/20190729-20190804周报/","link":"","permalink":"https://zgshen.me/2019/08/04/20190729-20190804周报/","excerpt":"打算自本周开始，每周都要记录过去的一周做了什么事情，内容包括职业技术上的事情和遇到的问题，但不限于生活上的各种琐事，或许平常生活内容才会更多，稳定的工作工作内容千篇一律。","text":"打算自本周开始，每周都要记录过去的一周做了什么事情，内容包括职业技术上的事情和遇到的问题，但不限于生活上的各种琐事，或许平常生活内容才会更多，稳定的工作工作内容千篇一律。 为什么要记录自从毕业以来已经快三年了，平时工作生活都是“两点一线“，早上做班车到公司上班，傍晚做班车回宿舍，而且是一个人(单身狗)生活。白天上班，晚上自闭玩主机游戏刷电视剧，突然想起一张图真是我的真实写照，”我一条狗，吃饭旅行，走走停停“。 真很难想象这样一直浑浑噩噩走下去会发生什么，或许会变成一个孤僻的疯子吧。最近在 v2 上看到站长新开的周报节点以及所写的一些观点，可以把自己一段时间的事情记录下来，即便是流水账的陈述也无妨。从日常记录引申出的所思所想，回顾一些之前的生活，证明我还活着，活得清楚，然后如何活得清楚简单，而不是一塌糊涂。 这周做了什么周一工作很快就做玩了，只是简单的查询页面和接口。下午和几个前同事的吃大餐聚会又鸽了，每个人都很忙啊，出来吃个饭都不好凑到刚好都有时间出来，就我一个闲人。 周二之后都没需求可做，想着一直以来都没系统学过 Linux ，遂找了下 鸟哥的私房菜 （找到的一个简体的镜像站）教程看看学学，不过相对的比较老了。 看了卓叔的增重微信公众号种草了增肌粉，许多年了想长胖都长不胖，死马当活马医，下单试试有没效果，增重需要配合锻炼，不知我能坚持多久。 在 PS4《漫威蜘蛛侠》中的纽约市荡来荡去实在太爽了，本体剧情也足够优秀，不过开坑一个月我才玩到40%进度，还好是线性剧情向游戏，通主线算休闲，白金看起来就有点蛋疼了，有些刷刷刷的任务真不想做。 周末翻出闲置的小米4C，想着能做什么用，做时钟，一直亮屏浪费电，而且小王子出了名的续航差，渣渣808处理器；想搞个 Linux 玩又用不着，云上已经有了，出公网也是问题，不想玩了；现在用的路由功能太简单，想拿来做全局路由折腾酸酸去广告，那我为什么不出掉换个新路由得了。然后我就把它闲鱼出掉了（笑哭），这还是我第一次用闲鱼，没多久就有人直接拍下付款，好快，难道我挂的价钱太好了么（3+32配置150出掉）。买家一看就是个二手贩子啊，不过信誉评价还可以，这次交易不知道会不会翻车呢……","categories":[{"name":"生活","slug":"生活","permalink":"https://zgshen.me/categories/生活/"}],"tags":[{"name":"其他","slug":"其他","permalink":"https://zgshen.me/tags/其他/"}]},{"title":"SpringBoot打包和部署(补充)","slug":"SpringBoot打包部署(补充)","date":"2019-01-01T16:00:00.000Z","updated":"2019-03-31T14:42:00.046Z","comments":true,"path":"2019/01/02/SpringBoot打包部署(补充)/","link":"","permalink":"https://zgshen.me/2019/01/02/SpringBoot打包部署(补充)/","excerpt":"","text":"SpringBoot 工程若用简单的 clean package 命令打包会包含所有依赖 jar 包，如果工程依赖比较多的时候，打的包通常动不动就几十 m 大。这使得在部署到远程的时候，如果你的网络是小水管的就要传半天了，而且上微服务的项目，多个工程，一个工程还多台机器，更新部署需要浪费许多时间。 SpringBoot 启动可以以加载外部依赖目录来启动工程，所以我不必每次打包都包含一堆 jar 包，只需要把 jar 统一放一个目录，启动时指定依赖目录启动就行。 在网上搜索各类资料和博客，大多以下方式打包。以 maven 打包为例，使用 SpringBoot 打包插件先正常打包12345678910111213141516171819202122232425262728&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;layout&gt;ZIP&lt;/layout&gt; &lt;includes&gt; &lt;!-- 依赖变化去掉打包重新传完jar包后再打开打包 --&gt; &lt;!-- &lt;include&gt; &lt;groupId&gt;nothing&lt;/groupId&gt; &lt;artifactId&gt;nothing&lt;/artifactId&gt; &lt;/include&gt; --&gt; &lt;/includes&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/**&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt;&lt;/build&gt; 打包后的目录结构，将 lib 目录的依赖包拷贝出来上传到服务器，依赖一般很少改动，若依赖改变重新传一次 打开 include nothing 的配置注释重新打包 1234&lt;include&gt; &lt;groupId&gt;nothing&lt;/groupId&gt; &lt;artifactId&gt;nothing&lt;/artifactId&gt;&lt;/include&gt; 打包后的文件，很小了，不用每次部署都传大文件 另外也可以直接用 maven maven-dependency-plugin 插件直接把 jar 包拷贝到目标目录，不需要去包里拷贝，更直接123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;layout&gt;ZIP&lt;/layout&gt; &lt;includes&gt; &lt;!-- 不含依赖 --&gt; &lt;include&gt; &lt;groupId&gt;nothing&lt;/groupId&gt; &lt;artifactId&gt;nothing&lt;/artifactId&gt; &lt;/include&gt; &lt;/includes&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;!-- 拷贝依赖jar包到target/lib --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-dependency-plugin&lt;/artifactId&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;copy-dependencies&lt;/id&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;copy-dependencies&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;type&gt;jar&lt;/type&gt; &lt;includeTypes&gt;jar&lt;/includeTypes&gt; &lt;includeScope&gt;runtime&lt;/includeScope&gt; &lt;outputDirectory&gt; $&#123;project.build.directory&#125;/lib &lt;/outputDirectory&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/**&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt;&lt;/build&gt; 启动指定 lib 目录，java -Dloader.path=/app/demo/lib -jar demo-*.jar以发行包和 lib 依赖目录都在 /app/demo 目录下为例，启动的参考脚本，jvm 及其他参数自行加上，注意你的进程名，别把其他进程也 kill 了12345678910111213141516171819202122232425262728293031323334#!/bin/shworkdir=/app/demostart() &#123; cd $workdir nohup java -Dloader.path=\"lib/\" -Xms512m -Xmx1024m -jar demo-*.jar &gt; demo.out 2&gt;&amp;1 &amp; echo \"demo service has started.\"&#125;stop() &#123; pid=`ps -ef | grep 'demo-' | grep -v grep | awk '&#123; print $2 &#125;'` echo $pid kill -9 $pid echo \"demo service has stoped.\"&#125;case \"$1\" in start) start ;; stop) stop ;; restart) stop start ;; *) echo \"Usage: ./demo.sh &#123;start|stop|restart&#125;\" exit 1esacexit 0 保存为 demo.sh授权755 chmod 755 demo.sh启动 ./demo.sh start查看日志输出 tail -20f /app/demo/demo.out","categories":[{"name":"技术","slug":"技术","permalink":"https://zgshen.me/categories/技术/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://zgshen.me/tags/Spring/"}]},{"title":"Mysql切换表和删除大表操作备忘","slug":"Mysql切换表和删除大表操作备忘","date":"2018-12-14T16:00:00.000Z","updated":"2019-03-31T14:44:07.955Z","comments":true,"path":"2018/12/15/Mysql切换表和删除大表操作备忘/","link":"","permalink":"https://zgshen.me/2018/12/15/Mysql切换表和删除大表操作备忘/","excerpt":"线上有一张日志表累计了太多数据，占用了服务器100多G的内存，需要把历史的数据清除掉，腾出空间。直接删除表的记录 Mysql 是不会自动归还硬盘空间的，需要对表进行 OPTIMIZE TABLE 优化操作归还空间，但此操作会长时间锁定表，不能在线上随便操作。","text":"线上有一张日志表累计了太多数据，占用了服务器100多G的内存，需要把历史的数据清除掉，腾出空间。直接删除表的记录 Mysql 是不会自动归还硬盘空间的，需要对表进行 OPTIMIZE TABLE 优化操作归还空间，但此操作会长时间锁定表，不能在线上随便操作。另一种方式就是新建一张新的表结构与日志表相同，把新的表表名互换，切到新表。之后就可以把占空间大的旧表删除，由于 drop 操作删除表会有锁影响数据库其他操作，而且如果是普通硬盘删除100多G数据也不会很快，会影响服务器IO操作。因此，删除大表一般使用网络上大多人推荐的建立硬链接来进行删除的方式。 切换表操作建表 cc_card_log_1206 ，结构与表 cc_card_log 完全相同,把表 cc_card_log_1206 相互切换表名 cc_card_log，锁写操作，互换表名，解锁。 1234LOCK TABLES cc_card_log WRITE, cc_card_log_1206 WRITE;ALTER TABLE cc_card_log RENAME TO cc_card_log_120601;ALTER TABLE cc_card_log_1206 RENAME TO cc_card_log;UNLOCK TABLES; 删除大表要删除的表已经很大 可以利用硬链接和 truncate 降低 drop table 对线上环境的影响创建方法都很简单：软链接（符号链接） ln -s source target硬链接 （实体链接）ln source target 使用此办法前提条件，需要开启独立表空间，如果是共享表空间无法使用改方法。查询 show variables like &#39;innodb_file_per%&#39;\\G，结果值是 ON 表明开启了。 开启独立表空间表文件就都是单独的 建立硬链接 ln cc_card_log_1206.ibd cc_card_log_1206.ibd.hdlk ，之后 cc_card_log_1206.ibd 的 INODES 属性变成了2，变成2之后 drop table 就不会直接把文件删除了，只是删除了链接，避免对数据库的影响，最后再把 cc_card_log_1206.ibd 删除掉就行了。 drop 删除表 物理上删除表，这里用 truncate 命令直接清空文件也可以，执行 truncate -s 0 cc_card_log_120601.ibd.hdlk","categories":[{"name":"技术","slug":"技术","permalink":"https://zgshen.me/categories/技术/"}],"tags":[{"name":"技术","slug":"技术","permalink":"https://zgshen.me/tags/技术/"}]},{"title":"域名更换注册商","slug":"域名更换服务商","date":"2018-10-13T16:00:00.000Z","updated":"2019-03-31T14:46:31.157Z","comments":true,"path":"2018/10/14/域名更换服务商/","link":"","permalink":"https://zgshen.me/2018/10/14/域名更换服务商/","excerpt":"域名不论是新注册、续费和转移，不同的注册商的定价和提供的服务都不一样。有些注册商对新注册域名有比较大的优惠，但续费的就不是那么便宜，还好域名是可以转移到别的注册商，所以给我们的选择就比较多了。","text":"域名不论是新注册、续费和转移，不同的注册商的定价和提供的服务都不一样。有些注册商对新注册域名有比较大的优惠，但续费的就不是那么便宜，还好域名是可以转移到别的注册商，所以给我们的选择就比较多了。 一般在哪个注册商注册域名考虑的方面有：价格：要快速知道各注册商的域名定价，可以到一些域名比较网站看看，比如 www.domcomp.com ；备案情况：许多人建博客喜欢用 .me、.im 域名，但这些域名现在国内是无法备案的，所以只能选择国外的注册商；whois ：不少注册商都有提供免费的 whois 隐私保护功能；dns ：域名解析功能，不同注册商也有所区别。例如这次我从 Namecheap 转到 Porkbun ，Porkbun 并没有找到二级域名重定向到顶级域名功能，比如把 www 定向到顶级域名，只支持重定向到另一个域名。 一般域名的转移步骤都是一样的：首先原注册商解锁域名，停掉 whois ；然后就是 transfer 操作了，注册商会给你生成一个转让授权码；接着到新的注册商进行转入，需要用到原注册商授权码；最后一般等个5天，如果原注册商一直没确认，你的域名就会就会自动转到新的注册商，当然有的注册商有给你转出同意的选择就比较快。所以照这个时间，转移域名一般在到期前的一周操作就行。 这次 transfer 只买了一年，选择了 Porkbun 。","categories":[{"name":"技术","slug":"技术","permalink":"https://zgshen.me/categories/技术/"}],"tags":[{"name":"其他","slug":"其他","permalink":"https://zgshen.me/tags/其他/"}]},{"title":"星球大战","slug":"星球大战","date":"2018-02-22T16:00:00.000Z","updated":"2019-03-31T14:46:41.525Z","comments":true,"path":"2018/02/23/星球大战/","link":"","permalink":"https://zgshen.me/2018/02/23/星球大战/","excerpt":"","text":"趁着春节，把星球大战系列电影刷了一遍，除了最后一部《星球大战：最后的绝地武士》还没正版资源，所以还没看。星战电影拍摄时间线比较有意思的是先拍了正传的三部，后来才补全拍的几部前传。虽然从1977年正传第一部到2017年第八部，跨度40年，电影技术与时俱进，但早年的几部也经过了重制，特效和观影效果不至于看起来太尴尬。系列电影让人感触的是，随着一部部作品的发展，角色的命运也被慢慢揭示。甚至，扮演这些角色的演员，由于他们所扮演的角色成为自己的另一个符号，被世人所熟知，比如我们的莱亚公主。而且，他们的命运也跟戏里的角色有了关联，这样想起来，编剧也是个不得了的工作呢。","categories":[{"name":"生活","slug":"生活","permalink":"https://zgshen.me/categories/生活/"}],"tags":[{"name":"其他","slug":"其他","permalink":"https://zgshen.me/tags/其他/"}]},{"title":"天河公园","slug":"tianhe","date":"2017-10-07T16:00:00.000Z","updated":"2019-03-31T14:45:52.301Z","comments":true,"path":"2017/10/08/tianhe/","link":"","permalink":"https://zgshen.me/2017/10/08/tianhe/","excerpt":"","text":"跑跑步…","categories":[{"name":"生活","slug":"生活","permalink":"https://zgshen.me/categories/生活/"}],"tags":[{"name":"其他","slug":"其他","permalink":"https://zgshen.me/tags/其他/"}]},{"title":"闭包","slug":"闭包","date":"2017-09-11T16:00:00.000Z","updated":"2019-03-03T14:49:43.088Z","comments":true,"path":"2017/09/12/闭包/","link":"","permalink":"https://zgshen.me/2017/09/12/闭包/","excerpt":"在Web开发中，在使用JavScript时，就算没用过，也听说过闭包这个名词。闭将外部作用域中的局部变量封闭起来的函数成为闭包，本质就是一个函数。","text":"在Web开发中，在使用JavScript时，就算没用过，也听说过闭包这个名词。闭将外部作用域中的局部变量封闭起来的函数成为闭包，本质就是一个函数。闭包的作用 保护函数内变量的安全，不能被外部随意修改，只能通过制定函数接口操作 在内存中维持变量，不会被销毁，所以弊端是滥用可能造成内存泄漏 例子123456789101112131415function fun() &#123; var num = 9; add = function() &#123; num++; &#125; function clo() &#123; return num; &#125; return clo;&#125;//add();//这里还不能执行var f = fun();//获得闭包函数add();//操作num的值var value = f();//执行函数获取局部变量num的值 11 以上例子最终的 value 值就是局部变量 num 的值， clo 函数就是闭包。我们无法直接访问 num 变量，但根据Javascript的链式作用域，对于 clo ， fun 内部的所有内部变量都是可见的，所以只要把 clo 作为返回值就可以在外部访问 num 内部变量了。add 函数在这里是一个全局变量，在Javascript中，在函数中变量定义不加上 var 或者其他类型，会被视为全局变量，但要在函数执行后得到声明才能使用，如下123456function test() &#123; var i = 1;//局部 j = 2;//全局，执行test函数时声明，之后全局可用&#125;test();console.log(j) 所以在 fun 函数执行后声明完成，就可以在外部执行，由于闭包 clo 维持了 num 变量，所以在外部 add 函数修改的 num 跟在 fun 函数中 num 的是同一个。 事实上， num 变量在函数中有点类似 Java 中的私有变量，外部不能直接访问，而需要函数内部其他方法访问。以函数对象写另一个例子123456789101112131415161718var fun = function() &#123; var age = 23; var name = \"shen\"; this.getAge = function() &#123; return age; &#125; this.getName = function() &#123; return name; &#125; this.setAge = function() &#123; age++; &#125;&#125;var ff = new foo();//ff.age;//访问不到局部变量ff.setAge();console.log(ff.getAge())//24console.log(ff.getName())//shen 在 Java 中，也有类似的闭包实现存在，匿名内部类就是一个例子，它可以访问外部类的成员变量（相当于第一个例子的clo函数可以访问fun函数的num变量）。但是，由于Java无法保证内部类使用的外部类的局部变量在内外部类同步都指向同一基本类型数据或对象，因为Java只是把外部类的变量做一个拷贝丢给了内部类另一个变量而已。所以，只能干脆限制在内部类访问的外部类变量必须定义为 final 类型，即初始化后就不能修改接口123public interface Cat&#123; public void eat();&#125; 测试类123456789101112131415161718192021222324252627public class Test &#123; public void eatSomething() &#123; //final int num = 10; int num = 10;//final默认可以不写，但当你尝试对num进行操作，比如num++之类，编译器会报错（环境Java8） Cat a = new Cat() &#123; @Override public void eat() &#123; System.out.println(\"eat \" + num + \" fish\");//访问外部num变量 &#125; &#125;; a.eat(); &#125; //Java8支持更简便的Lambda表达式 public void LambdaEatTest() &#123; int num = 10; Cat cat = ()-&gt;System.out.println(\"eat \" + num + \" fish\"); cat.eat(); &#125; public static void main(String[] args) &#123; new Test().eatSomething(); new Test().LambdaEatTest(); &#125;&#125; 因此，也有些人认为Java的闭包不能算是真正意义上的闭包，有不可修改外部变量的限制。","categories":[{"name":"技术","slug":"技术","permalink":"https://zgshen.me/categories/技术/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"https://zgshen.me/tags/Java基础/"}]},{"title":"RESTful API开发的简单应用","slug":"RESTful API 开发","date":"2017-09-01T16:00:00.000Z","updated":"2019-03-03T14:47:21.871Z","comments":true,"path":"2017/09/02/RESTful API 开发/","link":"","permalink":"https://zgshen.me/2017/09/02/RESTful API 开发/","excerpt":"在很早之前接触 Spring MVC 的时候，都知道 Spring MVC 支持 RESTful 风格API的开发，但对于 RESTful 只是有个模糊的认识，以至于甚至在开发写出来的接口其实不符合 RESTful 的要求。 定义REST 的全称是 Resource Representational State Transfer ，资源以某种表现形式进行状态转移Resource：资源，即数据；Representational：某种表现形式，比如用JSON，XML，JPEG等；State Transfer：状态变化。通过HTTP动词实现。","text":"在很早之前接触 Spring MVC 的时候，都知道 Spring MVC 支持 RESTful 风格API的开发，但对于 RESTful 只是有个模糊的认识，以至于甚至在开发写出来的接口其实不符合 RESTful 的要求。 定义REST 的全称是 Resource Representational State Transfer ，资源以某种表现形式进行状态转移Resource：资源，即数据；Representational：某种表现形式，比如用JSON，XML，JPEG等；State Transfer：状态变化。通过HTTP动词实现。HTTP动词有如下几个： GET 用来获取资源， POST 用来新建资源（也可以用于更新资源）， PUT 用来更新资源， DELETE 用来删除资源 在RESTful API中，URL中只使用名词来指定资源，原则上不使用动词，并且一般使用复数，比如 GET 操作 https://v1/users/1 来获取用户id为1的信息资源，禁止使用 http://v1/getUserById 、 http://v1/deleteUser 之类的url。 用处一种技术的存在肯定是为了解决一些问题而诞生的，REST是一种软件架构模式，通过使用RESTful 风格的 API 用来解决多端（PC、Android、IOS）共用一套统一的 API ，避免重复开发。 在 SpringMVC 中的应用用 SpringMVC 可以开发 restful 风格的restful api，以 Spring Boot 为基本框架，这里写一个基本的 controller 类1234567891011121314151617181920212223242526272829303132333435@RestController@RequestMapping(\"/users\")public class UserController &#123; @Autowired UserService userService; @RequestMapping(value=\"&#123;id&#125;\", method=RequestMethod.GET) public String getUserById(@PathVariable(\"id\") String userId) &#123; return ResultUtil.success(userService.getUserById(userId), \"操作成功\"); &#125; @RequestMapping(value=\"&#123;id&#125;\", method=RequestMethod.PUT) public String updateUser(@PathVariable(\"id\") String userId) &#123; int num = userService.updateUser(userId); if (1==num)&#123; return ResultUtil.success(\"操作成功\"); &#125; else return ResultUtil.error(\"操作失败\"); &#125; @RequestMapping(method=RequestMethod.POST) public String insertUser(String userCode, String userName) &#123; int num = userService.insertUser(userCode, userName); if (1==num)&#123; return ResultUtil.success(\"操作成功\"); &#125; else return ResultUtil.error(\"操作失败\"); &#125; @RequestMapping(value=\"&#123;id&#125;\", method=RequestMethod.DELETE) public String deleteUser(@PathVariable(\"id\") String userId) &#123; int num = userService.deleteUser(userId); if (1==num)&#123; return ResultUtil.success(\"操作成功\"); &#125; else return ResultUtil.error(\"操作失败\"); &#125;&#125; ResultUtil 封装返回数据格式，这里只是一个简单的封装1234567891011121314151617181920212223242526272829303132333435363738public class ResultUtil &#123; private final static String SUCCESS = \"success\"; private final static String MSG = \"msg\"; private final static String DATA = \"data\"; public static String success(String msg)&#123; Map&lt;String,Object&gt; result = new HashMap&lt;String,Object&gt;(); result.put(SUCCESS, true); result.put(MSG, msg); result.put(DATA, new Object()); return JSON.toJSONString(result); &#125; public static String success(Object data, String msg)&#123; Map&lt;String,Object&gt; result = new HashMap&lt;String,Object&gt;(); result.put(SUCCESS, true); result.put(MSG, msg); result.put(DATA, data); return JSON.toJSONString(result); &#125; public static String error(String msg)&#123; Map&lt;String,Object&gt; result = new HashMap&lt;String,Object&gt;(); result.put(SUCCESS, false); result.put(MSG, msg); result.put(DATA, new Object()); return JSON.toJSONString(result); &#125; public static String error(Object data, String msg)&#123; Map&lt;String,Object&gt; result = new HashMap&lt;String,Object&gt;(); result.put(SUCCESS, false); result.put(MSG, msg); result.put(DATA, data); return JSON.toJSONString(result); &#125;&#125; 对应的请求url为：12查询、更新、删除： /users/1插入： /users 有时需要管理版本号会把版本号写在url，比如 v1/users/1、 v2/users/1 。至于请求是什么类型的，可以在请求在head中设置，如果是ajax请求则设置比较简单12345678910111213141516171819$.ajax(&#123; url: '/users/1', type: 'get',//put、delete success: function(data) &#123; console.log(data) &#125;&#125;);$.ajax(&#123; url: '/users', type: 'post', data: &#123; userCode: 'test', userName: '测试名字' &#125;, success: function(data) &#123; console.log(data) &#125;&#125;); RESTful API 的开发涉及许多细节和技术实现，实际开发中的应用会可能会用到一些封装库和框架，这里不做深入了解，只是简单的记录自己的一些基本认识，相关的知识参考了以下的链接。 #####相关参考链接 REST的出处论文 - 作者Roy Fielding RESTful API 设计指南 - 阮一峰的网络日志 怎样用通俗的语言解释REST，以及RESTful？ - 回答作者: 覃超","categories":[{"name":"技术","slug":"技术","permalink":"https://zgshen.me/categories/技术/"}],"tags":[{"name":"Web技术","slug":"Web技术","permalink":"https://zgshen.me/tags/Web技术/"}]},{"title":"用本地服务器解决node-sass安装失败问题","slug":"用本地服务器解决node-sass安装失败问题","date":"2017-08-19T16:00:00.000Z","updated":"2019-06-11T08:36:38.929Z","comments":true,"path":"2017/08/20/用本地服务器解决node-sass安装失败问题/","link":"","permalink":"https://zgshen.me/2017/08/20/用本地服务器解决node-sass安装失败问题/","excerpt":"今天要用到node-sass这东西，使用命令 npm install node-sass --save 安装。然而搞半天始终下载不来，换成淘宝的镜像都不行，因为下载时还会去github下载一个 win32-x64-48_binding.node 的包，然后下不来就一直卡着最后失败。","text":"今天要用到node-sass这东西，使用命令 npm install node-sass --save 安装。然而搞半天始终下载不来，换成淘宝的镜像都不行，因为下载时还会去github下载一个 win32-x64-48_binding.node 的包，然后下不来就一直卡着最后失败。一种解决方法就是根据下载失败提示的链接直接把那个二进制包下载下来，然后放在本地服务器目录下，比如可以根据失败提示的版本号在Nginx的html目录下以版本号建个文件夹放进去，像这样 nginx-1.10.1\\html\\v4.5.3\\win32-x64-48_binding.node ,然后执行 npm install node-sass --save-dev --sass-binary-site=http://localhost:8090/ --registry=https://registry.npm.taobao.org 端口号为Nginx设置的端口号， v4.5.3\\win32-x64-48_binding.node 这一串不用加，这样 win32-x64-48_binding.node 这个包就直接从本地服务器下载了。","categories":[{"name":"技术","slug":"技术","permalink":"https://zgshen.me/categories/技术/"}],"tags":[{"name":"其他","slug":"其他","permalink":"https://zgshen.me/tags/其他/"}]},{"title":"线程池","slug":"线程池","date":"2017-07-19T16:00:00.000Z","updated":"2019-03-03T14:49:30.181Z","comments":true,"path":"2017/07/20/线程池/","link":"","permalink":"https://zgshen.me/2017/07/20/线程池/","excerpt":"创建一个新的线程是有代价的，创建大量的线程会消耗许多系统资源，影响系统的性能。这时，我们就需要使用线程池来管理线程，线程池能缓存线程，可用闲置的线程来执行新任务，能有效控制线程并发数，并对线程进行一些简单的管理。","text":"创建一个新的线程是有代价的，创建大量的线程会消耗许多系统资源，影响系统的性能。这时，我们就需要使用线程池来管理线程，线程池能缓存线程，可用闲置的线程来执行新任务，能有效控制线程并发数，并对线程进行一些简单的管理。 先创建一个线程任务类1234567891011121314151617public class TaskThread implements Runnable &#123; private static final Logger LOG = LoggerFactory.getLogger(TaskThread.class); private String task; public TaskThread(String task) &#123; this.task = task; &#125; @Override public void run() &#123; task(); &#125; private void task() &#123; LOG.info(\"任务:\" + task + \" 线程:\" + Thread.currentThread().getName()); &#125;&#125; 按照一般方式我们通过 new Thread(new TaskThread(&quot;task&quot;)); 的方式来创建一个线程，再调用start方法来启动线程。而线程池为我们提供了另一种创建管理方式，线程池的实现方式也有多种。 使用LinkedList做任务队列来实现一个简单线程池123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475import java.util.HashMap;import java.util.LinkedList;import java.util.Map;import org.slf4j.Logger;import org.slf4j.LoggerFactory;public class WorkQueue&#123; private static final Logger LOG = LoggerFactory.getLogger(WorkQueue.class); private static Map&lt;String,WorkQueue&gt; queues = new HashMap&lt;String,WorkQueue&gt;(); private final int nThreads;//线程池大小 private final PoolWorker[] threads;//用数组实现线程池 private final LinkedList&lt;Runnable&gt; queue;//双向链表实现任务队列 /**私有构造**/ private WorkQueue(String name,int nThreads) &#123; this.nThreads = nThreads; queue = new LinkedList&lt;Runnable&gt;(); threads = new PoolWorker[nThreads]; for (int i=0; i&lt;this.nThreads; i++) &#123; threads[i] = new PoolWorker(name+\"_\"+(i+1)); threads[i].start(); &#125; LOG.info(\"初始化线程池，线程数：\"+nThreads); &#125; /**静态工厂方法创建线程池**/ public static WorkQueue createWorkQueue(String name,int count)&#123; WorkQueue wq = queues.get(name); if(wq == null)&#123; wq = new WorkQueue(name,count); queues.put(name, wq); &#125; return wq; &#125; /**执行任务**/ public void execute(Runnable r) &#123; synchronized(queue) &#123; queue.addLast(r); queue.notify(); &#125; &#125; /**工作线程类**/ private class PoolWorker extends Thread &#123; PoolWorker(String name)&#123; super(name); &#125; public void run() &#123; Runnable r; while (true) &#123; synchronized(queue) &#123; while (queue.isEmpty()) &#123; try&#123; queue.wait();//如果任务队列没有任务，等待 &#125;catch (InterruptedException ignored)&#123; &#125; &#125; r = (Runnable) queue.removeFirst();//有任务时，取出任务 &#125; try &#123; LOG.info(\"线程:\"+Thread.currentThread().getName()+\" 开始执行\"); r.run();//执行任务 &#125; catch (Exception e) &#123; LOG.info(\"线程:\"+Thread.currentThread().getName()+\" 执行出现异常！\"); e.printStackTrace(); &#125; LOG.info(\"线程:\"+Thread.currentThread().getName()+\" 执行完成\"); r = null; &#125; &#125; &#125;&#125; 测试例子，大小为10的线程池执行20个任务1234567WorkQueue wq = WorkQueue.createWorkQueue(\"thread\", 10);TaskThread task[] = new TaskThread[20];for(int i=0; i&lt; task.length; i++)&#123; task[i] = new TaskThread(\"task_\"+i); wq.execute(task[i]);&#125; 使用Executors和ThreadPoolExecutor创建线程池Java 的 java.util.concurrent 包提供了 Executors 类来创建线程池，Executors 类有四种线程池构造，分别为： newCachedThreadPool创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。 newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。 newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。 newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。 之前在阿里的开发手册中有看到，各种 Executors 返回的线程池对象弊端如下：1） FixedThreadPool 和 SingleThreadPool:允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。2） CachedThreadPool 和 ScheduledThreadPool:允许的创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程，从而导致 OOM。 一般常用 newFixedThreadPool 构造返回 ExecutorService 对象来创建线程池。 ExecutorService 接口继承了 Executor 接口（Executor是接口，Executors是类），提供了线程池的操作的成员函数。 使用 Executors 创建线程池类1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.util.HashMap;import java.util.Map;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;public class ThreadPool &#123; private static final Logger LOG = LoggerFactory.getLogger(ThreadPool.class); private static Map&lt;String,ThreadPool&gt; pools = new HashMap&lt;String,ThreadPool&gt;(); private int threadCount = 0; private String name = null;; ExecutorService service = null; private ThreadPool(String name,int count)&#123; this.threadCount = count; this.name = name; service = Executors.newFixedThreadPool(this.threadCount); LOG.info(\"初始化线程池，线程数[\"+this.name+\"]：\"+this.threadCount); &#125; public static ThreadPool createThreadPool(String name,int count)&#123; ThreadPool pool = pools.get(name); if(pool == null)&#123; pool = new ThreadPool(name,count); pools.put(name, pool); &#125; return pool; &#125; public void execute(Runnable r) &#123; service.execute(r); &#125; public void destroy() &#123; service.shutdown(); pools.remove(this.getName()); &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; 其中，看下 newFixedThreadPool 方法的源码12345public static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());&#125; 这是 ThreadPoolExecutor 类的一个实现，再看下构造方法的参数12345678public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue) &#123; this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, Executors.defaultThreadFactory(), defaultHandler);&#125; corePoolSize 核心线程数。核心线程会一直存活，即使没有任务需要处理。即使现有的线程空闲，线程池也会优先创建新线程来处理任务，而不是直接交给现有的线程处理。核心线程在allowCoreThreadTimeout被设置为true时会超时退出，默认情况下不会退出。 maximumPoolSize 最大的线程数。当线程数大于或等于核心线程，且任务队列已满时，线程池会创建新的线程，直到线程数量达到maximumPoolSize。如果线程数已等于maximumPoolSize，且任务队列已满，则已超出线程池的处理能力，线程池会拒绝处理任务而抛出异常。 keepAliveTime 存活时间。当线程空闲时间达到keepAliveTime，该线程会退出，直到线程数量等于corePoolSize。如果allowCoreThreadTimeout设置为true，则所有线程均会退出直到线程数量为0。 allowCoreThreadTimeout 属性标识默认情况下核心线程不会退出，可通过将该参数设置为true，让核心线程也退出。 测试例子123456ThreadPool threadPool = ThreadPool.createThreadPool(\"testThread\", 10);TaskThread task[] = new TaskThread[20];for(int i=0; i&lt; task.length; i++)&#123; task[i] = new TaskThread(\"task_\"+i); threadPool.execute(task[i]);&#125; ThreadPoolExecutor 其他相关ThreadPoolExecutor 本身可以指定创建活跃线程数、限制线程池的大小，还可以创建自己的 RejectedExecutionHandler 来处理不适合放在工作队列里的任务。 终止策略 RejectedExecutionHandler 实现类,当提交的任务无法进入等待队列且线程池中创建的线程数量已经达到了最大线程数量的限制，则会拒绝新提交的任务123456789101112import java.util.concurrent.RejectedExecutionHandler;import java.util.concurrent.ThreadPoolExecutor;import org.slf4j.Logger;import org.slf4j.LoggerFactory;public class RejectedExecutionHandlerImpl implements RejectedExecutionHandler &#123; private static final Logger LOG = LoggerFactory.getLogger(RejectedExecutionHandlerImpl.class); @Override public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) &#123; LOG.info(r.toString() + \"不能执行。\"); &#125;&#125; 完整测试例子12345678910111213141516171819202122232425262728293031323334353637383940import java.util.concurrent.ArrayBlockingQueue;import java.util.concurrent.Executors;import java.util.concurrent.ThreadFactory;import java.util.concurrent.ThreadPoolExecutor;import java.util.concurrent.TimeUnit;import org.slf4j.Logger;import org.slf4j.LoggerFactory;public class TaskTest &#123; private static final Logger LOG = LoggerFactory.getLogger(TaskTest.class); public static void main(String[] args) &#123; /*WorkQueue wq = WorkQueue.createWorkQueue(\"thread\", 10); TaskThread task[] = new TaskThread[20]; for(int i=0; i&lt;task.length; i++)&#123; task[i] = new TaskThread(\"task_\"+i); wq.execute(task[i]); &#125;*/ /*ThreadPool threadPool = ThreadPool.createThreadPool(\"testThread\", 10); TaskThread task[] = new TaskThread[20]; for(int i=0; i&lt;task.length; i++)&#123; task[i] = new TaskThread(\"task_\"+i); threadPool.execute(task[i]); &#125;*/ RejectedExecutionHandlerImpl rejectionHandler = new RejectedExecutionHandlerImpl(); ThreadFactory threadFactory = Executors.defaultThreadFactory(); ThreadPoolExecutor threadPool = new ThreadPoolExecutor(2, 4, 10, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;Runnable&gt;(2), threadFactory, rejectionHandler); //TaskThread task[] = new TaskThread[4];//少数量任务 TaskThread task[] = new TaskThread[20]; for(int i=0; i&lt;task.length; i++)&#123; task[i] = new TaskThread(\"task_\"+i); threadPool.execute(task[i]); &#125; &#125;&#125; 线程池线程核心数设置为2，最大线程数设置为4，当执行少数量任务时线程池未饱和不会触发终止策略，而执行大量任务就可能会触发，比如以上测试例子的4个任务和20任务的区别。","categories":[{"name":"技术","slug":"技术","permalink":"https://zgshen.me/categories/技术/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"https://zgshen.me/tags/Java基础/"}]},{"title":"Spring Boot 打包部署","slug":"Spring Boot部署","date":"2017-07-14T16:00:00.000Z","updated":"2019-03-03T14:47:51.708Z","comments":true,"path":"2017/07/15/Spring Boot部署/","link":"","permalink":"https://zgshen.me/2017/07/15/Spring Boot部署/","excerpt":"Spring Boot默认集成Web容器，部署也相对简单，如果需要以war包形式部署在外部Web容器上也可以，只需要做一些简单的修改配置。","text":"Spring Boot默认集成Web容器，部署也相对简单，如果需要以war包形式部署在外部Web容器上也可以，只需要做一些简单的修改配置。 使用集成的Web容器部署方式打包maven 工程在 eclipse 中执行 Run as Maven build，输入 clean package 进行打包，这里要注意的是 Spring Boot 打成jar包要可以运行，必须使用Spring Boot提供的一个插件，不然打成的普通的jar是无法运行Spring Boot工程的，一般会提示 jar中没有主清单属性。在pom.xml加入插件1234567891011&lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;executions&gt; &lt;execution&gt; &lt;goals&gt; &lt;goal&gt;repackage&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt;&lt;/plugin&gt; 生成的 jar 包使用 java -jar xx.jar 命令就可以启动。 部署到外部Web容器方式在 pom.xml 文件将 &lt;packaging&gt;jar&lt;/packaging&gt; 改为 &lt;packaging&gt;war&lt;/packaging&gt;加上build插件，表明此Web工程不需要web.xml文件1234567&lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;failOnMissingWebXml&gt;false&lt;/failOnMissingWebXml&gt; &lt;/configuration&gt;&lt;/plugin&gt; 排除 Spring Boot Tomcat 组件，scope 属性设为 provided12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; 在 Application 即main方法类同包下创建实现外部 Web 容器启动的启动类例子123456789import org.springframework.boot.builder.SpringApplicationBuilder;import org.springframework.boot.web.support.SpringBootServletInitializer;public class WxServletInitializer extends SpringBootServletInitializer&#123; @Override protected SpringApplicationBuilder configure(SpringApplicationBuilder builder) &#123; return builder.sources(WxApplication.class);//WxApplication 为原main函数启动类 &#125;&#125; 打包完毕将war包部署到外部Web容器。","categories":[{"name":"技术","slug":"技术","permalink":"https://zgshen.me/categories/技术/"}],"tags":[{"name":"web框架","slug":"web框架","permalink":"https://zgshen.me/tags/web框架/"}]},{"title":"ThreadLcoal","slug":"ThreadLcoal","date":"2017-06-30T16:00:00.000Z","updated":"2019-03-03T14:48:04.092Z","comments":true,"path":"2017/07/01/ThreadLcoal/","link":"","permalink":"https://zgshen.me/2017/07/01/ThreadLcoal/","excerpt":"ThreadLcoal不是线程，而是一个创建线程的局部变量的类，主要用于存储多线程下类的某些变量，ThreadLocal为每个使用该变量的线程提供独立的变量副本，当前线程的ThreadLocal的变量只能被该线程访问，而其他线程访问不到。","text":"ThreadLcoal不是线程，而是一个创建线程的局部变量的类，主要用于存储多线程下类的某些变量，ThreadLocal为每个使用该变量的线程提供独立的变量副本，当前线程的ThreadLocal的变量只能被该线程访问，而其他线程访问不到。使用类定义，支持泛型public class ThreadLocal&lt;T&gt;初始化值private T setInitialValue()set方法public void set(T value)get方法public T get() 例子12345678910111213141516171819202122232425262728293031323334353637383940414243public class Test04 &#123; private ThreadLocal&lt;Integer&gt; local = new ThreadLocal&lt;&gt;(); int i=0; class localTread implements Runnable&#123; public void setNum()&#123; local.set(i++); &#125; public Integer getNum()&#123; return local.get(); &#125; @Override public void run() &#123; if(local.get() == null)&#123; setNum(); System.out.println(\"set threadlocal num...\"); &#125; System.out.print(\"the object is: \"); System.out.println(local); System.out.println(local.get()); &#125; &#125; public static void main(String[] args) &#123; try &#123; localTread t = new Test04().new localTread(); Thread t1 = new Thread(t); Thread t2 = new Thread(t); Thread t3 = new Thread(t); t1.start(); Thread.sleep(1000); t2.start(); Thread.sleep(1000); t3.start(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 输出123456789set threadlocal num...the object is: java.lang.ThreadLocal@6b2ce86d0set threadlocal num...the object is: java.lang.ThreadLocal@6b2ce86d1set threadlocal num...the object is: java.lang.ThreadLocal@6b2ce86d2 可以看到三个线程访问的都是同一个ThreadLocal，但只能访问当前线程存储的各自的变量。看源码set方法的实现12345678public void set(T value) &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value);&#125; 通过获取当前线程，再ThreadL中，ThreadLocalMap用弱引用实现get方法实现12345678910111213public T get() &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) &#123; ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) &#123; @SuppressWarnings(\"unchecked\") T result = (T)e.value; return result; &#125; &#125; return setInitialValue();&#125; 同样是为了解决多线程中变量冲突的问题，线程同步机制实现在某个时间点只有一个线程能访问变量，而ThreadLcoal是通过存储每个线程自己变量，以隔离多线程访问数据的冲突，一个损耗时间，一个损耗空间。","categories":[{"name":"技术","slug":"技术","permalink":"https://zgshen.me/categories/技术/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"https://zgshen.me/tags/Java基础/"}]},{"title":"泛型","slug":"泛型","date":"2017-06-29T16:00:00.000Z","updated":"2019-03-03T14:49:15.849Z","comments":true,"path":"2017/06/30/泛型/","link":"","permalink":"https://zgshen.me/2017/06/30/泛型/","excerpt":"泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。使用泛型，意味着编写的代码可以被很多不同类型 的对象所重用。","text":"泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。使用泛型，意味着编写的代码可以被很多不同类型 的对象所重用。泛型类1234567891011121314151617181920212223public class ClassTest&lt;T&gt; &#123; public T firtsFiled; public T secondFiled; public void setFirtsFiled(T data)&#123; firtsFiled = data; &#125; public void setSecondFiled(T data)&#123; secondFiled = data; &#125; public T getFirtsFiled()&#123; return firtsFiled; &#125; public T getSecondFiled()&#123; return secondFiled; &#125; public static &lt;T&gt; T getStaticData(T data)&#123; return data; &#125;&#125; 以上是一个简单的泛型类，T成为类型变量，一般使用大写字母命名。在Java中常用变量E表示集合的元素类型，K和V表示关键字与值的类型，T表示任意类型（约定俗成的用法，事实随便一个字母都行）。当实例化泛型类型需要用具体类型替代类型变量例如：1234ClassTest&lt;String&gt; one = new ClassTest&lt;&gt;();ClassTest&lt;Integer&gt; two = new ClassTest&lt;&gt;();one.setFirtsFiled(\"data1\"); two.setFirtsFiled(123); 泛型方法泛型方法可以定义在普通类或泛型类中，与普通方法不同，泛型方法可以在调用它的时候定义类型变量。例如 public static &lt;T&gt; T getStaticData(T data) 就是一个泛型方法，在方法的返回值前加上 &lt;T&gt; ，在调用时指定类型变量，如下：12Integer staticData = ClassTest.getStaticData(9090);String hello = ClassTest.getStaticData(\"hello\"); 类型变量的限制先看这个代码123public static &lt;T extends Comparable&gt; boolean getMinData(T data)&#123; return data.compareTo(data) &gt; 0 ;&#125; 之所以在定义泛型方法时给 &lt;T&gt; 继承 Comparable 接口，是因为 data 的类型无法确定，不能保证对象都有 compareTo 方法。一个类型变量或通配符可以有多个限定，例如 T extends Comparable &amp; Serializable限定类型用“&amp;”分隔，而逗号用来分隔类型变量。在Java的继承中，可以根据需要拥有多个接口超类型，但限定中至多有一个类。如果用一个类作为限定，它必须是限定列表中的第一个。(core Java) 类型擦除在虚拟机中没有泛型类型对象，所有对象都属于普通类。Java中的泛型基本上都是在编译器这个级别实现的，生成的字节码信息中是不包含泛型中的类型信息的。在定义一个泛型类型时， 都会提供一个删去类型参数后的原始类型，擦除类型变量，并替换为限定类型（无限定的变量用Object）。例如以上的泛型类擦除类型后的原始类型：1234567891011121314151617181920212223public class ClassTest &#123; public Object firtsFiled; public Object secondFiled; public void setFirtsFiled(Object data)&#123; firtsFiled = data; &#125; public void setSecondFiled(Object data)&#123; secondFiled = data; &#125; public Object getFirtsFiled()&#123; return firtsFiled; &#125; public Object getSecondFiled()&#123; return secondFiled; &#125; public static Object getStaticData(Object data)&#123; return data; &#125;&#125; 所以，不能存在如此两个方法，编译器会提示错误123456public String getFirtsFiled(T a)&#123; return \"1\";&#125;public String getFirtsFiled(Object w)&#123; return \"1\";&#125; 通配符类型在泛型操作中进行参数传递时泛型类型必须匹配才能传递，使用通配符来设置传递参数的类型例子，其中Man是Peple的子类，不必关心实现：1234567891011121314151617181920public class SubClass &#123; public void test(ClassTest&lt;Peple&gt; p)&#123; &#125; public void transfer(ClassTest&lt;? extends Peple&gt; p )&#123; &#125; public static void main(String[] args) &#123; SubClass sub = new SubClass(); ClassTest&lt;Man&gt; tt = new ClassTest&lt;&gt;(); //sub.test(tt);错误 sub.transfer(tt); ClassTest&lt;? extends Peple&gt; tt2 = new ClassTest(); //tt2.setFirtsFiled(new Man());错误 //tt2.setFirtsFiled(new Peple());错误 Peple pp =tt2.getSecondFiled(); &#125;&#125; 当调用 sub.test(tt); 时发生错误，我们不能把一个 ClassTest&lt;Man&gt; 传递给这个方法， tt 的类型是 ClassTest&lt;People&gt; ，但定义 public void transfer(ClassTest&lt;? extends Peple&gt; p ) 使用通配符后 sub.transfer(tt); 可以正确使用。再看下面的两个错误，使用通配符后set方法和get方法显然为12void setFirtsFiled(? extends Peple)? extends Peple getSecondFiled() 编译器只知道要将 People 的子类型，但未具体指定，所有set方法会报错，而get方法就没这个问题，有点类似于多态的子类对象指定父类引用，返回一个 People 子类型没有问题。 通配符的超类限定有 extends 来匹配子类，当然也有 super 来指定超类型限定，使用的意思刚好相反123456789101112131415161718192021public class SubClass &#123; public void test(ClassTest&lt;Man&gt; m)&#123; &#125; public void transfer(ClassTest&lt;? super Man&gt; m )&#123; &#125; public static void main(String[] args) &#123; SubClass sub = new SubClass(); ClassTest&lt;Peple&gt; tt = new ClassTest&lt;&gt;(); //sub.test(tt);错误 sub.transfer(tt); ClassTest&lt;? super Man&gt; tt2 = new ClassTest(); tt2.setFirtsFiled(new Tom());//Tom继承自Man tt2.setFirtsFiled(new Man()); //tt2.setFirtsFiled(new Peple());错误 //Peple pp = tt2.getSecondFiled();错误 &#125;&#125; transfer 方法允许使用通配符方式传进一个 ClassTest&lt;Peple&gt; ,因为 People 是 Man 的超类。下面的两个错误是因为此时不确定get方法返回的对象类型无法保证，只能把它赋给一个 Object ，而set方法可以使用任意 Man 对象或它的子类型调用它。","categories":[{"name":"技术","slug":"技术","permalink":"https://zgshen.me/categories/技术/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"https://zgshen.me/tags/Java基础/"}]},{"title":"SSM框架，基于JavaConfig配置方式，不用xml配置文件","slug":"SSM框架，基于JavaConfig配置方式，不用xml配置文件","date":"2017-06-13T16:00:00.000Z","updated":"2020-07-20T04:50:38.150Z","comments":true,"path":"2017/06/14/SSM框架，基于JavaConfig配置方式，不用xml配置文件/","link":"","permalink":"https://zgshen.me/2017/06/14/SSM框架，基于JavaConfig配置方式，不用xml配置文件/","excerpt":"在使用Spring开发时，我们经常会看到各种各样xml配置，过于繁多的xml配置显得复杂烦人。在Spring3之后，Spring支持使用JavaConfig来代替xml配置，这种方式也得到越来越多人的推荐，甚至在Spring Boot的项目中，基本上已经见不到xml的影子了。这里将使用JavaConfig方式对SSM框架进行整合。","text":"在使用Spring开发时，我们经常会看到各种各样xml配置，过于繁多的xml配置显得复杂烦人。在Spring3之后，Spring支持使用JavaConfig来代替xml配置，这种方式也得到越来越多人的推荐，甚至在Spring Boot的项目中，基本上已经见不到xml的影子了。这里将使用JavaConfig方式对SSM框架进行整合。一、maven 的pom.xml配置各种jar包的配置如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.open.ssm&lt;/groupId&gt; &lt;artifactId&gt;ssm-demo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;!-- 版本 --&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;junit.version&gt;4.12&lt;/junit.version&gt; &lt;spring.version&gt;4.3.0.RELEASE&lt;/spring.version&gt; &lt;jackson.version&gt;2.5.0&lt;/jackson.version&gt; &lt;mysql-connector-java.version&gt;5.1.37&lt;/mysql-connector-java.version&gt; &lt;fastjson.version&gt;1.2.3&lt;/fastjson.version&gt; &lt;slf4j.version&gt;1.7.12&lt;/slf4j.version&gt; &lt;commons-io.version&gt;2.4&lt;/commons-io.version&gt; &lt;commons-fileupload.version&gt;1.3.2&lt;/commons-fileupload.version&gt; &lt;commons-collections.version&gt;3.2.2&lt;/commons-collections.version&gt; &lt;commons-lang3.version&gt;3.3.2&lt;/commons-lang3.version&gt; &lt;commons-codec.version&gt;1.10&lt;/commons-codec.version&gt; &lt;javax.servlet-api.version&gt;3.1.0&lt;/javax.servlet-api.version&gt; &lt;druid.version&gt;1.0.16&lt;/druid.version&gt; &lt;mybatis.version&gt;3.4.0&lt;/mybatis.version&gt; &lt;mybatis-spring.version&gt;1.3.0&lt;/mybatis-spring.version&gt; &lt;/properties&gt; &lt;!-- 依赖管理 --&gt; &lt;dependencies&gt; &lt;!-- 单元测试 --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;$&#123;junit.version&#125;&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- json --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;$&#123;fastjson.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spring --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt; &lt;version&gt;$&#123;jackson.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;$&#123;jackson.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;$&#123;jackson.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- jdbc驱动包 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;$&#123;mysql-connector-java.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--common 组件 --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;$&#123;commons-io.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;$&#123;commons-fileupload.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-collections&lt;/groupId&gt; &lt;artifactId&gt;commons-collections&lt;/artifactId&gt; &lt;version&gt;$&#123;commons-collections.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt; &lt;version&gt;$&#123;commons-lang3.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-codec&lt;/groupId&gt; &lt;artifactId&gt;commons-codec&lt;/artifactId&gt; &lt;version&gt;$&#123;commons-codec.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 日志处理 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;$&#123;slf4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- servlet --&gt; &lt;!-- javax.servlet相关 --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;$&#123;javax.servlet-api.version&#125;&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;$&#123;druid.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis-spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;ssm-demo&lt;/finalName&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;configuration&gt; &lt;failOnMissingWebXml&gt;false&lt;/failOnMissingWebXml&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;port&gt;8088&lt;/port&gt; &lt;path&gt;/&lt;/path&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 二、SpringMvc的配置首先创建一个初始化类，继承 AbstractAnnotationConfigDispatcherServletInitializer 1234567891011121314151617181920212223242526272829303132package com.open.ssm.config;import org.apache.log4j.Logger;import org.springframework.web.servlet.support.AbstractAnnotationConfigDispatcherServletInitializer;/** *&lt;p&gt;Title: SpittrWebAppInitializer.java&lt;/p&gt; *&lt;p&gt;Description: 前端控制器配置&lt;/p&gt; *&lt;p&gt;CreateDate: 2017年6月12日&lt;/p&gt; *@author shen *@version v1.0 */public class WebAppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer &#123; private final static Logger LOG = Logger.getLogger(WebAppInitializer.class); @Override protected Class&lt;?&gt;[] getRootConfigClasses() &#123; LOG.info(\"------root配置类初始化------\"); return new Class&lt;?&gt;[] &#123; RootConfig.class &#125;; &#125; @Override protected Class&lt;?&gt;[] getServletConfigClasses() &#123; LOG.info(\"------web配置类初始化------\"); return new Class&lt;?&gt;[] &#123; WebConfig.class &#125;; &#125; @Override protected String[] getServletMappings() &#123; LOG.info(\"------映射根路径初始化------\"); return new String[]&#123; \"/\" &#125;;//请求路径映射，根路径 &#125;&#125; 这里需要实现三个方法，可以其中两个方法看到需要两个配置类 RootConfig 和 WebConfig , getServletMappings 方法处理路径映射到 “/”，表示默认的Servlet，会处理进入应用的所有请求。 其中 WebConfig 用于定义 DispatcherServlet 加载应用上下文的配置，主要包含一些web组件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.open.ssm.config;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;import org.springframework.web.multipart.commons.CommonsMultipartResolver;import org.springframework.web.servlet.ViewResolver;import org.springframework.web.servlet.config.annotation.DefaultServletHandlerConfigurer;import org.springframework.web.servlet.config.annotation.EnableWebMvc;import org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;import org.springframework.web.servlet.view.InternalResourceViewResolver;/** *&lt;p&gt;Title: WebConfig.java&lt;/p&gt; *&lt;p&gt;Description: 配置类，用于定义DispatcherServlet上下文的bean&lt;/p&gt; *&lt;p&gt;CreateDate: 2017年6月12日&lt;/p&gt; *@author shen *@version v1.0 */@Configuration@EnableWebMvc@ComponentScan( \"com.open.ssm.controller\" )public class WebConfig extends WebMvcConfigurerAdapter &#123; @Bean public ViewResolver viewResolver()&#123; InternalResourceViewResolver resolver = new InternalResourceViewResolver(); resolver.setPrefix(\"/WEB-INF/view/\"); resolver.setSuffix(\".jsp\"); return resolver; &#125; //文件上传，bean必须写name属性且必须为multipartResolver，不然取不到文件对象，别问我为什么，我也唔知 @Bean(name=\"multipartResolver\") protected CommonsMultipartResolver MultipartResolver() &#123; CommonsMultipartResolver multipartResolver = new CommonsMultipartResolver(); //multipartResolver.setUploadTempDir(new FileSystemResource(\"/tmp\"));//可不设置 multipartResolver.setMaxUploadSize(2097152);//2M multipartResolver.setMaxInMemorySize(0); multipartResolver.setDefaultEncoding(\"UTF-8\"); return multipartResolver; &#125; //静态资源的处理 @Override public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) &#123; configurer.enable(); &#125;&#125; 而 RootConfig 类主要配置持久层的一些东西，包括数据库、Mybatis框架，事务之类的东西。12345678910111213141516171819202122232425262728package com.open.ssm.config;import org.springframework.aop.framework.autoproxy.BeanNameAutoProxyCreator;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.Import;/** *&lt;p&gt;Title: RootConfig.java&lt;/p&gt; *&lt;p&gt;Description: 配置类，用于管理ContextLoadListener创建的上下文的bean&lt;/p&gt; *&lt;p&gt;CreateDate: 2017年6月12日&lt;/p&gt; *@author shen *@version v1.0 */@Configuration@ComponentScan(basePackages=&#123; \"com.open.ssm.config\", \"com.open.ssm.dao\", \"com.open.ssm.service\" &#125;)@Import(DruidDataSourceConfig.class)public class RootConfig &#123; @Bean public BeanNameAutoProxyCreator proxycreate()&#123; BeanNameAutoProxyCreator proxycreate = new BeanNameAutoProxyCreator(); proxycreate.setProxyTargetClass(true); proxycreate.setBeanNames(\"*ServiceImpl\"); proxycreate.setInterceptorNames(\"transactionInterceptor\"); return proxycreate; &#125; &#125; 三、数据库与Mybatis相关配置这里的数据源使用的是阿里的Druid，接上面 RootConfig 类，可以看到 RootConfig 类又 import 导入了一个配置类 DruidDataSourceConfig123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184package com.open.ssm.config;import java.io.IOException;import java.sql.SQLException;import java.util.Properties;import javax.sql.DataSource;import org.apache.log4j.Logger;import org.mybatis.spring.SqlSessionFactoryBean;import org.mybatis.spring.annotation.MapperScan;import org.springframework.beans.factory.annotation.Value;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.PropertySource;import org.springframework.core.io.support.PathMatchingResourcePatternResolver;import org.springframework.core.io.support.ResourcePatternResolver;import org.springframework.jdbc.datasource.DataSourceTransactionManager;import org.springframework.transaction.interceptor.TransactionInterceptor;import com.alibaba.druid.pool.DruidDataSource;/** *&lt;p&gt;Title: DruidDataSourceConfig.java&lt;/p&gt; *&lt;p&gt;Description: 数据源属性配置&lt;/p&gt; *&lt;p&gt;CreateDate: 2017年6月12日&lt;/p&gt; *@author shen *@version v1.0 */@Configuration@PropertySource(\"classpath:/jdbc.properties\")@MapperScan(basePackages=\"com.open.ssm.dao\")public class DruidDataSourceConfig&#123; private final static Logger LOG = Logger.getLogger(DruidDataSourceConfig.class); @Value(\"$&#123;spring.datasource.url&#125;\") private String dbUrl; @Value(\"$&#123;spring.datasource.username&#125;\") private String username; @Value(\"$&#123;spring.datasource.password&#125;\") private String password; @Value(\"$&#123;spring.datasource.driverClassName&#125;\") private String driverClassName; @Value(\"$&#123;spring.datasource.initialSize&#125;\") private int initialSize; @Value(\"$&#123;spring.datasource.minIdle&#125;\") private int minIdle; @Value(\"$&#123;spring.datasource.maxActive&#125;\") private int maxActive; @Value(\"$&#123;spring.datasource.maxWait&#125;\") private int maxWait; @Value(\"$&#123;spring.datasource.timeBetweenEvictionRunsMillis&#125;\") private int timeBetweenEvictionRunsMillis; @Value(\"$&#123;spring.datasource.minEvictableIdleTimeMillis&#125;\") private int minEvictableIdleTimeMillis; @Value(\"$&#123;spring.datasource.validationQuery&#125;\") private String validationQuery; @Value(\"$&#123;spring.datasource.testWhileIdle&#125;\") private boolean testWhileIdle; @Value(\"$&#123;spring.datasource.testOnBorrow&#125;\") private boolean testOnBorrow; @Value(\"$&#123;spring.datasource.testOnReturn&#125;\") private boolean testOnReturn; @Value(\"$&#123;spring.datasource.poolPreparedStatements&#125;\") private boolean poolPreparedStatements; @Value(\"$&#123;spring.datasource.maxPoolPreparedStatementPerConnectionSize&#125;\") private int maxPoolPreparedStatementPerConnectionSize; @Value(\"$&#123;spring.datasource.filters&#125;\") private String filters; @Value(\"&#123;spring.datasource.connectionProperties&#125;\") private String connectionProperties; @Bean //声明其为Bean实例 public DataSource dataSource()&#123; LOG.info(\"Initialize the data source...\"); DruidDataSource datasource = new DruidDataSource(); datasource.setUrl(this.dbUrl); datasource.setUsername(username); datasource.setPassword(password); datasource.setDriverClassName(driverClassName); //configuration datasource.setInitialSize(initialSize); datasource.setMinIdle(minIdle); datasource.setMaxActive(maxActive); datasource.setMaxWait(maxWait); datasource.setTimeBetweenEvictionRunsMillis(timeBetweenEvictionRunsMillis); datasource.setMinEvictableIdleTimeMillis(minEvictableIdleTimeMillis); datasource.setValidationQuery(validationQuery); datasource.setTestWhileIdle(testWhileIdle); datasource.setTestOnBorrow(testOnBorrow); datasource.setTestOnReturn(testOnReturn); datasource.setPoolPreparedStatements(poolPreparedStatements); datasource.setMaxPoolPreparedStatementPerConnectionSize(maxPoolPreparedStatementPerConnectionSize); try &#123; datasource.setFilters(filters); &#125; catch (SQLException e) &#123; LOG.error(\"druid configuration initialization filter\", e); &#125; datasource.setConnectionProperties(connectionProperties); return datasource; &#125; /* //JdbcTemplate的配置 @Bean public JdbcTemplate jdbcTemplate()&#123; JdbcTemplate jdbcTemplate = new JdbcTemplate(); jdbcTemplate.setDataSource(dataSource()); return jdbcTemplate; &#125; @Bean public NamedParameterJdbcTemplate namedParameterJdbcTemplate()&#123; NamedParameterJdbcTemplate namedParameterJdbcTemplate = new NamedParameterJdbcTemplate(dataSource()); return namedParameterJdbcTemplate; &#125;*/ //mybatis的配置 @Bean public SqlSessionFactoryBean sqlSessionFactoryBean() throws IOException&#123; ResourcePatternResolver resourcePatternResolver = new PathMatchingResourcePatternResolver(); SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean(); sqlSessionFactoryBean.setDataSource(dataSource()); sqlSessionFactoryBean.setMapperLocations(resourcePatternResolver.getResources(\"classpath*:mappers/*.xml\")); sqlSessionFactoryBean.setTypeAliasesPackage(\"com.open.ssm.model\");//别名，让*Mpper.xml实体类映射可以不加上具体包名 return sqlSessionFactoryBean; &#125; @Bean(name = \"transactionManager\") public DataSourceTransactionManager dataSourceTransactionManager()&#123; DataSourceTransactionManager dataSourceTransactionManager = new DataSourceTransactionManager(); dataSourceTransactionManager.setDataSource(dataSource()); return dataSourceTransactionManager; &#125; @Bean(name=\"transactionInterceptor\") public TransactionInterceptor interceptor()&#123; TransactionInterceptor interceptor = new TransactionInterceptor(); interceptor.setTransactionManager(dataSourceTransactionManager()); Properties transactionAttributes = new Properties(); transactionAttributes.setProperty(\"save*\", \"PROPAGATION_REQUIRED\"); transactionAttributes.setProperty(\"del*\", \"PROPAGATION_REQUIRED\"); transactionAttributes.setProperty(\"update*\", \"PROPAGATION_REQUIRED\"); transactionAttributes.setProperty(\"get*\", \"PROPAGATION_REQUIRED,readOnly\"); transactionAttributes.setProperty(\"find*\", \"PROPAGATION_REQUIRED,readOnly\"); transactionAttributes.setProperty(\"*\", \"PROPAGATION_REQUIRED\"); interceptor.setTransactionAttributes(transactionAttributes); return interceptor; &#125; /* //放这里会导致@value注解获取不到配置的值，移到RootConfig @Bean public BeanNameAutoProxyCreator proxycreate()&#123; BeanNameAutoProxyCreator proxycreate = new BeanNameAutoProxyCreator(); proxycreate.setProxyTargetClass(true); proxycreate.setBeanNames(\"*ServiceImpl\"); proxycreate.setInterceptorNames(\"transactionInterceptor\"); return proxycreate; &#125;*/ &#125; 数据库连接信息文件 jdbc.properties 相关内容12345678910111213141516171819202122232425262728spring.datasource.type=com.alibaba.druid.pool.DruidDataSourcespring.datasource.driverClassName=com.mysql.jdbc.Driverspring.datasource.url=jdbc:mysql://localhost:3306/blogspring.datasource.username=rootspring.datasource.password=root#连接池配置spring.datasource.initialSize=5spring.datasource.minIdle=5spring.datasource.maxActive=20#连接等待超时时间spring.datasource.maxWait=60000#配置隔多久进行一次检测(检测可以关闭的空闲连接)spring.datasource.timeBetweenEvictionRunsMillis=60000#配置连接在池中的最小生存时间spring.datasource.minEvictableIdleTimeMillis=300000spring.datasource.validationQuery=SELECT 1 FROM DUALspring.datasource.testWhileIdle=truespring.datasource.testOnBorrow=falsespring.datasource.testOnReturn=false# 打开PSCache，并且指定每个连接上PSCache的大小spring.datasource.poolPreparedStatements=truespring.datasource.maxPoolPreparedStatementPerConnectionSize=20# 配置监控统计拦截的filters，去掉后监控界面sql无法统计，'wall'用于防火墙spring.datasource.filters=stat,wall,log4j# 通过connectProperties属性来打开mergeSql功能；慢SQL记录spring.datasource.connectionProperties=druid.stat.mergeSql=true;druid.stat.slowSqlMillis=5000 这里数据库的事务配置方式有三种： 第一种最简单的方式，在 RootConfig 加上 @EnableTransactionManagement 注解，再加上配置 DataSourceTransactionManager 的bean，就可以在service实现层使用 @Transactional 注解为方法手动加上事务，并且指定的传播属性等等，但老是要手动加 @Transactional 注解实在麻烦 第二种就是文中使用的方式，使用 BeanNameAutoProxyCreator 拦截代理方式，先创建一个 TransactionInterceptor bean，配置好事务传播等属性，在由 BeanNameAutoProxyCreator 进行事务代理。这里有个问题就是 BeanNameAutoProxyCreator 放在 RootConfig 中居然会导致 @value注解获取不到配置文件的值，而是键名字，将它直接放到 RootConfig 下就没事了 第三种是采用aop切面事务， @EnableAspectJAutoProxy 开启切面自动代理，这里写一个切面相关类 AspectConfig ，然后在 使用 @Import(AspectConfig.class) 导进配置就行，由于 &lt;tx: 开头的这种标签实在不知如何用java方式表示，在 stackoverflow 看到一个答案讲还是只能写一个xml文件，使用 @ImportResource(“classpath:/aop-config.xml”) 这种方式进行配置，具体实现如下(三种方式根据需要去掉无关代码，免得出冲突) 1234567891011121314151617181920212223package com.open.ssm.config;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;import org.aspectj.lang.annotation.Pointcut;import org.springframework.context.annotation.ImportResource;import org.springframework.stereotype.Component;/** *&lt;p&gt;Title: AspectConfig.java&lt;/p&gt; *&lt;p&gt;Description: 切面事务&lt;/p&gt; *&lt;p&gt;CreateDate: 2017年6月12日&lt;/p&gt; *@author shen *@version v1.0 */@Aspect@Component@ImportResource(\"classpath:/aop-config.xml\")public class AspectConfig &#123; @Pointcut(\"execution(* com.open.ssm.service.*.*(..))\") public void serviceAnnotatedClass() &#123; &#125; &#125; 四、Druid监控Druid监控这里使用最简单的方式，就一个servlet和一个filterservlet 继承自 StatViewServlet123456789101112131415161718192021222324package com.open.ssm.web;import javax.servlet.annotation.WebInitParam;import javax.servlet.annotation.WebServlet;import com.alibaba.druid.support.http.StatViewServlet;/** *&lt;p&gt;Title: DruidServlMonitor.java&lt;/p&gt; *&lt;p&gt;Description: Druid Servlet&lt;/p&gt; *&lt;p&gt;CreateDate: 2017年6月14日&lt;/p&gt; *@author shen *@version v1.0 */@WebServlet(name=\"druidMonitor\", urlPatterns=\"/druid/*\", initParams=&#123; @WebInitParam(name=\"allow\", value=\"127.0.0.1\"), @WebInitParam(name=\"loginUsername\", value=\"admin\"), @WebInitParam(name=\"loginPassword\", value=\"123123\"), @WebInitParam(name=\"resetEnable\", value=\"false\")&#125;)public class DruidServletMonitor extends StatViewServlet&#123; /** * */ private static final long serialVersionUID = 1L;&#125; filter继承自 WebStatFilter123456789101112131415package com.open.ssm.web;import javax.servlet.annotation.WebFilter;import javax.servlet.annotation.WebInitParam;import com.alibaba.druid.support.http.WebStatFilter;/** * Servlet Filter implementation class DruidStatFilter */@WebFilter(filterName=\"druidFilter\", urlPatterns=\"/*\", initParams=&#123; @WebInitParam(name=\"exclusions\", value=\"*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*\")&#125;)public class DruidStatFilter extends WebStatFilter &#123;&#125; 浏览器直接输入ip+端口/druid，这里在本地是 http://localhost:8088/druid 进入登录页面，输入配置的用户名密码就可以进入监控页面了。 本文我写了一个demo，放在 https://github.com/shen28/ssm-demo ，后续有时间会加上其他的一些东西。","categories":[{"name":"技术","slug":"技术","permalink":"https://zgshen.me/categories/技术/"}],"tags":[{"name":"web框架","slug":"web框架","permalink":"https://zgshen.me/tags/web框架/"}]},{"title":"Spring Boot 普通类调用Bean对象的一种方式","slug":"Spring Boot 普通类调用Bean对象的一种方式","date":"2017-06-07T16:00:00.000Z","updated":"2019-03-03T14:47:34.259Z","comments":true,"path":"2017/06/08/Spring Boot 普通类调用Bean对象的一种方式/","link":"","permalink":"https://zgshen.me/2017/06/08/Spring Boot 普通类调用Bean对象的一种方式/","excerpt":"有时我们有一些特殊的需要，可能要在一个不被Spring管理的普通类中去调用Spring管理的bean对象的一些方法，比如一般SpringMVC工程在controller中通过12@Autowiredprivate TestService testService; 注入TestService 接口就可以调用此接口实现类的实现的方法。","text":"有时我们有一些特殊的需要，可能要在一个不被Spring管理的普通类中去调用Spring管理的bean对象的一些方法，比如一般SpringMVC工程在controller中通过12@Autowiredprivate TestService testService; 注入TestService 接口就可以调用此接口实现类的实现的方法。但在一般类中显然不可以这么做，注入的 TestService 将会报空指针异常，你无法拿到这个bean，在一般的ssm工程中我们可以通过xml配置把普通类设置成一个bean对象，那么 TestService 就有效了， 或者使用 ApplicationContext 直接读取xml配置中的bean也可以拿到 TestService。` Spring Boot 已经摒弃了各种繁琐的xml配置，当然就不再使用xml配置的方式，之前在网上看到一种很简便的方式，但现在又找不到链接了，这里做下记录。 在普通类中定义 ApplicationContext 静态变量和set方法12345private static ApplicationContext applicationContext;//启动类set入，调用下面set方法public static void setApplicationContext(ApplicationContext context) &#123; applicationContext = context;&#125; 在启动类中，启动时事实已经生成 ConfigurableApplicationContext 对象， ConfigurableApplicationContext 是 ApplicationContext 接口的实现，这里直接传到普通类的 setApplicationContext 方法就行了123456789@SpringBootApplication@ServletComponentScanpublic class WxApplication implements EmbeddedServletContainerCustomizer&#123; public static void main(String[] args) &#123; ConfigurableApplicationContext applicationContext = SpringApplication.run(WxApplication.class, args); TestClass.setApplicationContext(applicationContext); &#125;&#125; 由于是静态变量，类加载时 applicationContext 已经存在，就可获取到 TestService 了，唯一不好就是静态变量在服务器启动后将一直存在12345678910111213public class TestClass &#123; private static ApplicationContext applicationContext;//启动类set入，调用下面set方法 public static void setApplicationContext(ApplicationContext context) &#123; // TODO Auto-generated method stub applicationContext = context; &#125; public void getBeanTest()&#123; TestService testService = (TestService)applicationContext.getBean(TestService.class); &#125;&#125; 补充：在普通 Spring 工程在启动的时候都会通过 org.springframework.web.context.ContextLoaderListener 监听器从加载系统资源并管理bean， Spring 提供的 WebApplicationContextUtils 工具类能在请求时获取到运行时工程的bean，如果看源码就可以知道监听器执行时与 WebApplicationContextUtils 类的关联 12345678910//封装一下，类的class和请求request为必要参数public static &lt;T&gt; T getBean(Class&lt;? extends Object&gt; cla,HttpServletRequest request)&#123; if(request == null)&#123; return null; &#125; return (T)WebApplicationContextUtils.getRequiredWebApplicationContext(request.getServletContext()).getBean(cla);//getBean参数可为bean类的.class或直接是bean的Id &#125;//这样获取beanTestService testService= (TestService)getBean(TestService.class, request);","categories":[{"name":"技术","slug":"技术","permalink":"https://zgshen.me/categories/技术/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://zgshen.me/tags/Spring/"}]},{"title":"Spring Boot 过滤器、监听器和拦截器使用","slug":"Spring Boot 过滤器、监听器和拦截器使用","date":"2017-06-06T16:00:00.000Z","updated":"2019-03-03T14:47:44.957Z","comments":true,"path":"2017/06/07/Spring Boot 过滤器、监听器和拦截器使用/","link":"","permalink":"https://zgshen.me/2017/06/07/Spring Boot 过滤器、监听器和拦截器使用/","excerpt":"1、过滤器和监听器Spring Boot中对于过滤器和监听器的使用跟一般web工程中使用方式没什么不同，使用注解方式就可以快速创建，只是要使用注解方式需要在Application类加上 @ServletComponentScan 注解表明开启servlet的注解创建一个监听器","text":"1、过滤器和监听器Spring Boot中对于过滤器和监听器的使用跟一般web工程中使用方式没什么不同，使用注解方式就可以快速创建，只是要使用注解方式需要在Application类加上 @ServletComponentScan 注解表明开启servlet的注解创建一个监听器12345678910111213141516@WebListenerpublic class FirstListener implements ServletContextListener&#123; private static Logger LOG = LoggerFactory.getLogger(FirstListener.class); @Override public void contextInitialized(ServletContextEvent sce) &#123; LOG.info(\"FirstListener 初始化...\"); &#125; @Override public void contextDestroyed(ServletContextEvent sce) &#123; LOG.info(\"FirstListener 销毁...\"); &#125;&#125; 创建一个过滤器，过滤test和hello下文的所有路径1234567891011121314151617181920212223242526@WebFilter(filterName=\"firstFilter\", urlPatterns = &#123; \"/test/*\", \"/hello/*\" &#125;)public class FirsrtFilter implements Filter&#123; private static Logger LOG = LoggerFactory.getLogger(FirsrtFilter.class); @Override public void init(FilterConfig filterConfig) throws ServletException &#123; &#125; @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; HttpServletRequest req = (HttpServletRequest) request; String requestURI = req.getRequestURI(); LOG.info(\"过滤到的请求---&gt;\"+requestURI); &#125; @Override public void destroy() &#123; &#125;&#125; 运行 application 类可看到日志输出2017-06-08 17:14:55.252 INFO 7552 --- [ost-startStop-1] com.fyft.test.web.FirstListener : FirstListener 初始化... 写一个请求路径为 test 的 controller 并访问，可看到2017-06-08 17:15:50.799 INFO 7552 --- [nio-8003-exec-1] com.fyft.test.web.FirsrtFilter : 过滤到的请求---&gt;/test 2、拦截器 实现 HandlerInterceptor 接口创建一个拦截器类123456789101112131415161718192021222324public class MyInterceptor implements HandlerInterceptor &#123; @Override public void afterCompletion(HttpServletRequest arg0, HttpServletResponse arg1, Object arg2, Exception arg3) throws Exception &#123; // TODO Auto-generated method stub //在整个请求结束之后被调用，也就是在DispatcherServlet 渲染了对应的视图之后执行，主要是用于进行资源清理工作 &#125; @Override public void postHandle(HttpServletRequest arg0, HttpServletResponse arg1, Object arg2, ModelAndView arg3) throws Exception &#123; // TODO Auto-generated method stub //请求处理之后进行调用，但是在视图被渲染之前，即Controller方法调用之后 &#125; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object object) throws Exception &#123; // TODO Auto-generated method stub //controller方法调用之前 return true; &#125;&#125; 然后在初始化配置类中注册拦截器1234567891011121314@Configurationpublic class MyWebAppConfigurer extends WebMvcConfigurerAdapter &#123; /** * 添加拦截器 */ @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(new MyInterceptor()).addPathPatterns(\"/*\"); //registry.addInterceptor(new MyInterceptor_copy()).addPathPatterns(\"/*\");//有多个拦截器继续add进去 super.addInterceptors(registry); &#125;&#125; 这里的拦截器只有经过DispatcherServlet 的请求，才会走拦截器链，默认不拦截静态资源，Spring Boot中默认的静态资源路径有 classpath:/META-INF/resources/，classpath:/resources/，classpath:/static/，classpath:/public/ ，在拦截器中我们可以处理一些我们需要的业务，比如防xss攻击，在调用controller前对提交内容进行过滤等等。 参考博客 http://blog.csdn.net/catoop/article/details/50501696","categories":[{"name":"技术","slug":"技术","permalink":"https://zgshen.me/categories/技术/"}],"tags":[{"name":"web框架","slug":"web框架","permalink":"https://zgshen.me/tags/web框架/"}]},{"title":"深圳","slug":"深圳","date":"2017-05-27T16:00:00.000Z","updated":"2020-07-20T02:37:54.486Z","comments":true,"path":"2017/05/28/深圳/","link":"","permalink":"https://zgshen.me/2017/05/28/深圳/","excerpt":"","text":"深圳北站。","categories":[{"name":"生活","slug":"生活","permalink":"https://zgshen.me/categories/生活/"}],"tags":[{"name":"其他","slug":"其他","permalink":"https://zgshen.me/tags/其他/"}]},{"title":"Spring Boor配置Druid数据源","slug":"Spring Boor配置Druid数据源","date":"2017-05-17T16:00:00.000Z","updated":"2019-03-31T14:44:44.935Z","comments":true,"path":"2017/05/18/Spring Boor配置Druid数据源/","link":"","permalink":"https://zgshen.me/2017/05/18/Spring Boor配置Druid数据源/","excerpt":"Druid是阿里巴巴开源平台上的一个项目,整个项目由数据库连接池、插件框架和SQL解析器组成。 添加Druid数据源要使用Druid数据源，我们需要在 application.properties 下添加配置信息","text":"Druid是阿里巴巴开源平台上的一个项目,整个项目由数据库连接池、插件框架和SQL解析器组成。 添加Druid数据源要使用Druid数据源，我们需要在 application.properties 下添加配置信息1234567891011121314151617181920212223242526272829303132#数据库访问配置#mysql#spring.datasource.type=com.alibaba.druid.pool.DruidDataSource#spring.datasource.driver-class-name=com.mysql.jdbc.Driver#spring.datasource.url=jdbc:mysql://localhost:3306/blog#oraclespring.datasource.driverClassName=oracle.jdbc.driver.OracleDriverspring.datasource.url=jdbc:oracle:thin:@127.0.0.1:1521:orclspring.datasource.username=systemspring.datasource.password=123456#连接池配置spring.datasource.initialSize=5spring.datasource.minIdle=5spring.datasource.maxActive=20#连接等待超时时间spring.datasource.maxWait=60000#配置隔多久进行一次检测(检测可以关闭的空闲连接)spring.datasource.timeBetweenEvictionRunsMillis=60000#配置连接在池中的最小生存时间spring.datasource.minEvictableIdleTimeMillis=300000spring.datasource.validationQuery=SELECT 1 FROM DUALspring.datasource.testWhileIdle=truespring.datasource.testOnBorrow=falsespring.datasource.testOnReturn=false# 打开PSCache，并且指定每个连接上PSCache的大小spring.datasource.poolPreparedStatements=truespring.datasource.maxPoolPreparedStatementPerConnectionSize=20# 配置监控统计拦截的filters，去掉后监控界面sql无法统计，'wall'用于防火墙spring.datasource.filters=stat,wall,log4j# 通过connectProperties属性来打开mergeSql功能；慢SQL记录spring.datasource.connectionProperties=druid.stat.mergeSql=true;druid.stat.slowSqlMillis=5000 上面提供了mysql和oracle两种数据库驱动的配置，由于maven中心仓库不提供oracle驱动，需要到oracle官网自行下载你自己版本需要的oracle数据库驱动，再安装到本地仓库。我这里用的eclipse自带的maven，安装oracle数据库驱动到本地仓库是直接建个文件夹丢进去重命下名的，简单粗暴。 参考：jar包放com/oracle/ojdbc6/10.2.0.1.0 文件夹下，命名ojdbc6-10.2.0.1.0.jar12345&lt;dependency&gt; &lt;groupId&gt;com.oracle&lt;/groupId&gt; &lt;artifactId&gt;ojdbc6&lt;/artifactId&gt; &lt;version&gt;$&#123;ojdbc6.version&#125;&lt;/version&gt;&lt;/dependency&gt; 此外，在本版本（1.5.2）的Spring Boot 中，对于上面Druid连接池的配置都不支持，意味着这些配置属性不会生效，所以，需要些一个配置类来读取这些配置并设置到数据源中去 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112package com.fyft.wx.config;import java.sql.SQLException;import javax.sql.DataSource;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Value;import org.springframework.boot.autoconfigure.jdbc.DataSourceProperties;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.Primary;import com.alibaba.druid.pool.DruidDataSource;/** *&lt;p&gt;Title: DruidDataSourceConfig.java&lt;/p&gt; *&lt;p&gt;Description: 数据源属性配置&lt;/p&gt; *&lt;p&gt;CreateDate: 2017年5月18日&lt;/p&gt; *@author shen *@version v1.0 */@Configuration@Primary //在同样的DataSource中，首先使用被标注的DataSourcepublic class DruidDataSourceConfig extends DataSourceProperties&#123; private Logger logger = LoggerFactory.getLogger(DruidDataSourceConfig.class); @Value(\"$&#123;spring.datasource.url&#125;\") private String dbUrl; @Value(\"$&#123;spring.datasource.username&#125;\") private String username; @Value(\"$&#123;spring.datasource.password&#125;\") private String password; @Value(\"$&#123;spring.datasource.driverClassName&#125;\") private String driverClassName; @Value(\"$&#123;spring.datasource.initialSize&#125;\") private int initialSize; @Value(\"$&#123;spring.datasource.minIdle&#125;\") private int minIdle; @Value(\"$&#123;spring.datasource.maxActive&#125;\") private int maxActive; @Value(\"$&#123;spring.datasource.maxWait&#125;\") private int maxWait; @Value(\"$&#123;spring.datasource.timeBetweenEvictionRunsMillis&#125;\") private int timeBetweenEvictionRunsMillis; @Value(\"$&#123;spring.datasource.minEvictableIdleTimeMillis&#125;\") private int minEvictableIdleTimeMillis; @Value(\"$&#123;spring.datasource.validationQuery&#125;\") private String validationQuery; @Value(\"$&#123;spring.datasource.testWhileIdle&#125;\") private boolean testWhileIdle; @Value(\"$&#123;spring.datasource.testOnBorrow&#125;\") private boolean testOnBorrow; @Value(\"$&#123;spring.datasource.testOnReturn&#125;\") private boolean testOnReturn; @Value(\"$&#123;spring.datasource.poolPreparedStatements&#125;\") private boolean poolPreparedStatements; @Value(\"$&#123;spring.datasource.maxPoolPreparedStatementPerConnectionSize&#125;\") private int maxPoolPreparedStatementPerConnectionSize; @Value(\"$&#123;spring.datasource.filters&#125;\") private String filters; @Value(\"&#123;spring.datasource.connectionProperties&#125;\") private String connectionProperties; @Bean //声明其为Bean实例 public DataSource dataSource()&#123; DruidDataSource datasource = new DruidDataSource(); datasource.setUrl(this.dbUrl); datasource.setUsername(username); datasource.setPassword(password); datasource.setDriverClassName(driverClassName); //configuration datasource.setInitialSize(initialSize); datasource.setMinIdle(minIdle); datasource.setMaxActive(maxActive); datasource.setMaxWait(maxWait); datasource.setTimeBetweenEvictionRunsMillis(timeBetweenEvictionRunsMillis); datasource.setMinEvictableIdleTimeMillis(minEvictableIdleTimeMillis); datasource.setValidationQuery(validationQuery); datasource.setTestWhileIdle(testWhileIdle); datasource.setTestOnBorrow(testOnBorrow); datasource.setTestOnReturn(testOnReturn); datasource.setPoolPreparedStatements(poolPreparedStatements); datasource.setMaxPoolPreparedStatementPerConnectionSize(maxPoolPreparedStatementPerConnectionSize); try &#123; datasource.setFilters(filters); &#125; catch (SQLException e) &#123; logger.error(\"druid configuration initialization filter\", e); &#125; datasource.setConnectionProperties(connectionProperties); return datasource; &#125;&#125; 本段配置参考自 http://blog.csdn.net/blueheart20/article/details/52384032其中 @Primary 注解需要放在类上，不然本类配置还是不会覆盖默认的数据源配置，原作者是放在 public DataSource dataSource() 方法上，会报存在两个配置的错误，估计是Spring Boot版本的差异问题。 配置监控统计功能新建一个配置类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package com.fyft.wx.config;import org.springframework.boot.web.servlet.FilterRegistrationBean;import org.springframework.boot.web.servlet.ServletRegistrationBean;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import com.alibaba.druid.support.http.StatViewServlet;import com.alibaba.druid.support.http.WebStatFilter;/** *&lt;p&gt;Title: DruidConfiguration.java&lt;/p&gt; *&lt;p&gt;Description: Druid监控配置&lt;/p&gt; *&lt;p&gt;CreateDate: 2017年5月3日&lt;/p&gt; *@author shen *@version v1.0 */@Configurationpublic class DruidMonitorConfig &#123; /** * 注册ServletRegistrationBean * @return */ @Bean public ServletRegistrationBean registrationBean() &#123; ServletRegistrationBean bean = new ServletRegistrationBean(new StatViewServlet(), \"/druid/*\"); /** 初始化参数配置，initParams**/ //白名单 bean.addInitParameter(\"allow\", \"127.0.0.1\");//多个ip逗号隔开 //IP黑名单 (存在共同时，deny优先于allow) : 如果满足deny的话提示:Sorry, you are not permitted to view this page. //bean.addInitParameter(\"deny\", \"192.168.1.73\"); //登录查看信息的账号密码. bean.addInitParameter(\"loginUsername\", \"admin\"); bean.addInitParameter(\"loginPassword\", \"123456\"); //是否能够重置数据. bean.addInitParameter(\"resetEnable\", \"false\"); return bean; &#125; /** * 注册FilterRegistrationBean * @return */ @Bean public FilterRegistrationBean druidStatFilter() &#123; FilterRegistrationBean bean = new FilterRegistrationBean(new WebStatFilter()); //添加过滤规则. bean.addUrlPatterns(\"/*\"); //添加不需要忽略的格式信息. bean.addInitParameter(\"exclusions\",\"*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*\"); return bean; &#125; &#125; 启动项目后访问 ip:端口/druid 输入配置类设置的账号密码进入监控后台。我们先执行一个数据库操作，可以在sql监控选项卡看到执行的sql 查看数据源选项卡可以看到配置连接池参数也都生效了","categories":[{"name":"技术","slug":"技术","permalink":"https://zgshen.me/categories/技术/"}],"tags":[{"name":"web框架","slug":"web框架","permalink":"https://zgshen.me/tags/web框架/"}]},{"title":"Spring Boot 热部署与日志配置","slug":"Spring Boot 热部署与日志配置","date":"2017-05-10T16:00:00.000Z","updated":"2019-03-31T14:45:32.994Z","comments":true,"path":"2017/05/11/Spring Boot 热部署与日志配置/","link":"","permalink":"https://zgshen.me/2017/05/11/Spring Boot 热部署与日志配置/","excerpt":"热部署和日志是开发中常用的功能，Srping Boot同样集成了相应的工具，可以方便地实现这些功能。 热部署Spring Boot提供了 spring-boot-devtools 模块用于热部署，直接引入就行。","text":"热部署和日志是开发中常用的功能，Srping Boot同样集成了相应的工具，可以方便地实现这些功能。 热部署Spring Boot提供了 spring-boot-devtools 模块用于热部署，直接引入就行。12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; 当修改代码重新编译时，工程就会重新启动加载。 日志功能当引入 spring-boot-starter-web 时候，Spring Boot已经自动引入 spring-boot-starter-logging ，这里我们使用Logback来实现日志管理。Logback是log4j框架的作者开发的新一代日志框架，它效率更高、能够适应诸多的运行环境，同时天然支持SLF4J。 在spring-boot-starter-xx.RELEASE.jar （xx为版本号）下 org.springframework.boot.logging.logback 包中可看到一个base.xml文件,这是Spring Boot 的logback的默认配置。内容12345678910111213141516&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!--Base logback configuration provided for compatibility with Spring Boot 1.1--&gt;&lt;included&gt; &lt;include resource=\"org/springframework/boot/logging/logback/defaults.xml\" /&gt; &lt;property name=\"LOG_FILE\" value=\"$&#123;LOG_FILE:-$&#123;LOG_PATH:-$&#123;LOG_TEMP:-$&#123;java.io.tmpdir:-/tmp&#125;&#125;&#125;/spring.log&#125;\"/&gt; &lt;include resource=\"org/springframework/boot/logging/logback/console-appender.xml\" /&gt; &lt;include resource=\"org/springframework/boot/logging/logback/file-appender.xml\" /&gt; &lt;root level=\"INFO\"&gt; &lt;appender-ref ref=\"CONSOLE\" /&gt; &lt;appender-ref ref=\"FILE\" /&gt; &lt;/root&gt;&lt;/included&gt; 可以看到日志的输出级别是INFO，输出到文件需要我们东东配置下路径。在application.properties进行配置如下123#日志配置logging.file=test.loglogging.level.com.fyft.wx.controller=warn 运行会在工程根目录看到生成的日志文件，把com.fyft.wx.controller 包的日志级别设置为warn了controller下写个测试类123456789101112131415161718package com.fyft.wx.controller;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class IndexController &#123; private final static Logger LOG = LoggerFactory.getLogger(IndexController.class); @RequestMapping(\"test\") public String name() &#123; LOG.info(\"a info logger...\"); LOG.error(\"a error logger...\"); return \"welcome to the FYFT index page.I'm shen.\"; &#125;&#125; 访问本controller，输出（日志级别ALL &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL &lt; OFF，所以只输出error的） 如果我们需要更复杂的日志功能，可以自己写一个xml文件来配置，比如输出到控制台使用Spring Boot的默认配置，而输出到文件使用自定义配置。在resources下新建一个logback.xml配置文件并把刚才logging.file的配置删掉，配置如下12345678910111213141516171819202122232425262728293031323334&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;configuration&gt; &lt;!-- 继承默认配置 --&gt; &lt;include resource=\"org/springframework/boot/logging/logback/base.xml\"/&gt; &lt;logger name=\"org.springframework.web\" level=\"WARN\"/&gt; &lt;!-- 日志存储路径 --&gt; &lt;property name=\"LOG_HOME\" value=\"D:\\\\logs\" /&gt; &lt;!-- 文件输出配置 --&gt; &lt;appender name=\"FILE\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"&gt; &lt;File&gt;$&#123;LOG_HOME&#125;\\\\fyft-wx.log&lt;/File&gt; &lt;rollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\"&gt; &lt;!-- daily rollover 保存历史记录到这个文件夹一日起为后缀 --&gt; &lt;FileNamePattern&gt;$&#123;LOG_HOME&#125;\\\\temp\\\\fyft-wx.%d&#123;yyyy-MM-dd&#125;.%i.log&lt;/FileNamePattern&gt; &lt;!-- keep 30 days' worth of history 保存天数--&gt; &lt;maxHistory&gt;30&lt;/maxHistory&gt; &lt;!-- 日志大小 --&gt; &lt;timeBasedFileNamingAndTriggeringPolicy class=\"ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP\"&gt; &lt;maxFileSize&gt;2MB&lt;/maxFileSize&gt; &lt;/timeBasedFileNamingAndTriggeringPolicy&gt; &lt;/rollingPolicy&gt; &lt;encoder&gt; &lt;!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符--&gt; &lt;Pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;35&#125; - %msg %n&lt;/Pattern&gt; &lt;charset&gt;UTF-8&lt;/charset&gt; &lt;!-- 此处设置字符集 --&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!-- root节点，配置日志级别，添加输出节点 --&gt; &lt;root level=\"INFO\"&gt; &lt;appender-ref ref=\"FILE\"&gt;&lt;/appender-ref&gt; &lt;/root&gt;&lt;/configuration&gt; 如果输出到控制台的日志也需要自定义，就再加上一个 appender 配置，并添加到root节点。需要注意的是继承自 Spring Bootd 配置需要去掉，不然控制台的日志会输出两次（logger输出一次，root输出一次） 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;configuration&gt; &lt;!-- 去掉继承的配置 --&gt; &lt;!-- &lt;include resource=\"org/springframework/boot/logging/logback/base.xml\"/&gt; &lt;logger name=\"org.springframework.web\" level=\"WARN\"/&gt; --&gt; &lt;!-- 日志存储路径 --&gt; &lt;property name=\"LOG_HOME\" value=\"D:\\\\logs\" /&gt; &lt;!-- 文件输出配置 --&gt; &lt;appender name=\"FILE\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"&gt; &lt;File&gt;$&#123;LOG_HOME&#125;\\\\fyft-wx.log&lt;/File&gt; &lt;rollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\"&gt; &lt;!-- daily rollover 保存历史记录到这个文件夹一日起为后缀 --&gt; &lt;FileNamePattern&gt;$&#123;LOG_HOME&#125;\\\\temp\\\\fyft-wx.%d&#123;yyyy-MM-dd&#125;.%i.log&lt;/FileNamePattern&gt; &lt;!-- keep 30 days' worth of history 保存天数--&gt; &lt;maxHistory&gt;30&lt;/maxHistory&gt; &lt;!-- 日志大小 --&gt; &lt;timeBasedFileNamingAndTriggeringPolicy class=\"ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP\"&gt; &lt;maxFileSize&gt;2MB&lt;/maxFileSize&gt; &lt;/timeBasedFileNamingAndTriggeringPolicy&gt; &lt;/rollingPolicy&gt; &lt;encoder&gt; &lt;!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符--&gt; &lt;Pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;35&#125; - %msg %n&lt;/Pattern&gt; &lt;charset&gt;UTF-8&lt;/charset&gt; &lt;!-- 此处设置字符集 --&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!-- 控制台输出配置 --&gt; &lt;appender name=\"STDOUT\" class=\"ch.qos.logback.core.ConsoleAppender\"&gt; &lt;encoder class=\"ch.qos.logback.classic.encoder.PatternLayoutEncoder\"&gt; &lt;!--格式化输出：%d表示日期，$&#123;PID&#125; 进程Id， %thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符--&gt; &lt;Pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; $&#123;PID&#125; [%thread] %-5level %logger&#123;35&#125; - %msg %n&lt;/Pattern&gt; &lt;charset&gt;UTF-8&lt;/charset&gt; &lt;!-- 此处设置字符集 --&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!-- root节点，配置日志级别，添加输出节点 --&gt; &lt;root level=\"INFO\"&gt; &lt;appender-ref ref=\"FILE\"&gt;&lt;/appender-ref&gt; &lt;appender-ref ref=\"STDOUT\"&gt;&lt;/appender-ref&gt; &lt;/root&gt;&lt;/configuration&gt; 其他更多详细的logback配置可查看官方文档 https://logback.qos.ch/manual/configuration.html","categories":[{"name":"技术","slug":"技术","permalink":"https://zgshen.me/categories/技术/"}],"tags":[{"name":"web框架","slug":"web框架","permalink":"https://zgshen.me/tags/web框架/"}]},{"title":"创建一个Spring Boot工程","slug":"创建Spring Boot工程","date":"2017-05-09T16:00:00.000Z","updated":"2019-03-31T14:46:13.863Z","comments":true,"path":"2017/05/10/创建Spring Boot工程/","link":"","permalink":"https://zgshen.me/2017/05/10/创建Spring Boot工程/","excerpt":"在搭建传统的SpringMVC项目或其他Spring项目的的时候，我们通常都需要写一堆与Spring整合的xml配置文件，过程繁琐复杂不说，而且容易出错。为了简化开发，Spring Boot应运而生。Spring Boot可以创建独立运行的基于Spring的应用，并且大多数时候只需编写少量的配置。能独立运行的原因是Spring Boot项目本身嵌入了Tomcat等其他web容器插件，详细介绍看官网http://projects.spring.io/spring-boot/。 创建一个Spring Boot 项目1、pom.xml配置(1)基本配置这里使用Maven构建工程，根据官网的推荐，项目可继承于spring-boot-starter-parent 来管理工程。","text":"在搭建传统的SpringMVC项目或其他Spring项目的的时候，我们通常都需要写一堆与Spring整合的xml配置文件，过程繁琐复杂不说，而且容易出错。为了简化开发，Spring Boot应运而生。Spring Boot可以创建独立运行的基于Spring的应用，并且大多数时候只需编写少量的配置。能独立运行的原因是Spring Boot项目本身嵌入了Tomcat等其他web容器插件，详细介绍看官网http://projects.spring.io/spring-boot/。 创建一个Spring Boot 项目1、pom.xml配置(1)基本配置这里使用Maven构建工程，根据官网的推荐，项目可继承于spring-boot-starter-parent 来管理工程。1234567891011&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.2.RELEASE&lt;/version&gt;&lt;/parent&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; (2)如果不使用官方依赖实际开发中我们可能想自己创建父工程来管理依赖，例如我们创建聚合工程时有自己的parent工程，那么我们在自己的父工程定义版本号，根据需要引入对应的包。123456789101112131415&lt;!-- 版本号 --&gt;&lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;spring.version&gt;1.5.2.RELEASE&lt;/spring.version&gt;&lt;/properties&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;dependencyManagement&gt; 2、编写应用入口类1234567891011121314151617181920package com.fyft.test;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;/** *&lt;p&gt;Title: TestApplication.java&lt;/p&gt; *&lt;p&gt;Description: TODO&lt;/p&gt; *&lt;p&gt;CreateDate: 2017年5月10日&lt;/p&gt; *@author shen *@version v1.0 */@SpringBootApplicationpublic class TestApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(TestApplication.class, args); &#125; &#125; 直接执行此主函数项目就启动了，默认的端口是8080，如果需要改变端口可以在此类实现EmbeddedServletContainerCustomizer 接口，这个接口包含内置Servlet容器的一些配置，例如设置访问端口为800312345678910111213@SpringBootApplicationpublic class TestApplication implements EmbeddedServletContainerCustomizer&#123; public static void main(String[] args) &#123; SpringApplication.run(TestApplication.class, args); &#125; @Override public void customize(ConfigurableEmbeddedServletContainer config) &#123; config.setPort(8003); &#125; &#125; 创建Controller类要让Controller被扫描到，必须放在主入口类 TestApplication 的同级目录或下级目录，这样才能被扫描到，注解才会生效。其他的带注解类都是一样的逻辑， Spring Boot 默认扫描入口启动类所在包之下的目录。 打包部署启动Spring Boot工程直接打成jar包就行了，如果工程是要跑在外部web容器的，也可以打成war包发布，这需要修改一些配置，这里先不做介绍。在eclipse上直接用maven打包就行，输入 clean package 命令，勾上Skip Tests 忽略测试就行。 在dos下cd到jar包目录下执行 java -jar xx.jar 启动工程，出现一个错误 原因是 maven 自身打包生成的目录结构和文件和 Spring Boot 需要的有所不同，需要在pom.xml加上一段配置，使用 spring-boot-maven-plugin 来打包123456789101112131415&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;executions&gt; &lt;execution&gt; &lt;goals&gt; &lt;goal&gt;repackage&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 若上面的dos正cd到target目录下，须退出此目录，在打包编译时会删除一次target目录，若不退出将会包无法删除此目录，因为你正打开它。再次执行java -jar 命令启动成功","categories":[{"name":"技术","slug":"技术","permalink":"https://zgshen.me/categories/技术/"}],"tags":[{"name":"web框架","slug":"web框架","permalink":"https://zgshen.me/tags/web框架/"}]},{"title":"eclipse neon版本打开某些javascript文件异常问题","slug":"eclipse neon版本打开某些javascript文件异常问题","date":"2017-05-01T16:00:00.000Z","updated":"2019-03-03T14:44:37.181Z","comments":true,"path":"2017/05/02/eclipse neon版本打开某些javascript文件异常问题/","link":"","permalink":"https://zgshen.me/2017/05/02/eclipse neon版本打开某些javascript文件异常问题/","excerpt":"","text":"eclipse neon版本的javascript编辑器无法处理某些异常信息，比如本人在用require js和vue js的时候碰过这种异常 java.lang.NoSuchMethodError:jdk.nashorn.internal.runtime.ECMAException.getEcmaError()Ljava/lang/Object;然后js文件直接就打不开了，最终在stackoverflow找到相关问题，链接http://stackoverflow.com/questions/38089331/eclipse-neon-java-ee-ide-javascript-editor-broken 照回答者意思是javascript开发工具没法解析某些特殊语法的js代码；另一个回答是说新版本的jdk已经解决这个问题，尝试卸了jdk（一直用的1.8.0_05版），装上最新版本的（目前是1.8.0_131版），问题解决。（仅供参考）","categories":[{"name":"技术","slug":"技术","permalink":"https://zgshen.me/categories/技术/"}],"tags":[{"name":"其他","slug":"其他","permalink":"https://zgshen.me/tags/其他/"}]},{"title":"多线程","slug":"多线程","date":"2017-04-30T16:00:00.000Z","updated":"2019-03-03T14:49:04.743Z","comments":true,"path":"2017/05/01/多线程/","link":"","permalink":"https://zgshen.me/2017/05/01/多线程/","excerpt":"在编程中，多线程的意思是某个程序同时多个任务，这样的每一个任务则称为一个线程。线程这部分涉及的知识非常多，在实际开发的应用也是非常重要，这里将介绍基本的部分。 概念线程：操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中实际运作单位。进程：计算机中已运行程序的实体。进程本身不会运行，是线程的容器。","text":"在编程中，多线程的意思是某个程序同时多个任务，这样的每一个任务则称为一个线程。线程这部分涉及的知识非常多，在实际开发的应用也是非常重要，这里将介绍基本的部分。 概念线程：操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中实际运作单位。进程：计算机中已运行程序的实体。进程本身不会运行，是线程的容器。并行与并发： 并行：多个cpu实例或者多台机器同时执行一段处理逻辑，是真正的同时。 并发：通过cpu调度算法，让用户看上去同时执行，实际上从cpu操作层面不是真正的同时。[1] 实现多线程的几种基本方式1、继承Thread类 12345678910111213141516171819202122public class Test02 extends Thread&#123; private String name; public Test02(String name) &#123; this.name = name; &#125; @Override public void run() &#123; for(int i=0; i&lt;100; i++)&#123; System.out.println(name + i); &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; Test02 test1 = new Test02(\"one--&gt;\"); Test02 test2 = new Test02(\"two--&gt;\"); test1.start(); test2.start(); &#125;&#125; 2、实现Runnable接口 12345678910111213141516171819202122232425public class Test01 implements Runnable&#123; private String name; public Test01(String name)&#123; this.name = name; &#125; @Override public void run() &#123; for(int i=0; i&lt;100; i++)&#123; System.out.println(name+\"---&gt;\"+i); &#125; &#125; public static void main(String[] args) &#123; Test01 test1 = new Test01(\"one\"); Test01 test2 = new Test01(\"two\"); Thread thread1 = new Thread(test1);//使用thread类执行start方法 Thread thread2 = new Thread(test2); thread1.start(); thread2.start(); &#125;&#125; 3、使用Callable和Future接口创建线程 123456789101112131415161718192021public class Test03 implements Callable&lt;Integer&gt;&#123; @Override public Integer call() throws Exception &#123; for(int i=0; i&lt;100; i++)&#123; System.out.println(Thread.currentThread().getName()+\"---&gt;\"+i); &#125; return null; &#125; public static void main(String[] args) &#123; Test03 t1 = new Test03(); Test03 t2 = new Test03(); FutureTask&lt;Integer&gt; task1 = new FutureTask&lt;&gt;(t1); FutureTask&lt;Integer&gt; task2 = new FutureTask&lt;&gt;(t2); new Thread(task1, \"新建线程1\").start(); new Thread(task2, \"新建线程2\").start(); &#125;&#125; 线程状态使用getState()方法可获取当前线程的状态(枚举类型)，各种状态如下： New（新生)当new一个新的线程时，线程还没开始运行时，状态是new123456public class Test &#123; public static void main(String[] args) &#123; Thread thread = new Thread(); System.out.println(thread.getState()); &#125;&#125; 输出NEW Runnable（可运行）线程调用start执行时12345678910111213public class Test &#123; public static void main(String[] args) &#123; Thread thread = new Thread(new Runnable() &#123; public void run() &#123; for(int i=0; i&lt;100; i++)&#123; System.out.println(\"i is \"+i); &#125; &#125; &#125;); thread.start(); System.out.println(thread.getState()); &#125;&#125; 输出RUNNABLEi is 0i is 1…i is 99 Blocked（被阻塞）当一个线程试图获取一个内部的对象锁（而不是java.util.concurrent库中的锁），而该锁被其他线程持有，则该线程进入阻塞状态。1234567891011121314151617181920212223242526272829public class Test &#123; final Object lock = new Object(); class Example implements Runnable&#123; private String name; public Example(String name) &#123; this.name = name; &#125; @Override public void run() &#123; //同步代码块 synchronized (lock) &#123; for(int i=0; i&lt;100; i++)&#123; System.out.println(name+\": i is \"+i); &#125; &#125; &#125; &#125; public static void main(String[] args) &#123; Example example1 = new Test().new Example(\"test1\"); Example example2 = new Test().new Example(\"test2\"); Thread thread1 = new Thread(example1); Thread thread2 = new Thread(example2); thread1.start(); thread2.start(); System.out.println(thread1.getState()); System.out.println(thread2.getState()); &#125;&#125; 输出RUNNABLEtest1: i is 0test2: i is 0test1: i is 1BLOCKEDtest1: i is 2… Waiting（等待）等待状态，释放自身的锁进入Waiting状态并加入线程等待队列12345678910111213141516171819202122public class Test &#123; public synchronized void testMethod()&#123; try &#123; this.wait(); System.out.println(\"waiting closed.\"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; Thread thread1 = new Thread(new Runnable() &#123; public void run() &#123; new Test().testMethod(); &#125; &#125;); thread1.start(); Thread.sleep(10);//主线程休眠，转而去执行子进程 System.out.println(thread1.getState()); &#125;&#125; 输出WAITINGwaiting closed并不会输出 Timed waiting（计时等待）在this.wait();加上等待时间就会进入计时等待状态，例如this.wait(3000);等待三秒输出内容TIMED_WAITINGwaiting closed. Terminated（被终止）run方法执行结束线程终止 123456789101112public class Test &#123; public static void main(String[] args) throws InterruptedException &#123; Thread thread = new Thread(new Runnable() &#123; public void run() &#123; System.out.println(\"run success\"); &#125; &#125;); thread.start(); Thread.sleep(100); System.out.println(thread.getState()); &#125;&#125; 线程管理 sleep方法static void sleep(long millis)让当前正在运行的线程休眠一段时间sleep是一个静态方法，不要用实例化的线程对象调用，其作用的是当前正在运行的线程。Thread.sleep(2000);表示让当前线程休眠2秒，这里的2秒并不是准确的时间段，因为线程是由系统控制，实际时间可能大于2秒。 yield方法static void yield()暂停当前正在执行的线程，重新进入就绪状态，这也是和sleep方法的区别的地方。如果有其他的可运行线程具有至少与此线程同样高的优先级，那么这些线程接下来会被调度。 join方法合并线程。等待终止指定的线程，让主线程等待子线程结束之后再执行 12345678910111213141516171819202122232425public class Test &#123; public static void main(String[] args) throws InterruptedException &#123; Thread thread1 = new Thread(new Runnable() &#123; public void run() &#123; for(int i=0; i&lt;100; i++)&#123; System.out.println(\"one--\"+i); &#125; &#125; &#125;); Thread thread2 = new Thread(new Runnable() &#123; public void run() &#123; thread1.start(); try &#123; thread1.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; for(int i=0; i&lt;100; i++)&#123; System.out.println(\"two--\"+i); &#125; &#125; &#125;); thread2.start(); &#125;&#125; thread1在thread2中启动，为thread2子线程，调用join，等待thread1执行结束再执行thread2，相当于把两线程合并了。void join(long millis)join重载方法带参数，在指定时间段子线程未执行完将重新进入就绪状态，等待cpu调度。 notify和notifyAll方法notify方法只唤醒一个等待（对象的）线程并使该线程开始执行。所以如果有多个线程等待一个对象，这个方法只会唤醒其中一个线程，选择哪个线程取决于操作系统对多线程管理的实现。notifyAll 会唤醒所有等待(对象的)线程。1234567891011121314151617181920212223242526272829303132333435public class Test &#123; public synchronized void testMethod()&#123; try &#123; System.out.println(\"thread start.\"); this.wait(); System.out.println(\"waiting closed.\"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; public synchronized void notifyMethod()&#123; this.notifyAll(); &#125; public static void main(String[] args) throws InterruptedException &#123; Test test = new Test(); Thread thread1 = new Thread(new Runnable() &#123; public void run() &#123; test.testMethod(); &#125; &#125;); Thread thread2 = new Thread(new Runnable() &#123; public void run() &#123; test.notifyMethod(); System.out.println(\"唤醒线程.....\"); &#125; &#125;); thread1.start(); Thread.sleep(1000); System.out.println(thread1.getState()); thread2.start(); &#125;&#125; 输出thread start.WAITING唤醒线程.....waiting closed. interrupted和isInterruptedInterrupted方法是一个静态方法，它检测当前的线程是否被中断。而且，调用interrupted方法会清除该线程的中断状态。另一方面，isInterrupted方法是一个实例方法，可用来检验是否有线程被中断。调用这个方法不会改变中断状态。 setPriority和getPriorityvoid setPriority(int newPriority)设置线程的优先级。优先级必须在Thread.MIN_PRIORITY 与Thread.MAX_PRIORITY之间。一般使用Thread.NORM_PRIORITY 优先级。final int getPriority()获取线程的优先级 结束线程Tread中有stop方法，但改方法已经过时，不推荐使用。要结束线程，可设置标志来实现。 12345678910111213141516171819202122public class Test &#123; class TestTread implements Runnable&#123; private boolean flag; private void stopThread() &#123; this.flag=true; &#125; @Override public void run() &#123; for(int i=0; i&lt;1000 &amp;&amp; !flag; i++)&#123; System.out.println(\"i is \"+i); &#125; &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; TestTread test = new Test().new TestTread(); Thread thread1 = new Thread(test); thread1.start(); Thread.sleep(3);//休眠延时 test.stopThread(); &#125;&#125; 输出一段i的值之后当执行stopThread方法线程就结束了。","categories":[{"name":"技术","slug":"技术","permalink":"https://zgshen.me/categories/技术/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"https://zgshen.me/tags/Java基础/"}]},{"title":"Linux下安装Nginx并配置一个图片服务器","slug":"Linux下安装Nginx并配置一个图片服务器","date":"2017-04-20T16:00:00.000Z","updated":"2019-03-31T14:43:42.367Z","comments":true,"path":"2017/04/21/Linux下安装Nginx并配置一个图片服务器/","link":"","permalink":"https://zgshen.me/2017/04/21/Linux下安装Nginx并配置一个图片服务器/","excerpt":"首先到Nginx官网下载tar.gz格式的安装包，这里下载的是nginx-1.10.3版本，环境使用centos6的虚拟机 1、将安装包上传，解压，命令tar -xvf nginx-1.10.3.tar.gz； 2、自定义创建一个文件夹作为Nginx安装目录，这里在home下创建nginx文件夹；","text":"首先到Nginx官网下载tar.gz格式的安装包，这里下载的是nginx-1.10.3版本，环境使用centos6的虚拟机 1、将安装包上传，解压，命令tar -xvf nginx-1.10.3.tar.gz； 2、自定义创建一个文件夹作为Nginx安装目录，这里在home下创建nginx文件夹； 3、在解压的文件夹（nginx-1.10.3）下执行./configure --prefix=/home/nginx 命令。意思即配置安装环境，将会把Nginx安装到/home/nginx下； 若没有gcc，先安装yum -y install gcc gcc-c++ autoconf automake make 若出现缺少依赖包则先安装依赖包，以下纯净centos mini版碰到的两个依赖包问题出现上面这个执行 yum -y install pcre-devel 安装依赖， 出现这个yum install -y zlib-devel 安装依赖， 若还有其他依赖问题，根据缺少的文件提示安装相应的东西； 4、编译：在解压的文件夹下先后执行make 和 make install 命令 5、Nginx默认使用端口是80，这里直接先把Nginx端口改为8088，vi /home/nginx/conf/nginx.conf，修改server的端口，并配置一个图片服务器 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144#user nobody;worker_processes 1;#error_log logs/error.log;#error_log logs/error.log notice;#error_log logs/error.log info;#pid logs/nginx.pid;events &#123; worker_connections 1024;&#125;http &#123; include mime.types; default_type application/octet-stream; #log_format main '$remote_addr - $remote_user [$time_local] \"$request\" ' # '$status $body_bytes_sent \"$http_referer\" ' # '\"$http_user_agent\" \"$http_x_forwarded_for\"'; #access_log logs/access.log main; sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; #gzip on; server &#123; listen 8088; server_name localhost; #charset koi8-r; #access_log logs/host.access.log main; location ~ .*\\.(gif|jpg|jpeg|png)$ &#123; expires 24h; root /home/images/;#指定图片存放路径 access_log /home/nginx/logs/images.log;#图片 日志路径 proxy_store on; proxy_store_access user:rw group:rw all:rw; proxy_temp_path /home/images/;#代理临时路径 proxy_redirect off; proxy_set_header Host 127.0.0.1; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; client_max_body_size 10m; client_body_buffer_size 1280k; proxy_connect_timeout 900; proxy_send_timeout 900; proxy_read_timeout 900; proxy_buffer_size 40k; proxy_buffers 40 320k; proxy_busy_buffers_size 640k; proxy_temp_file_write_size 640k; if ( !-e $request_filename) &#123; proxy_pass http://127.0.0.1:8088;#代理访问地址 &#125; &#125; location / &#123; root html; index index.html index.htm; &#125; #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \\.php$ &#123; # proxy_pass http://127.0.0.1; #&#125; # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \\.php$ &#123; # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; # include fastcgi_params; #&#125; # deny access to .htaccess files, if Apache's document root # concurs with nginx's one # #location ~ /\\.ht &#123; # deny all; #&#125; &#125; # another virtual host using mix of IP-, name-, and port-based configuration # #server &#123; # listen 8000; # listen somename:8080; # server_name somename alias another.alias; # location / &#123; # root html; # index index.html index.htm; # &#125; #&#125; # HTTPS server # #server &#123; # listen 443 ssl; # server_name localhost; # ssl_certificate cert.pem; # ssl_certificate_key cert.key; # ssl_session_cache shared:SSL:1m; # ssl_session_timeout 5m; # ssl_ciphers HIGH:!aNULL:!MD5; # ssl_prefer_server_ciphers on; # location / &#123; # root html; # index index.html index.htm; # &#125; #&#125;&#125; server下listen的端口改为8088，并增加一个location配置，用于访问图片文件，这一串配置有#号在前面的注释掉的都可以删掉，免得看起来又长又乱。 6、启动命令： /home/nginx/sbin/nginx -c /home/nginx/conf/nginx.conf。打开防火墙对应端口供访问，8088，当然也可以直接关了防火墙。若修改了nginx.conf配置，则需要重启才生效，命令：/home/nginx/sbin/nginx -s reload 7、访问。输入ifconfig命令查看虚拟机ip，测试： 在/home/images下放张图片，测试访问：","categories":[{"name":"技术","slug":"技术","permalink":"https://zgshen.me/categories/技术/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://zgshen.me/tags/Linux/"}]},{"title":"eclipse neon git 提交窗口太小问题","slug":"eclipse neon git 提交窗口太小问题","date":"2017-04-15T16:00:00.000Z","updated":"2019-03-31T14:42:46.398Z","comments":true,"path":"2017/04/16/eclipse neon git 提交窗口太小问题/","link":"","permalink":"https://zgshen.me/2017/04/16/eclipse neon git 提交窗口太小问题/","excerpt":"","text":"eclipse neon 版本更新了git工具EGit版本，默认commit时使用的是一个标签窗口，不是像之前一个新 dialog窗口，像下面这样：不能单独作为新窗口拖出来的，个人用起来也觉得操作真的是不方便，翻了下设置，在Window-Preferences-Team-Git-Committing可以看到第一个选项 Use Staging View … （使用staging代替原来dialog的commit视图），把这个打钩去掉提交界面就回到前版本的样子","categories":[{"name":"技术","slug":"技术","permalink":"https://zgshen.me/categories/技术/"}],"tags":[{"name":"其他","slug":"其他","permalink":"https://zgshen.me/tags/其他/"}]},{"title":"反射","slug":"反射","date":"2017-04-03T16:00:00.000Z","updated":"2019-03-31T14:46:24.259Z","comments":true,"path":"2017/04/04/反射/","link":"","permalink":"https://zgshen.me/2017/04/04/反射/","excerpt":"相信大家经常听说某些框架设计用到了反射机制啥啥，但自己对此概念却了解甚少，虽然一般开发不会用到，但还是有必要知道反射的基本原理和操作。 使用反射，可以做到： 在运行中分析类的能力。 在运行中查看对象，例如，编写一个toString方法供所有类使用。 实现数组的操作代码。 利用Method对象，这个对象很像C++中的函数指针。 反射操作主要用到的类有Class（类）、Field（属性）、Method（成员函数）、Constructor（构造）和Modifier（修饰符）","text":"相信大家经常听说某些框架设计用到了反射机制啥啥，但自己对此概念却了解甚少，虽然一般开发不会用到，但还是有必要知道反射的基本原理和操作。 使用反射，可以做到： 在运行中分析类的能力。 在运行中查看对象，例如，编写一个toString方法供所有类使用。 实现数组的操作代码。 利用Method对象，这个对象很像C++中的函数指针。 反射操作主要用到的类有Class（类）、Field（属性）、Method（成员函数）、Constructor（构造）和Modifier（修饰符）一、反射获取类 新建一个Student类123456789101112131415161718192021222324252627282930313233343536public class Student &#123; private int age; private String name; //无参构造 public Student() &#123; &#125; //有参构造 public Student(int age, String name)&#123; this.age = age; this.name = name; System.out.println(\"My name is \"+name+\",I'm \"+age+\" years old.\"); &#125; public void setAge(int age) &#123; this.age = age; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public String getName() &#123; return name; &#125; public void learning() &#123; System.out.println(\"learning...\"); &#125; &#125; 测试类1234567891011121314151617181920212223public class ReflexTest &#123; public static void main(String[] args) throws ClassNotFoundException &#123; Student student = new Student(20, &quot;shen&quot;);//一般创建对象 Class stu = Class.forName(&quot;com.test.reflex.Student&quot;);//通过Class获取指定类的完整结构 System.out.println(&quot;getName---&gt;&quot;+stu.getName()); Student s = null; Student s1 = null; try &#123; s = (Student)stu.newInstance();//默认构造的是无参构造，若存在有参构造，这里将报错 Constructor constructor = stu.getConstructor(int.class, String.class);//获取有参构造,已知确定参数 s1 = (Student)constructor.newInstance(23, &quot;shen&quot;);//有参构造 Constructor[] constructors = stu.getConstructors();//所有构造 s1 = (Student)constructors[0].newInstance();//第一个构造(无参那个) &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 输出：Class类forName方法通过完整包路径类型来实例化Class对象，再通过Class对象获取Student类实例；再使用newInstance()创建对象，这里要注意Student的构造方法，默认使用的试试无参构造，可使用Constructor类操作构造方法。 二、获取类的基本结构 1、使用反射操作对象属性12345678910111213141516171819202122232425262728public class Test01 &#123; public static void main(String[] args) throws Exception, Exception &#123; try &#123; Class stu = Class.forName(&quot;com.test.reflex.Student&quot;); Constructor constructor = stu.getConstructor(int.class, String.class);//获取有参构造,已知确定参数 Student s = (Student)constructor.newInstance(23, &quot;shen&quot;);//有参构造 //Field[] fields = stu.getFields();//获取public的属性 Field[] fields = stu.getDeclaredFields();//获取所有属性 for(Field field : fields)&#123; System.out.println(&quot;属性--&gt;&quot;+field); &#125; Field fieldName = stu.getDeclaredField(&quot;name&quot;);//获取私有变量name fieldName.setAccessible(true); System.out.println(fieldName.getName());//私有属性名称 System.out.println(fieldName.get(s));//私有属性值 fieldName.set(s, &quot;a-shen&quot;); System.out.println(fieldName.get(s));//改变私有属性值 &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 结果输出 其中对于fieldName.setAccessible(true);使用java反射获取类的属性值时，如果该属性被声明为private 的，需要将setAccessible设置为true. 默认的值为false 2、使用反射访问成员函数通过反射调用方法，使用invoke方法 12345678910111213141516171819202122232425262728public class Test02 &#123; public static void main(String[] args) throws Exception, Exception &#123; try &#123; Class stu = Class.forName(&quot;com.test.reflex.Student&quot;); Constructor constructor = stu.getConstructor(int.class, String.class);//获取有参构造,已知确定参数 Constructor[] constructors = stu.getConstructors(); Student s = (Student)constructors[0].newInstance();//无参构造对象 //Method[] methods = stu.getMethods();//获取类所有方法，包括继承自父类和实现接口的方法 Method[] methods = stu.getDeclaredMethods();//获取类本身各类方法和实现接口的方法及重写的方法，不包括继承的方法 for(Method method : methods)&#123; System.out.println(&quot;成员函数---&gt;&quot;+method); &#125; Method m1 = s.getClass().getMethod(&quot;setName&quot;, String.class); m1.invoke(s, &quot;ashen&quot;);//设置name值为&quot;ashen&quot; Method m2 = s.getClass().getMethod(&quot;getName&quot;); String name = (String) m2.invoke(s); System.out.println(&quot;getName---&gt;&quot;+name);//输出name值 &#125;catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 结果输出","categories":[{"name":"技术","slug":"技术","permalink":"https://zgshen.me/categories/技术/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"https://zgshen.me/tags/Java基础/"}]},{"title":"Mysql存储过程","slug":"Mysql存储过程","date":"2017-02-25T16:00:00.000Z","updated":"2019-03-31T14:44:16.408Z","comments":true,"path":"2017/02/26/Mysql存储过程/","link":"","permalink":"https://zgshen.me/2017/02/26/Mysql存储过程/","excerpt":"当需要实现复杂的逻辑，需要写多条sql语句或写的sql比较复杂时，可以考虑使用存储过程来处理，最终返回需要的结果集。存储过程即一组SQL语句集。 存储过程的基本语法也不算复杂，以下为创建一个存储过程的模板","text":"当需要实现复杂的逻辑，需要写多条sql语句或写的sql比较复杂时，可以考虑使用存储过程来处理，最终返回需要的结果集。存储过程即一组SQL语句集。 存储过程的基本语法也不算复杂，以下为创建一个存储过程的模板123456789101112131415161718192021222324DROP PROCEDURE IF EXISTS TEST_FUNCTION;/*定义存储过程名称，设置入参，指定类型和大小*/CREATE PROCEDURE TEST_FUNCTION(in DATA_A INT(20),in DATA_B INT(20),in B_TYPE varchar(20))BEGIN /*DECLARE 关键字用于定义变量*/ DECLARE SUM int default 0; DECLARE t_error INTEGER DEFAULT 0; DECLARE CONTINUE HANDLER FOR SQLEXCEPTION SET t_error=1;/*异常标志*/ START TRANSACTION;/*启动事务*/ /*字符串的判断，STRCMP用法类似于C++*/ if STRCMP(B_TYPE,'SUM')=0 then begin SELECT DATA_A+DATA_B INTO SUM;/*INTO 把值放到变量中*/ SELECT SUM; end;/*一个begin对应一个end*/ end if;/*一个if对应一个end if*/ IF t_error = 1 THEN ROLLBACK;/*异常回滚*/ ELSE COMMIT;/*正常提交*/ END IF;END; 创建生成的样子 DEFINER的信息是’用户名’@’host’ 输入参数值测试 调用存储使用call命令","categories":[{"name":"技术","slug":"技术","permalink":"https://zgshen.me/categories/技术/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://zgshen.me/tags/数据库/"}]},{"title":"内部类相关——定义、匿名内部类、回调实现及静态内部类","slug":"内部类相关——定义、匿名内部类、回调实现及静态内部类","date":"2017-02-22T16:00:00.000Z","updated":"2019-03-03T14:48:45.836Z","comments":true,"path":"2017/02/23/内部类相关——定义、匿名内部类、回调实现及静态内部类/","link":"","permalink":"https://zgshen.me/2017/02/23/内部类相关——定义、匿名内部类、回调实现及静态内部类/","excerpt":"内部类，顾名思义就是在一个类中的类。内部类可以访问所在类的数据，包括私有数据，而又可以对其他类隐藏，在快速实现回调函数时可以使用匿名内部类，比较便捷。 1、以下为一个简单的内部类例子，内部类可以定义为私有以对其他类隐藏起来；可以用内部类来达到实现多继承的效果。需要注意的是，通过成员函数传入内部类的变量必须定义为final类型，以保证数据的一致性。","text":"内部类，顾名思义就是在一个类中的类。内部类可以访问所在类的数据，包括私有数据，而又可以对其他类隐藏，在快速实现回调函数时可以使用匿名内部类，比较便捷。 1、以下为一个简单的内部类例子，内部类可以定义为私有以对其他类隐藏起来；可以用内部类来达到实现多继承的效果。需要注意的是，通过成员函数传入内部类的变量必须定义为final类型，以保证数据的一致性。123456789101112131415161718192021222324public class Cat extends Walk&#123; //private私有类，继承Walk和Eat private class LittleCat extends Eat &#123; public void doSomething() &#123; System.out.println(\"Walking....Eating....\"); &#125; &#125; public static void main(String[] args) &#123; LittleCat lCat = new Cat().new LittleCat();//创建内部类对象方式，通过先创建所在外围类对象再创建内部类对象 lCat.doSomething(); &#125; public void event(final String name) &#123; class EatFish&#123; public void eat() &#123; //name = \"Tom\";//在这里修改会报错，name 必须为final类型，保证数据一致 System.out.println(name); &#125; &#125; EatFish test = new EatFish(); test.eat(); &#125;&#125; 两个父类：12public class Walk &#123;&#125; 12public class Eat &#123;&#125; 2、匿名内部类从名称可以知道匿名就是没有类名的类，匿名内部类用于快速调用接口或抽象类等等中的方法，不需要多写一个实现类来实现调用。 抽象类123public abstract class Dog &#123; abstract void eat();&#125; 接口123public interface Animal &#123; void eat();&#125; 测试类123456789101112131415161718192021222324252627public class AnonymousDemo &#123; public static void main(String[] args) &#123; /** * 通过创建的一个接口或抽象类分引用，快速便捷重写需要实现的方法，不需要先写一个实现类再实例化以调用方法 */ //实现接口方式 Animal dog = new Animal() &#123; @Override public void eat() &#123; System.out.println(&quot;like bone.&quot;); &#125; &#125;; dog.eat();//向上转型的实例，直接调用重写的eat方法 //继承抽象类的方式 Dog littleDog = new Dog() &#123; @Override void eat() &#123; System.out.println(&quot;I like bone.&quot;); &#125; &#125;; littleDog.eat(); &#125;&#125; 此外，Java的回调函数式可以通过匿名内部类来实现，比如以下例子 (1)封装的类和提供的接口封装给别人调用的类1234567891011121314151617181920212223242526public class Person &#123; private EatFood eatFood; /** * 普通方式，构造传递引用 */ public Person(EatFood eatSomething)&#123; this.eatFood = eatSomething;//构造时传入引用 &#125; /** * 普通方式，成员函数传递引用 */ public Person()&#123; &#125; public void setCallBack(EatFood eatSomething) &#123; this.eatFood = eatSomething;//用成员函数传入引用 &#125; //需要调用的方法 public void eatFood() &#123; eatFood.eat(); &#125;&#125; 调用类需要的接口定义123public interface EatFood &#123; void eat();&#125; (2)实际调用一般做法都会写一个类实现接口 1234567public class EatRice implements EatFood &#123; @Override public void eat() &#123; // TODO Auto-generated method stub System.out.println(&quot;It&apos;s time to eat rice.&quot;); &#125;&#125; 然后是实际使用的类123456789101112public class PeronEatTest &#123; public static void main(String[] args) &#123; //普通方式，构造传递引用 Person personOne = new Person(new EatRice());//EatRice实现类方式。多写一个方法传入也可 personOne.eatFood(); //普通方式，成员函数传递引用 Person personOne = new Person(); EatRice eatRice = new EatRice(); personOne.setCallBack(eatRice); personOne.eatFood();&#125; 如果使用匿名内部类就便捷了许多123456789101112public class PeronEatTest &#123; public static void main(String[] args) &#123; Person personTwo = new Person(new EatFood() &#123; @Override public void eat() &#123; // TODO Auto-generated method stub System.out.println(&quot;It&apos;s time to eat rice.&quot;); &#125; &#125;); personTwo.eatFood(); &#125;&#125; 3、静态内部类创建是不需要依赖于外围类，但也不能使用任何外围类的非static成员变量和方法 1234567891011121314151617181920212223242526272829public class Cat&#123; private String str = &quot;cat&quot;; private static String str_static = &quot;cat&quot;; private class LittleCat&#123; //public static String str_test = &quot;test&quot;;//错误，非静态内部类变量不能为静态 public static final String str_test = &quot;test&quot;;//但加上final就可以 public void doSomething() &#123; str = &quot;little cat&quot;; System.out.println(&quot;Walking....Eating....&quot;); &#125; &#125; static class BigCat&#123; public void doSomething() &#123; //str = &quot;little cat&quot;;//错误，静态内部类反问外围非静态变量和方法 str_static = &quot;big cat&quot;; System.out.println(&quot;I am a big cat.&quot;); &#125; &#125; public static void main(String[] args) &#123; LittleCat lCat = new Cat().new LittleCat();//依赖外围类 lCat.doSomething(); BigCat bigCat = new BigCat();//不依赖外围类 bigCat.doSomething(); &#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://zgshen.me/categories/技术/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"https://zgshen.me/tags/Java基础/"}]},{"title":"无题","slug":"0214广州","date":"2017-02-13T16:00:00.000Z","updated":"2019-03-31T14:42:52.357Z","comments":true,"path":"2017/02/14/0214广州/","link":"","permalink":"https://zgshen.me/2017/02/14/0214广州/","excerpt":"","text":"本命年暂且不用去想太多破事，认真过好今年 E时光上的广州","categories":[{"name":"生活","slug":"生活","permalink":"https://zgshen.me/categories/生活/"}],"tags":[{"name":"其他","slug":"其他","permalink":"https://zgshen.me/tags/其他/"}]},{"title":"鸡年大吉","slug":"除夕","date":"2017-01-26T16:00:00.000Z","updated":"2019-03-31T14:47:11.945Z","comments":true,"path":"2017/01/27/除夕/","link":"","permalink":"https://zgshen.me/2017/01/27/除夕/","excerpt":"","text":"2017除夕辞旧迎新新年快乐","categories":[{"name":"生活","slug":"生活","permalink":"https://zgshen.me/categories/生活/"}],"tags":[{"name":"其他","slug":"其他","permalink":"https://zgshen.me/tags/其他/"}]},{"title":"给博客换个主题","slug":"给博客换个主题","date":"2016-12-28T16:00:00.000Z","updated":"2019-03-03T14:49:35.817Z","comments":true,"path":"2016/12/29/给博客换个主题/","link":"","permalink":"https://zgshen.me/2016/12/29/给博客换个主题/","excerpt":"搭好了博客之后，想把博客换了个hexo主题，挑来挑去最后选了Litten的Yilia主题。事实好多主题都做得很棒，现在不管是网站和移动端的应用，都很注重页面展示和交互体验，由此前端的技术也是日新月异，作为一个后端，看得真是眼花缭乱。 转眼间2016也即将过去了，这年毕业了，开始工作，真正地靠自己生活着，做了许多事情，也学会很多东西。整体上马马虎虎，但事实还有许多事情没有做好，找个时间再写个年终总结吧。 加首歌试试 markdown真是好用啊。顺便加上多说评论。 以下测试","text":"搭好了博客之后，想把博客换了个hexo主题，挑来挑去最后选了Litten的Yilia主题。事实好多主题都做得很棒，现在不管是网站和移动端的应用，都很注重页面展示和交互体验，由此前端的技术也是日新月异，作为一个后端，看得真是眼花缭乱。 转眼间2016也即将过去了，这年毕业了，开始工作，真正地靠自己生活着，做了许多事情，也学会很多东西。整体上马马虎虎，但事实还有许多事情没有做好，找个时间再写个年终总结吧。 加首歌试试 markdown真是好用啊。顺便加上多说评论。 以下测试 12345public class HelloWorld &#123; public static void main(String[] args) &#123; System.out.println(\"欢迎来到啊深的博客。\"); &#125;&#125; 故人西辞黄鹤楼，烟花三月下扬州。孤帆远影碧空尽，惟见长江天际流。 16/12/29","categories":[{"name":"技术","slug":"技术","permalink":"https://zgshen.me/categories/技术/"}],"tags":[{"name":"博客","slug":"博客","permalink":"https://zgshen.me/tags/博客/"}]},{"title":"欢迎来到我的博客","slug":"hello-world","date":"2016-12-19T16:00:00.000Z","updated":"2019-03-03T14:44:50.389Z","comments":true,"path":"2016/12/20/hello-world/","link":"","permalink":"https://zgshen.me/2016/12/20/hello-world/","excerpt":"","text":"之前鼓捣服务器的时候买了个域名耍耍，空间到期之后域名一直放着，不久前才想起github上能搭个博客能用自定义域名，而且刚好又不需要备案，就鼓捣了这个博客。顺便把CSDN的博文同步过来试试，CSDN博客地址 http://blog.csdn.net/u012809062 。","categories":[{"name":"技术","slug":"技术","permalink":"https://zgshen.me/categories/技术/"}],"tags":[{"name":"其他","slug":"其他","permalink":"https://zgshen.me/tags/其他/"}]},{"title":"继承、多态、封装、抽象类与接口","slug":"继承、多态、封装、抽象类与接口","date":"2016-09-04T16:00:00.000Z","updated":"2019-03-03T14:49:39.616Z","comments":true,"path":"2016/09/05/继承、多态、封装、抽象类与接口/","link":"","permalink":"https://zgshen.me/2016/09/05/继承、多态、封装、抽象类与接口/","excerpt":"作为一门面向对象语言，继承和多态是Java重要的特性。继承封装了一些公共特性，实现代码复用，减少代码冗余；多态可以动态调整对象的调用，降低对象之间的依存关系；接口是一种规范，可以通过接口实现多继承的功能。一、继承 利用继承，人们可以基于已存在的类构造一个新类。继承已存在的类就是复用（继承）这些类的方法和域。在此基础上，还可以添加一些新的方法和域，以满足新的需求。这是Java程序设计中的一项核心技术。[java核心技术] 新建一个人物父类","text":"作为一门面向对象语言，继承和多态是Java重要的特性。继承封装了一些公共特性，实现代码复用，减少代码冗余；多态可以动态调整对象的调用，降低对象之间的依存关系；接口是一种规范，可以通过接口实现多继承的功能。一、继承 利用继承，人们可以基于已存在的类构造一个新类。继承已存在的类就是复用（继承）这些类的方法和域。在此基础上，还可以添加一些新的方法和域，以满足新的需求。这是Java程序设计中的一项核心技术。[java核心技术] 新建一个人物父类12345678910111213141516public class Person &#123; private int age; private String name; public Person(int age, String name)&#123; this.age = age; this.name = name; &#125; public void info()&#123; System.out.println(age); System.out.println(name); &#125; &#125; Teacher子类继承Person父类，关键字extends表示继承，extends表明正在构造的新类派生于一个已存在的类。已存在的类被称为超类（superclass）、基类（base class）或父类（parent class）；新类被称为子类（subclass）、派生类（derived class）或孩子类（child class）。 1234567891011121314151617181920212223242526public class Teacher extends Person &#123; //默认实现无参构造并可以不写，如果父类存在带参构造，则需要显式实现此构造 public Teacher(int age, String name) &#123; super(22, &quot;shen&quot;); // TODO Auto-generated constructor stub super.info(); &#125; //重写父类方法 @Override public void info()&#123; System.out.println(&quot;rewrite...&quot;); &#125; public static void main(String[] args) &#123; Teacher t = new Teacher(20, &quot;tutu&quot;); t.info();//子类拥有所有父类的成员变量，但private的成员变量没有访问权限 //t.age//private变量不可访问 &#125; &#125;输出结果：22shenrewrite... 二、多态实现多态有三个条件：要有继承、要有重写、父类引用指向子类对象。父类：12345678910public class Animal &#123; public void eat()&#123; System.out.println(&quot;eat food&quot;); &#125; public void walk()&#123; System.out.println(&quot;walk alone&quot;); &#125;&#125; 子类： 123456789101112131415161718192021222324252627282930public class Dog extends Animal &#123; //重写父类方法 @Override public void eat()&#123; System.out.println(&quot;eat bone&quot;); &#125; public void walk(String dog1)&#123; dog1 = &quot;tom&quot;; System.out.println(&quot;walk with &quot; + dog1); &#125; public static void main(String[] args) &#123; Animal dog = new Dog();//向上转型，父类引用指向子类对象 dog.eat(); dog.walk(); //dog.walk(&quot;jane&quot;);//只能调用父类存在的方法 Dog dd = (Dog)dog;//向下转型 dd.walk(); dd.walk(&quot;jane&quot;); &#125;&#125;输出结果：eat bonewalk alonewalk alonewalk with tom 多态可以使程序有良好的扩展，并可以对所有类的对象进行通用处理。三、封装在面向对象程式设计方法中，封装指一种将抽象性函式接口的实作细节部份包装、隐藏起来的方法。通常都使用getter和setter方法来实现，其他类要访问本类的私有成员变量都需要通过getter和setter方法。例实体类：1234567891011121314151617public class Person &#123; private int age; private String name; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; 测试类： 1234567891011121314public class Test &#123; public static void main(String[] args) &#123; Person t = new Person(); t.setAge(20); t.setName(&quot;shen&quot;); System.out.println(&quot;Age:&quot; + t.getAge() + &quot; name:&quot; + t.getName()); &#125; &#125;输出：Age:20 name:shen 四、抽象与接口1、我们知道，在面向对象世界中，所有的对象都是通过类来描述的，但是并不是所有的类都是来描述对象的。如果一个类没有足够的信息来描述一个具体的对象，而需要其他具体的类来支撑它，那么这样的类我们称它为抽象类。例： 12345678910111213141516public abstract class Animal &#123; private String name; private float weight; public Animal(String name, float weight)&#123; this.name = name; this.weight = weight; &#125; abstract void run();//抽象类不一定有抽象方法，但包含抽象方法的类一定要被声明为抽象类 public void eat()&#123; &#125;&#125; 继承： 12345678910111213141516171819202122public class Cat extends Animal&#123; public Cat(String name, float weight) &#123; super(name, weight); // TODO Auto-generated constructor stub &#125; //覆盖抽象方法 @Override void run() &#123; // TODO Auto-generated method stub System.out.println(&quot;run fast&quot;); &#125; public static void main(String[] args) &#123; //Animal cat = new Animal(&quot;tom&quot;, 20f);//错误,抽象类不能实例化 Cat cat = new Cat(&quot;tom&quot;, 20f); cat.run(); &#125; &#125; 另注：如果一个类包含抽象方法，那么该类必须是抽象类。任何子类必须重写父类的抽象方法，或者声明自身为抽象类。2、接口接口是抽象方法的集合。接口并不是类，一个类通过继承接口的方式，从而来继承接口的抽象方法。实现接口必须覆盖全部抽象方法，跟抽象类相似。但是java中不能通过extends实现多继承，可以通过实现多个接口来达到多继承的目的。1234public interface Person &#123; public void eat(); public void say();&#125; 实现：123456789101112public class Student implements Person &#123; @Override public void eat() &#123; // TODO Auto-generated method stub &#125; @Override public void say() &#123; // TODO Auto-generated method stub &#125;&#125; 注：接口是隐式抽象的，当声明一个接口的时候，不必使用abstract关键字。接口中每一个方法也是隐式抽象的，声明时同样不需要abstract关键子。接口中的方法都是公有的。","categories":[{"name":"技术","slug":"技术","permalink":"https://zgshen.me/categories/技术/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"https://zgshen.me/tags/Java基础/"}]},{"title":"集合","slug":"集合","date":"2016-08-12T16:00:00.000Z","updated":"2019-03-03T14:49:48.213Z","comments":true,"path":"2016/08/13/集合/","link":"","permalink":"https://zgshen.me/2016/08/13/集合/","excerpt":"一、概述 集合框架是Java一块很重要的内容，对常用的数据结构做了规范和实现。对象封装了数据，许多对象则构成了所谓集合。Java集合类库构成了集合类的框架。它为集合的实现者定义了大量的接口和抽象类，并且对其中的某些机制给予了描述。 集合框架的接口和实现类：","text":"一、概述 集合框架是Java一块很重要的内容，对常用的数据结构做了规范和实现。对象封装了数据，许多对象则构成了所谓集合。Java集合类库构成了集合类的框架。它为集合的实现者定义了大量的接口和抽象类，并且对其中的某些机制给予了描述。 集合框架的接口和实现类： 二、Iterator接口Iterator接口与Collection系列、Map系列的集合不一样：Collection系列集合、Map系列集合主要用于盛装其他对象，而Iterator则主要用于遍历（即迭代访问）Collection集合中的元素，Iterator对象也被称为迭代器。[引]Iterator接口定义了四个方法–boolean hasNext()：如果被迭代的集合还元素没有被遍历，则返回true。–Object next()：返回集合里下一个元素。–void remove() ：删除集合里上一次next方法返回的元素–void forEachRemaining(Consumer action)：这是Java 8为Iterator新增的默认方法，该方法可使用Lambda表达式来遍历集合元素。 123456789101112131415161718192021222324252627282930313233/** * @author shen * @desc Iterator接口 * @date 2016年8月23日 */public class IteratorTest &#123; public static void main(String[] args) &#123; //Iterator是Collection父接口，可如此创建集合 Collection&lt;Object&gt; animals = new HashSet&lt;&gt;(); //添加元素 animals.add(&quot;cat&quot;); animals.add(&quot;dog&quot;); animals.add(&quot;pig&quot;); //使用Lambda表达式遍历集合(java1.8新特性) animals.forEach(obj -&gt; System.out.println(&quot;Lambda迭代输出：&quot; + obj)); //iterator()方法获取迭代器 Iterator&lt;Object&gt; data = animals.iterator(); while(data.hasNext())&#123; Object subData = data.next(); if(&quot;cat&quot;.equals(subData))&#123; data.remove();//移除元素 &#125; System.out.println(&quot;迭代器输出：&quot; + subData); &#125; System.out.println(animals); &#125;&#125; 输出： 三、Collection接口 Collection不提供接口的任何直接实现，一个Collection代表一组Object，但它提供更加具体的子接口如List和Set，而继承自它们的 ArrayList, Vector, HashTable, HashMap等实现类才可被实例化。1、List接口List是一个有序集合（ordered collection）。元素可以添加到容器中某个特定的位置。将对象放置在某个位置上可以采用两种方式：使用整数索引或使用列表迭代器。[引 java核心技术]List接口实现类主要有：ArrayList、Vector、LinkedList。(1)ArrayListArrayList是List接口的可变数组的实现，其操作基本是对数组的操作，ArrayList是线程不安全的。ArrayList包装了许多的方法，包括元素的增加移除、插入移动、转换数组等等： 12345678910111213141516171819202122232425262728293031323334353637/** * @author shen * @desc * @date 2016年8月23日 */public class ListTest &#123; public static void main(String[] args) &#123; List&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add(&quot;1&quot;);//使用list时默认长度置为10 list.add(&quot;2&quot;); list.add(&quot;3&quot;); list.add(&quot;4&quot;); list.add(&quot;5&quot;); System.out.println(&quot;list输出：&quot;+list); list.remove(4);//移除元素 System.out.println(&quot;移除元素之后的list：&quot;+list); Object[] arr = list.toArray();//转换为数组 System.out.println(&quot;数组元素输出：&quot;+arr[0]); List&lt;String&gt; c = new ArrayList&lt;&gt;(4);//预计有4个元素而创建 c.add(&quot;6&quot;); c.add(&quot;7&quot;); c.add(&quot;8&quot;); c.add(&quot;9&quot;); c.add(&quot;10&quot;);//超过5个元素list会增加原来长度一半个元素,目前即长度为6 list.addAll(c);//增加一组数据,数据类型应相同 System.out.println(list); Iterator&lt;String&gt; data = list.iterator();//获取迭代器 System.out.println(&quot;迭代输出：&quot;); data.forEachRemaining(action -&gt; System.out.print(action+&quot; &quot;)); &#125;&#125; 输出：ArrayList的各种操作虽然很方便，但是ArrayList的插入和删除，会导致内部数据大量移位，而扩容则需要新建一个ArrayList将原来的数据复制过去,会影响性能。如果我们已经知道需要的元素个数，我们可以初始化时指定ArrayList的容量，这样可以有效的避免数组多次扩充，从而提高效率。(2)VectorVector类提供了实现可增长数组的功能，随着更多元素加入其中，数组变的更大。在删除一些元素之后，数组变小,而不像ArrayList的扩容方式，基本用法与ArrayList相同。Vector是同步类，是线程安全的。(3)LinkedListLinkedList是list的链表实现，列表中的每个节点都包含了对前一个和后一个元素的引用，除了大部分与ArrayList相同的方法，LinkedList还有一些其特有的方法，并且LinkedList在添加和删除元素时具有比ArrayList更好的性能，但在get数据时更慢。LinkedList适用于没有大规模的随机读取，大量的增加/删除操作。[引] 12345678910111213141516171819public class LinkTest &#123; public static void main(String[] args) &#123; LinkedList&lt;String&gt; link = new LinkedList&lt;&gt;(); link.add(&quot;a&quot;); link.add(&quot;b&quot;); link.add(&quot;c&quot;); link.add(&quot;d&quot;); link.add(&quot;e&quot;); System.out.println(&quot;第一个元素：&quot;+link.getFirst()+&quot; 最后一个元素：&quot;+link.getLast()); link.remove(1); System.out.println(link); link.add(3, &quot;zhiding&quot;); System.out.println(link); &#125;&#125; 输出： 2、Set接口由于Set接口提供的数据结构是数学意义上集合概念的抽象，因此它需要支持对象的添加、删除，而不需提供随机访问。Set具有与Collection完全一样的接口，因此没有任何额外的功能。实际上Set就是Collection，只是行为不同。Set不包含重复的元素。Set的实现类主要有：HashSet，TreeSet，LinkedHashSet(1)HashSet不保证set的迭代顺序，不保证该顺序永恒不变，因此HashSet也没有get方法。此类允许使用null元素，底层是使用HashMap实现的。 1234567891011121314151617181920212223242526public static void main(String[] args) &#123; HashSet&lt;String&gt; set = new HashSet&lt;&gt;(); set.add(&quot;adf&quot;); set.add(&quot;bhf&quot;); set.add(&quot;c32&quot;); set.add(&quot;c32&quot;);//有重复元素，添加不了 set.add(null);//null也只允许只有一个 System.out.println(set); for(String str : set)&#123; System.out.print(str +&quot; &quot;); &#125; System.out.println(); Iterator&lt;String&gt; iterator = set.iterator(); while(iterator.hasNext())&#123; String data = iterator.next(); System.out.print(data +&quot; &quot;); &#125; &#125;输出：[null, bhf, adf, c32]null bhf adf c32 null bhf adf c32 (2)TreeSetTreeSet元素自然排序，底层是使用TreeMap实现的，自定义要显示Comparable接口。TreeSet可以给集合中的元素进行指定方式的排序，保证元素唯一性。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/** * @author shen * @desc 测试类，实现Comparable&lt;T&gt;接口 * @date 2016年8月24日 */public class User implements Comparable&lt;User&gt;&#123; private String name; private int age; //构造 public User(String name,int age)&#123; this.name = name; this.age = age; &#125; //实现类 @Override public int compareTo(User user) &#123; if(user == null) throw new NullPointerException(); if(this.age &gt; user.age) return 1; if(this.age &lt; user.age) return -1; return 0; &#125; //重写toString @Override public String toString() &#123; return &quot;User [name=&quot; + name + &quot;, age=&quot; + age + &quot;]&quot;; &#125; &#125;//测试public static void main(String[] args) &#123; Set&lt;User&gt; set = new TreeSet&lt;User&gt;(); User user1 = new User(&quot;Tom&quot;, 20); User user2 = new User(&quot;Jack&quot;, 21); User user3 = new User(&quot;Dave&quot;, 22); User user4 = new User(&quot;Jane&quot;, 12); set.add(user1); set.add(user1);//重复，添加不了 set.add(user2); set.add(user3); set.add(user4); System.out.println(&quot;按年龄大小输出：&quot;); System.out.println(set); &#125;输出按年龄大小输出：[User [name=Jane, age=12], User [name=Tom, age=20], User [name=Jack, age=21], User [name=Dave, age=22]] (3)LinkedHashSetLinkedHashSet集合同样是根据元素的hashCode值来决定元素的存储位置，但是它同时使用链表维护元素的次序。这样使得元素看起 来像是以插入顺序保存的，也就是说，当遍历该集合时候，LinkedHashSet将会以元素的添加顺序访问集合的元素。LinkedHashSet在迭代访问Set中的全部元素时，性能比HashSet好，但是插入时性能稍微逊色于HashSet。[引] 四、Map接口在Collection实现中保存的直接是一个个对象，二在Map实现中保存的是一对对象，以键值对key-value的方式关联着。Map的常用实现类有HashMap，HashTabel和TreeMap。1、HashMapHashMap是基于哈希表的Map接口的非同步实现，其中元素表现无序，特别是它不保证该顺序恒久不变。HashMap会利用对象的hashCode来快速找到key。12345678910111213141516171819202122232425262728293031323334353637383940414243444546public static void main(String[] args) &#123; //使用实现类创建，键值指定对象类型 HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;(); map.put(&quot;name&quot;, &quot;shen&quot;); map.put(&quot;age&quot;, &quot;20&quot;); map.put(&quot;age&quot;, &quot;19&quot;);//相同键多次存入数据覆盖 map.put(&quot;weight&quot;, &quot;100&quot;); map.put(null, &quot;空&quot;);//允许空键值 map.put(null, null); System.out.println(map); //对map集合的遍历，可取出具体的键和对应值 for(Entry&lt;String, String&gt; element:map.entrySet())&#123; String key = element.getKey(); String value = element.getValue(); Class&lt;? extends Entry&gt; classData = element.getClass(); System.out.println(key + &quot;---- &quot; + value + &quot;---- &quot; + classData.getName()); &#125; //使用接口创建，不关心具体实现，只有在使用才具体实现 //键值的值一般设为Object，不关心什么类型的数据，当然，获取需要具体数据类型或对象需要转化 Map&lt;String, Object&gt; mapData = null;//new HashMap&lt;&gt;(); mapData = new HashMap&lt;&gt;(); mapData.put(&quot;name&quot;, &quot;Jack&quot;); mapData.put(&quot;age&quot;, 21); mapData.put(&quot;weight&quot;, 110.5); System.out.println(mapData); System.out.println(&quot;获取name值:&quot; + mapData.get(&quot;name&quot;)); Set&lt;String&gt; keys = mapData.keySet(); System.out.println(&quot;获取所有key:&quot; + keys); Collection&lt;Object&gt; values = mapData.values(); System.out.println(&quot;获取所有value:&quot; + values); &#125;输出：&#123;null=null, name=shen, weight=100, age=19&#125;null---- null---- java.util.HashMap$Nodename---- shen---- java.util.HashMap$Nodeweight---- 100---- java.util.HashMap$Nodeage---- 19---- java.util.HashMap$Node&#123;name=Jack, weight=110.5, age=21&#125;获取name值:Jack获取所有key:[name, weight, age]获取所有value:[Jack, 110.5, 21] 2、HashTabelHashTable在很大程度事实上和HashMap的实现差不多，主要区别是HashMap采用异步处理方式，性能更高，而HashTabel采用同步处理方式，性能较低。HashTabel属于线程安全类而HashMap属于线程不安全类。[参考] 3、TreeMapTreeMap是可排序的Map集合按照集合中的key进行排序，key不允许重复。TreeMap是红黑树基于Map接口的实现。关于TreeMap红黑树参考,初次接触不容易理解，多查资料。","categories":[{"name":"技术","slug":"技术","permalink":"https://zgshen.me/categories/技术/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"https://zgshen.me/tags/Java基础/"}]},{"title":"类与对象","slug":"类与对象","date":"2016-07-08T16:00:00.000Z","updated":"2019-03-03T14:49:26.391Z","comments":true,"path":"2016/07/09/类与对象/","link":"","permalink":"https://zgshen.me/2016/07/09/类与对象/","excerpt":"一、Java的对象和类Java作为一种面向对象语言，有类、对象、实例、方法、继承、重载、抽象、多态、封装的基本概念。1、类(1)类是Java的核心和本质，封装、继承、多态和抽象几大特性都离不开类，可以把类看成是对象的模板。(2)类中的变量。包括局部变量、全局变量和类变量。 局部变量：定义在方法中的变量，作用域为本方法中。 成员变量：定义在类中方法外的变量，作用域为本类。 类变量(静态变量)：类变量也声明在类中，方法体之外，但必须声明为static类型(static表示全局的、静态的)。","text":"一、Java的对象和类Java作为一种面向对象语言，有类、对象、实例、方法、继承、重载、抽象、多态、封装的基本概念。1、类(1)类是Java的核心和本质，封装、继承、多态和抽象几大特性都离不开类，可以把类看成是对象的模板。(2)类中的变量。包括局部变量、全局变量和类变量。 局部变量：定义在方法中的变量，作用域为本方法中。 成员变量：定义在类中方法外的变量，作用域为本类。 类变量(静态变量)：类变量也声明在类中，方法体之外，但必须声明为static类型(static表示全局的、静态的)。 123456789101112131415161718192021222324252627282930/** * @author shen * @desc test * @date 2016年7月10日 */public class Book &#123; static int num = 0;//类变量 static final String type = &quot;children&quot;;//用final变量只能被初始化一次，之后不能再赋值 String str=&quot;this is a book&quot;;//实例变量 public void borrow()&#123; int i = 0;//局部变量 &#125; public static void rend()&#123; //静态方法，无需创建对象就能使用 System.out.println(&quot;this is a static method.&quot;); &#125; public static void main(String[] args) &#123; rend();//直接调用 System.out.println(&quot;this is a main function.&quot;); &#125; static &#123; //静态代码块，类加载时调用 System.out.println(&quot;this is a static code block.&quot;); &#125;&#125; 结果：(3)构造方法 每个类都有构造方法，如果没有显式定义构造方法，编译器会默认为类创建一个不带参的构造方法(若子类继承有带参构造方法的父类，需要显式调用父类构造方法)。 构造方法名必须与类名相同，一个类中可以有多个构造方法(参数不同)，创建对象时至少一个构造方法。2、对象 对象的创建：声明，声明类的类型和名称；实例化，使用new创建一个对象；初始化，创建对象时会调用构造方法初始化对象 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889/** * @author shen * @desc test * @date 2016年7月10日 */public class User &#123; private String type = &quot;student&quot;; private String name;//私有属性只能在本类获取到 private int age; public int height;//公有属性其他类也能获取到 public int getHeight() &#123; return height; &#125; public void setHeight(int height) &#123; this.height = height; &#125; //Javabean的规范，通过getter和setter对数据进行封装 public String getType() &#123; return type; &#125; public void setType(String type) &#123; this.type = type; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public User()&#123; //无参构造方法 &#125; public User(String num)&#123; //带参构造 &#125; public User(String name,int age)&#123; //参数个数不同的构造 this.name = name; this.age = age; &#125; //普通方法 public void borrow(String bookName)&#123; //bookName为方法体中的局部变量 System.out.println(this.name + &quot; borrow a book :&quot; + bookName ); &#125; public static void main(String[] args) &#123; User jack = new User();//默认的无参构造创建对象 jack.age = 20;//私有属性，只能在本类使用这种方式 jack.name = &quot;jack&quot;; //公有属性其他类也能获取到，暴露了数据细节。将属性定义为private并使用getter和setter方法隐藏数据的细节(Java的封装特性) jack.height = 170; jack.borrow(&quot;Java code&quot;); System.out.println(jack.type); User jane = new User(); jane.setAge(19);//Javabean规范，实现对数据细节的隐藏封装 jane.setName(&quot;jane&quot;); jane.setType(&quot;teacher&quot;); jane.borrow(&quot;C prime plus&quot;); System.out.println(jane.type); User tom = new User(&quot;tom&quot;, 21);//使用带参构造创建对象 tom.borrow(&quot;C++ prime plus&quot;); &#125; &#125; 结果： 二、基本规则1、一个源文件中只能有一个public类，可以有多个非public类，并且public类名必须与源文件名称相同2、包与import语句(1)Java包主要是用来给类分类，创建包使用package语句实现。包也有基本的命名规则，根据公司或个人名、项目名、模块名等命名。(2)import语句。import语句就是用来提供一个合理的路径，使得编译器可以找到某个类，有点类似与c的头文件和c++的命名空间。","categories":[{"name":"技术","slug":"技术","permalink":"https://zgshen.me/categories/技术/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"https://zgshen.me/tags/Java基础/"}]},{"title":"字符相关","slug":"字符相关","date":"2016-07-08T16:00:00.000Z","updated":"2019-03-03T14:49:08.479Z","comments":true,"path":"2016/07/09/字符相关/","link":"","permalink":"https://zgshen.me/2016/07/09/字符相关/","excerpt":"一、字符类型char是Java的一种基本数据类型，也是Java中的保留字。char在Java中占两个字节，无符号类型，是16位二进制Unicode字符。char是类型表示的是字符，不是字符串；char类型变量值只能用单引号来表示，不可使用双引号；即表示单引号内的单个字符。","text":"一、字符类型char是Java的一种基本数据类型，也是Java中的保留字。char在Java中占两个字节，无符号类型，是16位二进制Unicode字符。char是类型表示的是字符，不是字符串；char类型变量值只能用单引号来表示，不可使用双引号；即表示单引号内的单个字符。 12345678910111213141516171819202122232425262728/** * @author shen * @desc char test * @date 2016年7月15日 */public class CharTest &#123; public static void main(String[] args) &#123; //单引号内的单个字符 char test = &apos;C&apos;; System.out.println(test); //数组 char cha[] = &#123;&apos;J&apos;,&apos;a&apos;,&apos;v&apos;,&apos;a&apos;&#125;; System.out.println(cha); //Unicode编码，每一个字符用16位2进制数标识 char ucode = &apos;\\u4F60&apos;;//20320 char hao = &apos;\\u597d&apos;;//22909 System.out.print(ucode); System.out.println(hao); //转换成的对应值 System.out.println( ucode + hao); &#125;&#125;由于其编码方式，编码方式最多有65536种，远不足以使用，以及在数据库存储的一些问题，在一般情况下，char在java中的实际使用比较少，也并不推荐使用。 二、字符串类1、String(1)String类表示字符串，是字符串常量(另:常量池)，其值在创建后不能改变，因此Stirng对象创建后是不可变的，直至到被GC回收。(2)创建String对象 1234567891011121314public class StringTest &#123; public static void main(String[] args) &#123; String str1 = &quot;Java&quot;;//直接创建 String str2 = new String();//面向对象基本创建方法,有时浪费内存 str2 = &quot;C++&quot;; String str3 = new String(&quot;C&quot;);//String类提供许多构造创建方法和其他方法,详JDK源码 System.out.println(str1+&quot;--&quot;+str2+&quot;--&quot;+str3); &#125; &#125; (3)常见方法I.获取字符串长度与某个字符 123String str = &quot;Java Code&quot;;str.charAt(0);//获取某个下标对应字符str.length();//字符串长度 II.str.compareTo方法 该方法的作用是比较两个字符串的大小，比较的原理是依次比较每个字符的字符编码。首先比较两个字符串的第一个字符，如果第一个字符串的字符编码大于第二个的字符串的字符编码，则返回大于0的值，如果小于则返回小于0的值，如果相等则比较后续的字符，如果两个字符串中的字符编码完全相同则返回0。 123String data1 = &quot;Javi&quot;;String data2 = &quot;Java&quot;;int value = data1.compareTo(data2); III.截取方法 123String str = &quot;Java Code&quot;;String subStr = str.substring(7);//截取得到从某个下标之后的字符串String sub = str.substring(0, 5);//截取区间之内的字符串 IV.连接方法 12345String st1 = &quot;Java&quot;;String st2 = &quot;Code&quot;;String st = st1.concat(st2);//连接组成一个新的字符串JavaCodeString stt = st1+st2;//更直接的做法JavaCodeString sst = st1+007;//参与连接中有字符串按字符串连接Java007 V.查找方法 123String str = &quot;Java Code&quot;;int i = str.indexOf(&apos;o&apos;);//某个在字符串第一次出现的下标,不存在则返回-1int j = str.indexOf(&apos;o&apos;, 7);//从第几个字符开始查,返回下标，不存在则返回-1 VI.replace方法 该方法的作用是替换字符串中所有指定的字符，然后生成一个新的字符串。经过该方法调用以后，原来的字符串不发生改变。12String str = &quot;Java Code&quot;;String s = str.replace(&quot;Java&quot;, &quot;C++&quot;);//把Java代替成C++ VII.split方法 以特定的分隔符分隔字符串，生成一个 数组。 12345String data = &quot;java,c++,c,c#&quot;;String arr[] = data.split(&quot;,&quot;);for(int k = 0;k&lt;arr.length;k++)&#123; System.out.println(arr[k]);&#125; 2、Stringbuffer 同样是字符串类，Stringbuffer 是字符串变量，实现方式与String有所不同，在进行处理字符串时不生成新的对象。在存储和操作字符串操作比String更合适。I.字符串拼接 1234StringBuffer data = new StringBuffer(&quot;The&quot;);//创建对象StringBuffer data1 = data.append(&quot; Great&quot;);//拼接方法String str = &quot; Wall&quot;;data1.append(str).append(&quot;!&quot;); II.deleteCharAt方法 此外，字符串操作相关的方法还有insert插入、reverse反转倒序、setCharAt修改某个下标上的字符、trimToSize将StringBuffer对象的中存储空间缩小到和字符串长度一样的长度，减少空间的浪费。3、Stringbuilder Stringbuilder和StringBuffer基本类似，相关方法也一样 4、String、StringBuffer和Stringbuilder的具体区别[以下复制,来自其他博主总结]String：字符串常量StringBuffer：字符创变量，线程安全StringBuilder：字符创变量，非线程安全 如果要操作少量的数据用String单线程操作字符串缓冲区下操作大量数据StringBuilder多线程操作字符串缓冲区下操作大量数据StringBuffer5、其他[引用]I.字符串比较”==”与equal()方法“==” 判断两个引用的是不是同一个内存地址(同一个物理对象).equals 判断两个字符串的值是否相等.除非你想判断两个string引用是否同一个对象,否则应该总是使用 equals()方法.II.密码及其他问题上char[]优先于String原因 String是不可变对象, 意思是一旦创建,那么整个对象就不可改变. 即使新手觉得String引用变了,实际上只是(指针)引用指向了另一个(新的)对象. 而程序员可以明确地对字符数组进行修改,因此敏感信息(如密码)不容易在其他地方暴露(只要你用完后对char[]置0).","categories":[{"name":"技术","slug":"技术","permalink":"https://zgshen.me/categories/技术/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"https://zgshen.me/tags/Java基础/"}]},{"title":"Java 简介和开发环境","slug":"Java 简介和开发环境","date":"2016-06-30T16:00:00.000Z","updated":"2019-03-03T14:45:01.632Z","comments":true,"path":"2016/07/01/Java 简介和开发环境/","link":"","permalink":"https://zgshen.me/2016/07/01/Java 简介和开发环境/","excerpt":"一、定义与特点定义：Java是一门面向对象编程语言，不仅吸收了C++语言的各种优点，还摒弃了C++里难以理解的多继承、指针等概念，因此Java语言具有功能强大和简单易用两个特征。Java语言作为静态面向对象编程语言的代表，极好地实现了面向对象理论，允许程序员以优雅的思维方式进行复杂的编程。[Java疯狂讲义]特点：主要特点是面向对象和可移植等等，广泛应用于web应用程序(JavaEE相关)、嵌入式(安卓相关)，桌面程序、分布式系统等等。","text":"一、定义与特点定义：Java是一门面向对象编程语言，不仅吸收了C++语言的各种优点，还摒弃了C++里难以理解的多继承、指针等概念，因此Java语言具有功能强大和简单易用两个特征。Java语言作为静态面向对象编程语言的代表，极好地实现了面向对象理论，允许程序员以优雅的思维方式进行复杂的编程。[Java疯狂讲义]特点：主要特点是面向对象和可移植等等，广泛应用于web应用程序(JavaEE相关)、嵌入式(安卓相关)，桌面程序、分布式系统等等。二、开发工具和开发环境JDK：Java开发包或Java开发工具，编写Java程序必须，已包含JRE。JRE：Java运行环境，运行编写完毕的Java程序。JDK的安装(Windows系统,Java8)1、首先到oracle官网下载与计算机系统对应的Java SE的JDK即可。2、安装、配置环境变量配置JAVA_HOME的环境变量：新建JAVA_HOME一个变量，路径为JDK的安装路径，指定到jdk文件夹jdk的版本是1.8，在1.6版本之后的jdk都不必配置classpath环境变量了。3、基本命令win+r运行cmd，输入java命令，可以看到各种选项命令 输入java -version可以看到当前安装的jdk版本信息 javac命令，各种编译选项三、基本数据类型1、Java有八种基本数据类型，包括byte字节类型、int整形、short短整形、long长整形、char字符型、float浮点型(单精度)、double双精度类型、boolean布尔型。2、基本知识一个字节等于8位，一个字节等于256个数，就是-128到127一共256。kB就是kBytesBytes就是“字节”的意思！K就是千的意思，因为计算机是通过二进制来计算，10个1正好是10241111111111（二进制）=1024（十进制）1Bytes（字节）=8bit（比特）一个英文字母或一个阿拉伯数字就是一个字符，占用一个字节一个汉字就是两个字符，占用两个字节。3、数据类型转换byte-&gt;shortchar-&gt;int-&gt;longfloat-&gt;doubleint-&gt;floatlong-&gt;double范围小的转到范围大的范围大的转换到范围小的会失去精度","categories":[{"name":"技术","slug":"技术","permalink":"https://zgshen.me/categories/技术/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"https://zgshen.me/tags/Java基础/"}]},{"title":"spring springmvc mybatis 整合","slug":"spring springmvc mybatis 整合","date":"2016-04-09T16:00:00.000Z","updated":"2019-03-07T02:07:14.259Z","comments":true,"path":"2016/04/10/spring springmvc mybatis 整合/","link":"","permalink":"https://zgshen.me/2016/04/10/spring springmvc mybatis 整合/","excerpt":"最近鼓捣ssm框架的东西，写篇博文记录。环境 apache-tomcat-8.0.33、jdk1.8.0_05 maven Dynamic Web Module 2.51、各个xml配置文件的配置(1)pom.xml 配置清单文件连接池用的阿里巴巴Druid，数据库mysql，指定jdk编译版本1.8","text":"最近鼓捣ssm框架的东西，写篇博文记录。环境 apache-tomcat-8.0.33、jdk1.8.0_05 maven Dynamic Web Module 2.51、各个xml配置文件的配置(1)pom.xml 配置清单文件连接池用的阿里巴巴Druid，数据库mysql，指定jdk编译版本1.8 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;cn.shen&lt;/groupId&gt; &lt;artifactId&gt;ssmdemo&lt;/artifactId&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;ssmdemo Maven Webapp&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;dependencies&gt; &lt;!-- 添加spring依赖，对应版本号jar包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;4.1.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 添加tomcat下servlet-api依赖,对应版本 --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 添加jtl支持 --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 添加Spring支持 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;4.1.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;4.1.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;4.1.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;4.1.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;4.1.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;4.1.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;4.1.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;4.1.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;4.1.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;4.1.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 添加日志支持 --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.7.12&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 添加mybatis支持 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- jdbc驱动包 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.37&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 添加连接池druid支持 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.0.16&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;ssmdemo&lt;/finalName&gt; &lt;!-- 指定jdk编译器版本 --&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.1&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; (2)web.xml配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance http://www.springmodules.org/schema/cache/springmodules-cache.xsd http://www.springmodules.org/schema/cache/springmodules-ehcache.xsd &quot; xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot; xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot; id=&quot;WebApp_ID&quot; version=&quot;2.5&quot;&gt; &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt; &lt;!-- Spring配置文件 --&gt; &lt;!-- --&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;!-- 解决工程编码过滤器 --&gt; &lt;filter&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- Spring监听器 --&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- 添加对springmvc的支持 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-mvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;async-supported&gt;true&lt;/async-supported&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt; &lt;url-pattern&gt;*.html&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; (3)mybatis配置 12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;!-- 别名 --&gt; &lt;typeAliases&gt; &lt;package name=&quot;cn.web.open.model&quot;/&gt; &lt;/typeAliases&gt;&lt;/configuration&gt; (4)springmvc配置 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:jee=&quot;http://www.springframework.org/schema/jee&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd http://www.springframework.org/schema/jee http://www.springframework.org/schema/jee/spring-jee-4.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd&quot;&gt; &lt;!-- 使用注解的包，包括子集 --&gt; &lt;context:component-scan base-package=&quot;cn.web.open.controller&quot; /&gt; &lt;!-- 开启注解 --&gt; &lt;mvc:annotation-driven/&gt; &lt;mvc:resources mapping=&quot;/static/**&quot; location=&quot;/static/&quot;/&gt; &lt;!-- 视图解析器 --&gt; &lt;bean id=&quot;viewResolver&quot; class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;prefix&quot; value=&quot;/&quot; /&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 文件上传解析器 id 必须为multipartResolver --&gt; &lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt; &lt;property name=&quot;defaultEncoding&quot; value=&quot;UTF-8&quot;/&gt; &lt;property name=&quot;maxUploadSize&quot; value=&quot;10000000&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; (5)数据源及整合配置applicationContext.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:jee=&quot;http://www.springframework.org/schema/jee&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd http://www.springframework.org/schema/jee http://www.springframework.org/schema/jee/spring-jee-4.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd&quot;&gt; &lt;!-- 配置数据源 ,连接池用的阿里druid--&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;!-- &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://IP+数据库&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;用户名&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;密码&quot;/&gt; --&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://121.42.57.186:3306/blog&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;shen200800&quot;/&gt; &lt;/bean&gt; &lt;!-- 配置mybatis的sqlSessionFactory --&gt; &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt; &lt;!-- 自动扫描mappers.xml文件 --&gt; &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:mappers/*.xml&quot;&gt;&lt;/property&gt; &lt;!-- mybatis配置文件 --&gt; &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- DAO接口所在包名，Spring会自动查找其下的类 --&gt; &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; &lt;property name=&quot;basePackage&quot; value=&quot;cn.web.open.dao&quot; /&gt; &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- (事务管理)transaction manager, use JtaTransactionManager for global tx --&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt; &lt;/bean&gt; &lt;!-- 5. 使用声明式事务 transaction-manager：引用上面定义的事务管理器--&gt; &lt;tx:annotation-driven transaction-manager=&quot;txManager&quot; /&gt; &lt;!-- 配置事务通知属性 --&gt; &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt; &lt;!-- 定义事务传播属性 --&gt; &lt;tx:attributes&gt; &lt;tx:method name=&quot;insert*&quot; propagation=&quot;REQUIRED&quot; /&gt; &lt;tx:method name=&quot;update*&quot; propagation=&quot;REQUIRED&quot; /&gt; &lt;tx:method name=&quot;edit*&quot; propagation=&quot;REQUIRED&quot; /&gt; &lt;tx:method name=&quot;save*&quot; propagation=&quot;REQUIRED&quot; /&gt; &lt;tx:method name=&quot;add*&quot; propagation=&quot;REQUIRED&quot; /&gt; &lt;tx:method name=&quot;new*&quot; propagation=&quot;REQUIRED&quot; /&gt; &lt;tx:method name=&quot;set*&quot; propagation=&quot;REQUIRED&quot; /&gt; &lt;tx:method name=&quot;remove*&quot; propagation=&quot;REQUIRED&quot; /&gt; &lt;tx:method name=&quot;delete*&quot; propagation=&quot;REQUIRED&quot; /&gt; &lt;tx:method name=&quot;change*&quot; propagation=&quot;REQUIRED&quot; /&gt; &lt;tx:method name=&quot;check*&quot; propagation=&quot;REQUIRED&quot; /&gt; &lt;tx:method name=&quot;get*&quot; propagation=&quot;REQUIRED&quot; read-only=&quot;true&quot; /&gt; &lt;tx:method name=&quot;find*&quot; propagation=&quot;REQUIRED&quot; read-only=&quot;true&quot; /&gt; &lt;tx:method name=&quot;load*&quot; propagation=&quot;REQUIRED&quot; read-only=&quot;true&quot; /&gt; &lt;tx:method name=&quot;*&quot; propagation=&quot;REQUIRED&quot; read-only=&quot;true&quot; /&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!-- 配置事务切面 --&gt; &lt;aop:config&gt; &lt;aop:pointcut id=&quot;serviceOperation&quot; expression=&quot;execution(* cn.web.open.service.*.*(..))&quot; /&gt; &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;serviceOperation&quot; /&gt; &lt;/aop:config&gt; &lt;!-- 自动扫描 --&gt; &lt;context:component-scan base-package=&quot;cn.web.open.service&quot; /&gt;&lt;/beans&gt; 2、工程结构(1)分层结构 (2)实体类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package cn.web.open.model;import java.util.Date;public class User &#123; private String userCode; private String userName; private String userPwd; private String email; private String address; private Date userBorn; public String getUserCode() &#123; return userCode; &#125; public void setUserCode(String userCode) &#123; this.userCode = userCode; &#125; public String getUserName() &#123; return userName; &#125; public void setUserName(String userName) &#123; this.userName = userName; &#125; public String getUserPwd() &#123; return userPwd; &#125; public void setUserPwd(String userPwd) &#123; this.userPwd = userPwd; &#125; public String getEmail() &#123; return email; &#125; public void setEmail(String email) &#123; this.email = email; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125; public Date getUserBorn() &#123; return userBorn; &#125; public void setUserBorn(Date userBorn) &#123; this.userBorn = userBorn; &#125; &#125; dao接口 123456package cn.web.open.dao;import cn.web.open.model.User;public interface UserDao &#123; User findById(String code,String pwd);&#125; service接口 1234567package cn.web.open.service;import cn.web.open.model.User;public interface UserService &#123; User findById(String code,String pwd);&#125; service实现类,@Resource注入dao 12345678910111213141516171819package cn.web.open.service.impl;import javax.annotation.Resource;import org.springframework.stereotype.Service;import cn.web.open.dao.UserDao;import cn.web.open.model.User;import cn.web.open.service.UserService;@Service(&quot;userService&quot;)public class UserServiceImpl implements UserService&#123; @Resource private UserDao userDao; public User findById(String code,String pwd) &#123; User user = userDao.findById(code,pwd); return user; &#125;&#125; 控制器controller 12345678910111213141516171819202122232425262728293031323334package cn.web.open.controller;import javax.annotation.Resource;import javax.servlet.http.HttpServletRequest;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;import cn.web.open.model.User;import cn.web.open.service.UserService;@Controller//@RequestMapping(&quot;/user&quot;)public class UserController &#123; @Resource private UserService userService; @RequestMapping(&quot;/login&quot;) public String login(HttpServletRequest request, Model model) &#123; String code = request.getParameter(&quot;usercode&quot;); String pwd = request.getParameter(&quot;password&quot;); User user_login = userService.findById(code,pwd); System.out.println(&quot;---&gt;&quot;+user_login); if (null == user_login) &#123; System.out.println(&quot;Error login!&quot;); return &quot;redirect:index.jsp?oper=error&quot;; &#125; else &#123; model.addAttribute(&quot;user&quot;, user_login); return &quot;pages/success&quot;; &#125; &#125;&#125; sql语句文件mappers/userMapper.xml 1234567891011121314151617181920&lt;pre name=&quot;code&quot; class=&quot;html&quot;&gt;&lt;pre name=&quot;code&quot; class=&quot;html&quot;&gt;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;cn.web.open.dao.UserDao&quot;&gt; &lt;resultMap type=&quot;User&quot; id=&quot;UserResult&quot;&gt; &lt;result column=&quot;USER_CODE&quot; property=&quot;userCode&quot; /&gt; &lt;result column=&quot;USER_NAME&quot; property=&quot;userName&quot; /&gt; &lt;result column=&quot;USER_PWD&quot; property=&quot;userPwd&quot; /&gt; &lt;/resultMap&gt; &lt;!-- 查询条件:账号密码用户类型. 0第一个参数,1第二个参数,对应dao接口参数 --&gt; &lt;select id=&quot;findById&quot; parameterType=&quot;String&quot; resultMap=&quot;UserResult&quot;&gt; SELECT USER_CODE,USER_NAME,USER_PWD FROM BLOG_USER WHERE USER_CODE=#&#123;0&#125; AND USER_PWD=#&#123;1&#125; AND USER_TYPE=2 &lt;/select&gt; &lt;!-- &lt;select id=&quot;getAllUsers&quot; resultMap=&quot;userResult&quot;&gt; SELECT USER_CODE,USER_NAME,USER_PWD,CREATE_DATE FROM BLOG_USER &lt;/select&gt; --&gt;&lt;/mapper&gt; (3)前台的一些测试页面WEB_INF下文件不能通过URL直接访问,登录页面网上拿了别人做了一个页面，挺有趣的，访问工程地址,端口你自己配的,输入管理员类型的账号测试刚开始对于各种注解的使用不甚了解鼓捣了许久,用maven管理项目构建时也碰到许多小问题，着实查了许多资料,下过别人的demo参考，总算是把ssm这一套搭起来了，如果发现有问题，请留言指教。demo下载http://download.csdn.net/detail/u012809062/9486330","categories":[{"name":"技术","slug":"技术","permalink":"https://zgshen.me/categories/技术/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://zgshen.me/tags/Spring/"}]},{"title":"MySQL入门接触记录--从安装到Java通过JDBC连接MySQL数据库","slug":"MySQL入门接触记录--从安装到Java通过JDBC连接MySQL数据库","date":"2015-12-11T16:00:00.000Z","updated":"2019-03-03T14:46:53.846Z","comments":true,"path":"2015/12/12/MySQL入门接触记录--从安装到Java通过JDBC连接MySQL数据库/","link":"","permalink":"https://zgshen.me/2015/12/12/MySQL入门接触记录--从安装到Java通过JDBC连接MySQL数据库/","excerpt":"一、安装MySQL1.本人用的版本是mysql-5.6.24-winx64解压免装版，链接：http://xiazai.zol.com.cn/detail/4/33431.shtml解压后找到my-default.ini文件，复制改名为my.ini，修改添加以下语句：","text":"一、安装MySQL1.本人用的版本是mysql-5.6.24-winx64解压免装版，链接：http://xiazai.zol.com.cn/detail/4/33431.shtml解压后找到my-default.ini文件，复制改名为my.ini，修改添加以下语句：[client]port=3306default-character-set=utf8 [mysqld]port=3306character_set_server=utf8 #以下路径为你解压到的文件夹basedir = D:\\Program Files\\mysql-5.6.24-winx64datadir = D:\\Program Files\\mysql-5.6.24-winx64\\datasql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES2.配置环境变量：计算机-属性-高级系统设置-高级-环境变量，在Path中添加D:\\Program Files\\mysql-5.6.24-winx64\\bin路径依然根据自己所解压到的路径决定，注意添加时前面用；分号隔开。3.win+r进dos，cd到解压文件目录的bin文件下安装服务：mysqld -install启动服务:net start mysql如果要删除服务，命令为：mysqld -remove安装结束———- 二、创建数据库和表以一个简单例子为例，步骤如下:win+r进dos并cd到解压路径的bin文件下，执行mysql -uroot -p因为初始密码为空，直接回车，如图 show databases; 显示目前所有的数据库create database 库名; 因为之前person已经创建过，所有提示存在创建完我们使用它，use person; 接着创建一个表名student的表,有两个简单的属性, 命令:create table &lt;表名&gt; (&lt;字段名 1&gt; &lt;类型 1&gt; [,..&lt;字段名 n&gt; &lt;类型 n&gt;]); 具体如下: 查看表结构命令: show columns from 表名;插入数据命令:insert into &lt;表名&gt; [( &lt;字段名 1&gt;[,..&lt;字段名 n &gt; ])] values ( 值 1 )[, ( 值 n )]以下随便插入两个select * from 表名; 显示表所有内容 三、在eclipse上通过JDBC连接MySQl数据库1.下载对应MySQL的驱动包 http://dev.mysql.com/downloads/connector/j/解压驱动包，eclipse新建一个java工程MysqlDemo，复制驱动包的.jar文件，在java工程右键paste，接着在.jar包右键Build Path - Configure Build Path,这样驱动就加载进来了 测试程序参考自http://qq163230530.blog.163.com/blog/static/4289250620081186262719/12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import java.sql.*;public class MysqlDemo &#123; public static void main(String[] args) &#123; //声明Connection对象 Connection con; //驱动程序名 String driver = \"com.mysql.jdbc.Driver\"; //URL指向要访问的数据库名mydata String url = \"jdbc:mysql://localhost:3306/person\"; //MySQL配置时的用户名 String user = \"root\"; //MySQL配置时的密码 String password = \"\"; //遍历查询结果集 try &#123; //加载驱动程序 Class.forName(driver); //1.getConnection()方法，连接MySQL数据库！！ con = DriverManager.getConnection(url,user,password); if(!con.isClosed()) System.out.println(\"Succeeded connecting to the Database!\"); //2.创建statement类对象，用来执行SQL语句！！ Statement statement = con.createStatement(); //要执行的SQL语句 String sql = \"select * from student\"; //3.ResultSet类，用来存放获取的结果集！！ ResultSet rs = statement.executeQuery(sql); System.out.println(\"-----------------\"); System.out.println(\"执行结果如下所示:\"); System.out.println(\"-----------------\"); System.out.println(\" 学号\" + \"\\t\" + \" 姓名\"); System.out.println(\"-----------------\"); String name = null; String id = null; while(rs.next())&#123; //获取stuname这列数据 name = rs.getString(\"name\"); //获取stuid这列数据 id = rs.getString(\"id\"); //首先使用ISO-8859-1字符集将name解码为字节序列并将结果存储新的字节数组中。 //然后使用GB2312字符集解码指定的字节数组。 name = new String(name.getBytes(\"ISO-8859-1\"),\"gb2312\"); //输出结果 System.out.println(id + \"\\t\" + name); &#125; rs.close(); con.close(); &#125; catch(ClassNotFoundException e) &#123; //数据库驱动类异常处理 System.out.println(\"Sorry,can`t find the Driver!\"); e.printStackTrace(); &#125; catch(SQLException e) &#123; //数据库连接失败异常处理 e.printStackTrace(); &#125;catch (Exception e) &#123; // TODO: handle exception e.printStackTrace(); &#125;finally&#123; System.out.println(\"数据库数据成功获取！！\"); &#125; &#125;&#125; run结果 印象流程大概这样，水平有限，记录。","categories":[{"name":"技术","slug":"技术","permalink":"https://zgshen.me/categories/技术/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://zgshen.me/tags/数据库/"}]},{"title":"avr单片机三种时钟模式","slug":"avr单片机三种时钟模式","date":"2015-05-03T16:00:00.000Z","updated":"2017-05-06T14:54:52.040Z","comments":true,"path":"2015/05/04/avr单片机三种时钟模式/","link":"","permalink":"https://zgshen.me/2015/05/04/avr单片机三种时钟模式/","excerpt":"","text":"AVR单片机时钟有三种模式：1、内部时钟源，可分为内部晶振和外部晶振，用的是单片机内部的振荡电路。内部晶振可以设置1M、2M、4M、8MHz晶振频率，外部可支持到16MHz（MEGA16或者MEGA16A）MEGA16L可支持最高8MHz的外部晶振（通过熔丝设置）。2、外部时钟源，靠外部振荡电路提供时钟，可以用外部同步时钟信号（如用其他单片机提供时钟）或者外部振荡器（如有源晶振）将此信号接到单片机XTAL1端口，熔丝设置为外部时钟即可（不是外部晶振）。3、设置晶振熔丝错误会导致芯片锁死，如果设置为外部晶振，直接加晶振即可解除，设置为外部时钟源，那只好提供外部时钟才能解除（有源晶振）。","categories":[],"tags":[{"name":"其他","slug":"其他","permalink":"https://zgshen.me/tags/其他/"}]},{"title":"opencv简单的彩色图像灰度化和二值化（学习笔记）","slug":"opencv简单的彩色图像灰度化和二值化（学习笔记）","date":"2015-05-03T16:00:00.000Z","updated":"2019-03-03T14:47:17.004Z","comments":true,"path":"2015/05/04/opencv简单的彩色图像灰度化和二值化（学习笔记）/","link":"","permalink":"https://zgshen.me/2015/05/04/opencv简单的彩色图像灰度化和二值化（学习笔记）/","excerpt":"图像的灰度化即是将彩色图像转化成为灰度图像的过程成为图像的灰度化处理。彩色图像中的每个像素的颜色有R、G、B三个分量决定，而每个分量有255中值可取，这样一个像素点可以有1600多万（255255255）的颜色的变化范围。而灰度图像是R、G、B三个分量相同的一种特殊的彩色图像，其一个像素点的变化范围为255种，所以在数字图像处理种一般先将各种格式的图像转变成灰度图像以使后续的图像的计算量变得少一些。灰度图像的描述与彩色图像一样仍然反映了整幅图像的整体和局部的色度和亮度等级的分布和特征。图像的灰度化处理可用两种方法来实现。 图像的二值化是将图像上的像素点的灰度值设置为0或255，也就是将整个图像呈现出明显的黑白效果。要对RGB彩色图像进行二值化一般首先要对图像进行灰度化处理。","text":"图像的灰度化即是将彩色图像转化成为灰度图像的过程成为图像的灰度化处理。彩色图像中的每个像素的颜色有R、G、B三个分量决定，而每个分量有255中值可取，这样一个像素点可以有1600多万（255255255）的颜色的变化范围。而灰度图像是R、G、B三个分量相同的一种特殊的彩色图像，其一个像素点的变化范围为255种，所以在数字图像处理种一般先将各种格式的图像转变成灰度图像以使后续的图像的计算量变得少一些。灰度图像的描述与彩色图像一样仍然反映了整幅图像的整体和局部的色度和亮度等级的分布和特征。图像的灰度化处理可用两种方法来实现。 图像的二值化是将图像上的像素点的灰度值设置为0或255，也就是将整个图像呈现出明显的黑白效果。要对RGB彩色图像进行二值化一般首先要对图像进行灰度化处理。例子12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061 #include \"cv.h\" #include \"highgui.h\" #include &lt;cvaux.h&gt; int main(int argc, char *argv[]) &#123; IplImage* img; IplImage* img0; IplImage* img1; img = cvLoadImage(\"test.jpg\");//默认初始图像放在工程文件下 //IplImage* img1 = img; if (NULL == img) return 0;//灰度化操作 img0 = cvCreateImage(cvGetSize(img),IPL_DEPTH_8U,1);//申请一段内存 cvCvtColor(img,img0,CV_BGR2GRAY);//图像数据复制 img1 = cvCreateImage(cvGetSize(img),IPL_DEPTH_8U,1);//申请一段内存 cvCopy(img0, img1, NULL);//数据复制，若直接赋值相当指针指向同一地址会对原本img0操作//二值化操作 int height = img1-&gt;height; int width = img1-&gt;width; int step = img1-&gt;widthStep; int channels = img1-&gt;nChannels; uchar *data = (uchar*)img1-&gt;imageData; for(int i=0;i != height; ++ i) &#123; for(int j=0;j != width; ++ j) &#123; for(int k=0;k != channels; ++ k) &#123; if(data[i*step+j*channels+k]&lt;128) data[i*step+j*channels+k]=0;//255-data[i*step+j*channels+k]; else data[i*step+j*channels+k]=255;//255-data[i*step+j*channels+k]; &#125; &#125; &#125;//创建窗口、显示图像、销毁图像、释放图像 cvNamedWindow( \"test1\", 0 ); cvShowImage(\"test1\", img0); cvNamedWindow( \"test\", 0 ); cvShowImage(\"test\", img1); cvWaitKey(0); cvDestroyWindow( \"test1\" ); cvDestroyWindow( \"test\" ); cvReleaseImage( &amp;img0 ); cvReleaseImage( &amp;img1 ); return 0; &#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://zgshen.me/categories/技术/"}],"tags":[{"name":"其他","slug":"其他","permalink":"https://zgshen.me/tags/其他/"}]}]}